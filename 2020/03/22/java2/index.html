<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    java2 |
    
    yuchen</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/technology.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <section class="outer">
  <article id="post-java2" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java2
    </h1>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2020/03/22/java2/" class="article-date">
  <time datetime="2020-03-22T13:25:41.000Z" itemprop="datePublished">2020-03-22</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>从JDKS开始，Java增加了对元数据(MctaData)的支持，也就是Annotation (即注解，偶尔也被翻译为注释),本章所介绍的<strong>注解，其实是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。通过使用注解，程序开发人员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充的信息。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。</strong>代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</p>
<p>注解提供了一种为程序元素设置元数据的方法，从某些方面来看，注解就像修饰符一一样， 可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被存储在注解的“name = value” 对中。</p>
<p><strong>注解是一个接口，程序可以通过反射来获取指定程序元素的java.lang.annotation.Annotation对象，然后通过java.lang.annotation.Annotation对象来取得注解里的元数据</strong>。</p>
<h2 id="内置的注解"><a href="#内置的注解" class="headerlink" title="内置的注解"></a>内置的注解</h2><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p>
<h3 id="作用在代码的注解是"><a href="#作用在代码的注解是" class="headerlink" title="作用在代码的注解是"></a>作用在代码的注解是</h3><ul>
<li>@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li>
<li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li>
<li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。<br>作用在其他注解的注解(或者说 元注解)是:</li>
<li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li>
<li>@Documented - 标记这些注解是否包含在用户文档中。</li>
<li>@Target - 标记这个注解应该是哪种 Java 成员。</li>
<li>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)<br>从 Java 7 开始，额外添加了 3 个注解:</li>
<li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li>
<li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li>
<li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。<h2 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h2></li>
<li>@Override</li>
<li>@Deprecated</li>
<li>@Suppress Warmings</li>
<li>@SafeVarargs</li>
<li>@FunctionalInterface</li>
</ul>
<p>上面5个基本注解中的@SafeVarargs是Java 7新增的、Functionalntrface是Java 8新增的。这5<br>个基本的注解都定义在java.lang包下，读者可以通过查阅它们的API文档来了解关于它们的更多细节。</p>
<h2 id="Annotation架构"><a href="#Annotation架构" class="headerlink" title="Annotation架构"></a>Annotation架构</h2><p><img src="/2020/03/22/java2/174.jpg" alt></p>
<p>从中，我们可以看出：</p>
<p><strong>(01) 1 个 Annotation 和 1 个 RetentionPolicy 关联。</strong><br>可以理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性。</p>
<p><strong>(02) 1 个 Annotation 和 1~n 个 ElementType 关联。</strong><br>可以理解为：对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性。</p>
<p><strong>(03) Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。</strong><br>Annotation 的每一个实现类，都 “和 1 个 RetentionPolicy 关联” 并且 “ 和 1~n 个 ElementType 关联”。</p>
<h2 id="2、Annotation-组成部分"><a href="#2、Annotation-组成部分" class="headerlink" title="2、Annotation 组成部分"></a>2、Annotation 组成部分</h2><p>java Annotation 的组成中，有 3 个非常重要的主干类。它们分别是：</p>
<ul>
<li>Annotation.java</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package java.lang.annotation;</span><br><span class="line">public interface Annotation &#123;</span><br><span class="line"></span><br><span class="line">    boolean equals(Object obj);</span><br><span class="line"></span><br><span class="line">    int hashCode();</span><br><span class="line"></span><br><span class="line">    String toString();</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ElementType.java</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package java.lang.annotation;</span><br><span class="line"></span><br><span class="line">public enum ElementType &#123;</span><br><span class="line">    TYPE,               /* 类、接口（包括注释类型）或枚举声明  */</span><br><span class="line"></span><br><span class="line">    FIELD,              /* 字段声明（包括枚举常量）  */</span><br><span class="line"></span><br><span class="line">    METHOD,             /* 方法声明  */</span><br><span class="line"></span><br><span class="line">    PARAMETER,          /* 参数声明  */</span><br><span class="line"></span><br><span class="line">    CONSTRUCTOR,        /* 构造方法声明  */</span><br><span class="line"></span><br><span class="line">    LOCAL_VARIABLE,     /* 局部变量声明  */</span><br><span class="line"></span><br><span class="line">    ANNOTATION_TYPE,    /* 注释类型声明  */</span><br><span class="line"></span><br><span class="line">    PACKAGE             /* 包声明  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>RetentionPolicy.java</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package java.lang.annotation;</span><br><span class="line">public enum RetentionPolicy &#123;</span><br><span class="line">    SOURCE,            /* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */</span><br><span class="line"></span><br><span class="line">    CLASS,             /* 编译器将Annotation存储于类对应的.class文件中。默认行为  */</span><br><span class="line"></span><br><span class="line">    RUNTIME            /* 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<br><strong>(01) Annotation 就是个接口。</strong><br>“每 1 个 Annotation” 都与 “1 个 RetentionPolicy” 关联，并且与 “1～n 个 ElementType” 关联。可以通俗的理解为：每 1 个 Annotation 对象，都会有唯一的 RetentionPolicy 属性；至于 ElementType 属性，则有 1~n 个。<br><strong>(02) ElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型。</strong><br>“每 1 个 Annotation” 都与 “1～n 个 ElementType” 关联。当 Annotation 与某个 ElementType 关联时，就意味着：Annotation有了某种用途。例如，若一个 Annotation 对象是 METHOD 类型，则该 Annotation 只能用来修饰方法。<br><strong>(03) RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同。</strong><br>“每 1 个 Annotation” 都与 “1 个 RetentionPolicy” 关联。</p>
<ul>
<li>a) 若 Annotation 的类型为 SOURCE，则意味着：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了。 例如，” @Override” 标志就是一个 Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”@Override” 就没有任何作用了。</li>
<li>b) 若 Annotation 的类型为 CLASS，则意味着：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为。</li>
<li>c) 若 Annotation 的类型为 RUNTIME，则意味着：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入。</li>
</ul>
<h2 id="Annotation-通用定义"><a href="#Annotation-通用定义" class="headerlink" title="Annotation 通用定义"></a>Annotation 通用定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotation1 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<br>上面的作用是定义一个 Annotation，它的名字是 MyAnnotation1。定义了 MyAnnotation1 之后，我们可以在代码中通过 “@MyAnnotation1” 来使用它。 其它的，@Documented, @Target, @Retention, @interface 都是来修饰 MyAnnotation1 的。下面分别说说它们的含义：</p>
<p><strong>(01) @interface</strong></p>
<p>使用 @interface 定义注解时，意味着它实现了 java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。<br>定义 Annotation 时，@interface 是必须的。<br>注意：它和我们通常的 implemented 实现接口的方法不同。Annotation 接口的实现细节都由编译器完成。通过 @interface 定义注解后，该注解不能继承其他的注解或接口。</p>
<p><strong>(02) @Documented</strong></p>
<p>类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。<br>定义 Annotation 时，@Documented 可有可无；若没有定义，则 Annotation 不会出现在 javadoc 中。</p>
<p><strong>(03) @Target(ElementType.TYPE)</strong></p>
<p>前面我们说过，ElementType 是 Annotation 的类型属性。而 @Target 的作用，就是来指定 Annotation 的类型属性。<br>@Target(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE。这就意味着，MyAnnotation1 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。<br>定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方。</p>
<p><strong>(04) @Retention(RetentionPolicy.RUNTIME)</strong></p>
<p>前面我们说过，RetentionPolicy 是 Annotation 的策略属性，而 @Retention 的作用，就是指定 Annotation 的策略属性。<br>@Retention(RetentionPolicy.RUNTIME) 的意思就是指定该 Annotation 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。<br>定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS。</p>
<h3 id="重写父类方法-Override"><a href="#重写父类方法-Override" class="headerlink" title="重写父类方法@Override"></a>重写父类方法@Override</h3><p>@Override就是用来指定方法覆载的，它可以强制一个子类必须覆盖父类的方法。如下程序中使用@Overide指定子类Apple的info()方法必须重写父类方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Fruit&#123;</span><br><span class="line">	public void info()&#123;</span><br><span class="line">		System.out .printIn(&quot;水果的info方法...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Apple extends Fruit&#123;</span><br><span class="line"></span><br><span class="line">	//使用@override指定下面方法必须重写父类方法</span><br><span class="line">	@Override</span><br><span class="line">	public void info()&#123;</span><br><span class="line">		System.out. printIn(&quot;苹果重写水果的info方法..&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><blockquote>
<p>若某个方法被 @Deprecated 标注，则该方法不再被建议使用。如果有开发人员试图使用或重写被 @Deprecated 标示的方法，编译器会给相应的提示信息。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Calendar;</span><br><span class="line"></span><br><span class="line">public class DeprecatedTest &#123;</span><br><span class="line">    // @Deprecated 修饰 getString1(),表示 它是建议不被使用的函数</span><br><span class="line">    @Deprecated</span><br><span class="line">    private static void getString1()&#123;</span><br><span class="line">        System.out.println(&quot;Deprecated Method&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static void getString2()&#123;</span><br><span class="line">        System.out.println(&quot;Normal Method&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Date是日期/时间类。java已经不建议使用该类了</span><br><span class="line">    private static void testDate() &#123;</span><br><span class="line">        Date date = new Date(113, 8, 25);</span><br><span class="line">        System.out.println(date.getYear());</span><br><span class="line">    &#125;</span><br><span class="line">    // Calendar是日期/时间类。java建议使用Calendar取代Date表示&quot;日期/时间&quot;</span><br><span class="line">    private static void testCalendar() &#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        System.out.println(cal.get(Calendar.YEAR));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        getString1(); </span><br><span class="line">        getString2();</span><br><span class="line">        testDate(); </span><br><span class="line">        testCalendar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较类中 “getString1() 和 getString2()” 以及 “testDate() 和 testCalendar()” 。</p>
<ul>
<li>(01) getString1() 被 @Deprecated 标注，意味着建议不再使用 getString1(); 所以 getString1() 的定义和调用时，都会一横线。这一横线是eclipse() 对 @Deprecated 方法的处理。<br>getString2() 没有被 @Deprecated 标注，它的显示正常。</li>
<li>(02) testDate() 调用了 Date 的相关方法，而 java 已经建议不再使用 Date 操作日期/时间。因此，在调用 Date的API 时，会产生警告信息，途中的 warnings。</li>
<li>testCalendar() 调用了 Calendar 的 API 来操作日期/时间，java 建议用 Calendar 取代 Date。因此，操作 Calendar 不会产生 warning。</li>
</ul>
<h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><blockquote>
<p>假设，我们定义了某个 Annotaion，它的名称是 MyAnnotation，并且 MyAnnotation 被标注为 @Inherited。现在，某个类 Base 使用了<br>MyAnnotation，则 Base 具有了”具有了注解 MyAnnotation”；现在，Sub 继承了 Base，由于 MyAnnotation 是 @Inherited的(具有继承性)，所以，Sub 也 “具有了注解 MyAnnotation”。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Inherited;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义的Annotation。</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Inherited</span><br><span class="line">@interface Inheritable</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Inheritable</span><br><span class="line">class InheritableFather</span><br><span class="line">&#123;</span><br><span class="line">    public InheritableFather() &#123;</span><br><span class="line">        // InheritableBase是否具有 Inheritable Annotation</span><br><span class="line">        System.out.println(&quot;InheritableFather:&quot;+InheritableFather.class.isAnnotationPresent(Inheritable.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * InheritableSon 类只是继承于 InheritableFather，</span><br><span class="line"> */</span><br><span class="line">public class InheritableSon extends InheritableFather</span><br><span class="line">&#123;</span><br><span class="line">    public InheritableSon() &#123;</span><br><span class="line">        super();    // 调用父类的构造函数</span><br><span class="line">        // InheritableSon类是否具有 Inheritable Annotation</span><br><span class="line">        System.out.println(&quot;InheritableSon:&quot;+InheritableSon.class.isAnnotationPresent(Inheritable.class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        InheritableSon is = new InheritableSon();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InheritableFather:true</span><br><span class="line">InheritableSon:true</span><br></pre></td></tr></table></figure>

<p>现在，我们对 InheritableSon.java 进行修改：注释掉”Inheritable 的 @Inherited 注解”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Inherited;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义的Annotation。</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">//@Inherited</span><br><span class="line">@interface Inheritable</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Inheritable</span><br><span class="line">class InheritableFather</span><br><span class="line">&#123;</span><br><span class="line">    public InheritableFather() &#123;</span><br><span class="line">        // InheritableBase是否具有 Inheritable Annotation</span><br><span class="line">        System.out.println(&quot;InheritableFather:&quot;+InheritableFather.class.isAnnotationPresent(Inheritable.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * InheritableSon 类只是继承于 InheritableFather，</span><br><span class="line"> */</span><br><span class="line">public class InheritableSon extends InheritableFather</span><br><span class="line">&#123;</span><br><span class="line">    public InheritableSon() &#123;</span><br><span class="line">        super();    // 调用父类的构造函数</span><br><span class="line">        // InheritableSon类是否具有 Inheritable Annotation</span><br><span class="line">        System.out.println(&quot;InheritableSon:&quot;+InheritableSon.class.isAnnotationPresent(Inheritable.class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        InheritableSon is = new InheritableSon();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InheritableFather:true</span><br><span class="line">InheritableSon:false</span><br></pre></td></tr></table></figure>
<p>对比上面的两个结果，我们发现：当注解 Inheritable 被 @Inherited 标注时，它具有继承性。否则，没有继承性。</p>
<h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><blockquote>
<p>SuppressWarnings 的作用是，让编译器对”它所标注的内容”的某些警告保持静默。例如，”@SuppressWarnings(value={“deprecation”, “unchecked”})” 表示对”它所标注的内容”中的 “SuppressWarnings 不再建议使用警告”和”未检查的转换时的警告”保持沉默。示例如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class SuppressWarningTest &#123;</span><br><span class="line"></span><br><span class="line">    //@SuppressWarnings(value=&#123;&quot;deprecation&quot;&#125;)</span><br><span class="line">    public static void doSomething()&#123;</span><br><span class="line">        Date date = new Date(113, 8, 26);</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<br>(01) 左边的图中，没有使用 @SuppressWarnings(value={“deprecation”}) , 而 Date 属于 java 不再建议使用的类。因此，调用 Date 的 API 时，会产生警告。而右边的途中，使用了 @SuppressWarnings(value={“deprecation”})。因此，编译器对”调用 Date 的 API 产生的警告”保持沉默。 </p>
<p>补充：SuppressWarnings 常用的关键字的表格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deprecation  -- 使用了不赞成使用的类或方法时的警告</span><br><span class="line">unchecked    -- 执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。</span><br><span class="line">fallthrough  -- 当 Switch 程序块直接通往下一种情况而没有 Break 时的警告。</span><br><span class="line">path         -- 在类路径、源文件路径等中有不存在的路径时的警告。</span><br><span class="line">serial       -- 当在可序列化的类上缺少 serialVersionUID 定义时的警告。</span><br><span class="line">finally      -- 任何 finally 子句不能正常完成时的警告。</span><br><span class="line">all          -- 关于以上所有情况的警告。</span><br></pre></td></tr></table></figure>
<h2 id="重复注解-Repeatable"><a href="#重复注解-Repeatable" class="headerlink" title="重复注解@Repeatable"></a>重复注解@Repeatable</h2><p><strong>在Java8以前，同一个程序元素前最多只能使用一个相同类型的注解:如果需要在同一个元素前使用多个相同类型的注解，则必须使用注解“容器”。</strong>例如在Stuts 2开发中，有时需要在Action类上使用多个@Result注解。在Java 8以前只能写成如下形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Results (&#123;@Result (name=&quot;failure&quot;, location = &quot;failed.jsp&quot;),@Result(name=&quot;success&quot;, location = &quot;success.jsp&quot;)&#125;)</span><br><span class="line">public Acton FooAction&#123; ... )</span><br></pre></td></tr></table></figure>

<p>上面代码中使用了两个@Result注解，但由于传统Java语法不允许多次使用@Result修饰同个类，因此程序必须使用@Results注解作为两个@Result的容器–实质是，@Results注解只包含一个名字为value、类型为Result[]的成员变量，程序指定的多个@Result将作为@Results的value属性(数组类型)的数组元素。</p>
<p><strong>从Java 8开始，上面语法可以得到简化: Java 8允许使用多个相同类型的注解来修饰同一个类</strong>，因此上面代码可能(之所以说可能，是因为重复注解还需要对原来的注解进行改造)可简化为如下形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Result (name=&quot;failure&quot;, location =&quot;failed.jsp&quot;)</span><br><span class="line">@Result (name=&quot;success&quot;, location =&quot;success.jsp&quot;)</span><br><span class="line">public Acton FooAction&#123; ...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义一个注解"><a href="#定义一个注解" class="headerlink" title="定义一个注解"></a>定义一个注解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Repeatable(FkTags.class)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface FkTag &#123;</span><br><span class="line">	String name() default &quot;玄烨散人&quot;;</span><br><span class="line">	int age();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义一个”容器”注解"><a href="#定义一个”容器”注解" class="headerlink" title="定义一个”容器”注解"></a>定义一个”容器”注解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface FkTags &#123;</span><br><span class="line">	//该成员变量可以接受多个@FkTag注解</span><br><span class="line">	FkTag[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@FkTag(age=19)</span><br><span class="line">@FkTag(name=&quot;金烨&quot;,age=18)</span><br><span class="line">public class FkTagTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Class&lt;FkTagTest&gt; class1 = FkTagTest.class;</span><br><span class="line">		/*Java8新增的getDeclaredAnnotationsByType()方法获取*/</span><br><span class="line">		FkTag[] tags = class1.getDeclaredAnnotationsByType(FkTag.class);</span><br><span class="line">		</span><br><span class="line">		for(FkTag tag :tags) &#123;</span><br><span class="line">			System.out.println(tag.name()+&quot;--&gt;&quot;+tag.age());</span><br><span class="line">		&#125;</span><br><span class="line">		FkTags fkTags = class1.getDeclaredAnnotation(FkTags.class);</span><br><span class="line">		System.out.println(fkTags);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型注解-Target-ElementType-TYPE-USE"><a href="#类型注解-Target-ElementType-TYPE-USE" class="headerlink" title="类型注解@Target(ElementType.TYPE_USE)"></a>类型注解@Target(ElementType.TYPE_USE)</h2><p>Java8为ElementType枚举增加了TYPE_PARAMETER,TYPE_USE两个枚举值，这样就允许定义枚举时使用@Targe(ElementType.TYPF_USE)修饰，这种注解被称为类型注解(Type Annotation),类型注解可用于修饰在任何地方出现的类型</p>
<p>在Java8以前，只能在定义各种程序元素(定义类、定义接口、定义方法、定义成员变….时,使用注解。从Java 8开始，类型注解可以修饰在任何地方出现的类型。比如，允许在如下位置使用类型注解。</p>
<ul>
<li>创建对象(用new关键字创建)。</li>
<li>类型转换。</li>
<li>使用implements实现接口。</li>
<li>使用throws声明抛出异常。<br>上面这些情形都会用到类型，因此都可以使用类型注解来修饰。<br>下面程序将会定义一一个简单的类型注解，然后就可在任何用到类型的地方使用类型注解了，读者可通过该示例了解类型注解无处不在的神奇魔力。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//定义一个简单的类型注解，不带任何成员变量</span><br><span class="line">@Target (ElementType.TYPE_USE)</span><br><span class="line">@interface NotNull&#123;&#125;</span><br><span class="line">// 定义类时使用类型注解</span><br><span class="line">@NotNull</span><br><span class="line">public class TypeAnnotationTest implements @NotNull /* implements 时使用类型注解*/ Serializable</span><br><span class="line">&#123;</span><br><span class="line">	//方法形参中使用类型注解</span><br><span class="line">	public static void main(@NotNull String[] args)throws @NotNull    FileNotFoundException&#123;</span><br><span class="line">	//throws时使用类型注解</span><br><span class="line">	Object obj = &quot;fkjava.org&quot;;</span><br><span class="line">	//强制类型转换时使用类型注解</span><br><span class="line">	String str = (@NotNull String) obj;</span><br><span class="line">	//创建对象时使用类型注解</span><br><span class="line">	Object win = new @NotNull JFrame (&quot;疯狂软件&quot;) ;</span><br><span class="line">	&#125;</span><br><span class="line">	//泛型中使用类型注解</span><br><span class="line">	public void foo(List&lt;@NotNull String&gt; info)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Annotation-的作用"><a href="#Annotation-的作用" class="headerlink" title="Annotation 的作用"></a>Annotation 的作用</h2><p>Annotation 是一个辅助类，它在 Junit、Struts、Spring 等工具框架中被广泛使用。<br>我们在编程中经常会使用到的 Annotation 作用有：</p>
<h3 id="1-编译检查"><a href="#1-编译检查" class="headerlink" title="1.编译检查"></a>1.编译检查</h3><p>Annotation 具有”让编译器进行编译检查的作用”。<br>例如，@SuppressWarnings, @Deprecated 和 @Override 都具有编译检查作用。<br>(02) 若某个方法被 @Override 的标注，则意味着该方法会覆盖父类中的同名方法。如果有方法被 @Override 标示，但父类中却没有”被 @Override 标注”的同名方法，则编译器会报错。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class OverrideTest &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * toString() 在java.lang.Object中定义；</span><br><span class="line">     * 因此，这里用 @Override 标注是对的。</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;Override toString&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * getString() 没有在OverrideTest的任何父类中定义；</span><br><span class="line">     * 但是，这里却用 @Override 标注，因此会产生编译错误！</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public String getString()&#123;</span><br><span class="line">        return &quot;get toString&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-在反射中使用-Annotation"><a href="#2-在反射中使用-Annotation" class="headerlink" title="2.在反射中使用 Annotation"></a>2.在反射中使用 Annotation</h3><p>在反射的 Class, Method, Field 等函数中，有许多于 Annotation 相关的接口。<br>这也意味着，我们可以在反射中解析并使用 Annotation。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Annotation在反射函数中的使用示例</span><br><span class="line"> */</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@interface MyAnnotation &#123;</span><br><span class="line">    String[] value() default &quot;unknown&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Person类。它会使用MyAnnotation注解。</span><br><span class="line"> */</span><br><span class="line">class Person &#123;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * empty()方法同时被 &quot;@Deprecated&quot; 和 &quot;@MyAnnotation(value=&#123;&quot;a&quot;,&quot;b&quot;&#125;)&quot;所标注 </span><br><span class="line">     * (01) @Deprecated，意味着empty()方法，不再被建议使用</span><br><span class="line">     * (02) @MyAnnotation, 意味着empty() 方法对应的MyAnnotation的value值是默认值&quot;unknown&quot;</span><br><span class="line">     */</span><br><span class="line">    @MyAnnotation</span><br><span class="line">    @Deprecated</span><br><span class="line">    public void empty()&#123;</span><br><span class="line">        System.out.println(&quot;\nempty&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * sombody() 被 @MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;) 所标注，</span><br><span class="line">     * @MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;), 意味着MyAnnotation的value值是&#123;&quot;girl&quot;,&quot;boy&quot;&#125;</span><br><span class="line">     */</span><br><span class="line">    @MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;)</span><br><span class="line">    public void somebody(String name, int age)&#123;</span><br><span class="line">        System.out.println(&quot;\nsomebody: &quot;+name+&quot;, &quot;+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AnnotationTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        </span><br><span class="line">        // 新建Person</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        // 获取Person的Class实例</span><br><span class="line">        Class&lt;Person&gt; c = Person.class;</span><br><span class="line">        // 获取 somebody() 方法的Method实例</span><br><span class="line">        Method mSomebody = c.getMethod(&quot;somebody&quot;, new Class[]&#123;String.class, int.class&#125;);</span><br><span class="line">        // 执行该方法</span><br><span class="line">        mSomebody.invoke(person, new Object[]&#123;&quot;lily&quot;, 18&#125;);</span><br><span class="line">        iteratorAnnotations(mSomebody);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        // 获取 somebody() 方法的Method实例</span><br><span class="line">        Method mEmpty = c.getMethod(&quot;empty&quot;, new Class[]&#123;&#125;);</span><br><span class="line">        // 执行该方法</span><br><span class="line">        mEmpty.invoke(person, new Object[]&#123;&#125;);        </span><br><span class="line">        iteratorAnnotations(mEmpty);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void iteratorAnnotations(Method method) &#123;</span><br><span class="line"></span><br><span class="line">        // 判断 somebody() 方法是否包含MyAnnotation注解</span><br><span class="line">        if(method.isAnnotationPresent(MyAnnotation.class))&#123;</span><br><span class="line">            // 获取该方法的MyAnnotation注解实例</span><br><span class="line">            MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class);</span><br><span class="line">            // 获取 myAnnotation的值，并打印出来</span><br><span class="line">            String[] values = myAnnotation.value();</span><br><span class="line">            for (String str:values)</span><br><span class="line">                System.out.printf(str+&quot;, &quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 获取方法上的所有注解，并打印出来</span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        for(Annotation annotation : annotations)&#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">somebody: lily, 18</span><br><span class="line">girl, boy, </span><br><span class="line">@com.skywang.annotation.MyAnnotation(value=[girl, boy])</span><br><span class="line"></span><br><span class="line">empty</span><br><span class="line">unknown, </span><br><span class="line">@com.skywang.annotation.MyAnnotation(value=[unknown])</span><br><span class="line">@java.lang.Deprecated()</span><br></pre></td></tr></table></figure>

<h3 id="3-根据-Annotation-生成帮助文档"><a href="#3-根据-Annotation-生成帮助文档" class="headerlink" title="3.根据 Annotation 生成帮助文档"></a>3.根据 Annotation 生成帮助文档</h3><p>通过给 Annotation 注解加上 @Documented 标签，能使该 Annotation 标签出现在 javadoc 中。</p>
<h3 id="4-能够帮忙查看查看代码"><a href="#4-能够帮忙查看查看代码" class="headerlink" title="4.能够帮忙查看查看代码"></a>4.能够帮忙查看查看代码</h3><p>通过 @Override, @Deprecated 等，我们能很方便的了解程序的大致结构。<br>另外，我们也可以通过自定义 Annotation 来实现一些功能。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><img src="/2020/03/22/java2/image174.png" alt></p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul>
<li>Collection接口是最基本的集合接口，它不提供直接的实现，JavaSDK提供的类都是继承自Collection的“子接口”如List和Set。Collection所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持</li>
<li>在Java中所有实现了Collection接口的类都应该提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素</li>
<li>Collection接口为集合提供一些统一的访问接口（泛型接口），覆盖了向集合中添加元素、删除元素、以及协助对集合进行遍历访问的相关方法：</li>
</ul>
<p><img src="/2020/03/22/java2/image175.png" alt><br><img src="/2020/03/22/java2/image176.png" alt></p>
<p>集合的通用遍历方法有以下几种： </p>
<ol>
<li>使用增强型for(<strong>forEach循环</strong>)遍历 </li>
<li>使用<strong>迭代器</strong>遍历 </li>
<li>（多说两句：JDK8以后 lambda表达式，stream基于foreach）<br>使用增强型for循环进行Collection遍历额一般形式是： </li>
</ol>
<p><strong>for(元素类型 循环变量名:Collection对象)｛<br>对循环变量进行处理；<br>}</strong></p>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><ul>
<li>Map是由一系列键值对组成的集合，提供了key到Value的映射。同时它也<strong>没有继承Collection</strong>。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它<strong>不能存在相同的key值</strong>，当然value值可以相同 </li>
<li>Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序定义为迭代器在映射的 collection 视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类<br><img src="/2020/03/22/java2/image177.png" alt><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2>List接口为Collection子接口。List所代表的是<strong>有序的Collection</strong><br>它<strong>用某种特定的插入顺序来维护元素顺序</strong>。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据<strong>元素的整数索引</strong>（在列表中的位置，和数组相似，从0开始，到元素个数-1）访问元素，并检索列表中的元素，由于这些特性，List在Collection的基础上扩展了一些重要方法：</li>
</ul>
<p><img src="/2020/03/22/java2/image178.png" alt></p>
<p>由于列表有序并存在索引，因此除了增强for循环进行遍历外，还可以使用普通的for循环进行遍历： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;list.size();i++)｛ </span><br><span class="line">	元素类型 e = list.get(i);</span><br><span class="line">	//对e进行处理 </span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set是一种<strong>不包括重复元素的Collection</strong>。它维持自己的内部排序，所以随机访问没有任何意义。与List一样，<strong>它同样允许null的存在但是仅有一个</strong><br>由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种先进先出的数据结构，元素在队列末尾添加，在队列头部删除。Queue接口扩展自Collection，并提供插入、提取、检验等操作</p>
<p>方法offer表示向队列添加一个元素，poll()与remove()方法都是移除队列头部的元素，两者的区别在于如果队列为空，那么poll()返回的是null，而remove()会抛出一个异常。方法element()与peek()主要是获取头部元素，不删除 </p>
<p>接口Deque，是一个扩展自Queue的双端队列，它支持在两端插入和删除元素，因为LinkedList类实现了Deque接口，所以通常我们可以使用LinkedList来创建一个队列。PriorityQueue类实现了一个优先队列，优先队列中元素被赋予优先级，拥有高优先级的先被删除</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList是一个用数组实现的列表，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null</p>
<p>每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作（构建一个新的更大的数组并将之前的内容拷贝到新书组中）。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率 </p>
<p>ArrayList的默认扩容扩展后数组大小为：(原数组长度*3)/2+1</p>
<p>ArrayList是一个非线程安全的列表</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>同样实现List接口的LinkedList与ArrayList不同，LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部</p>
<p>由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作 </p>
<p>与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步 </p>
<p><img src="/2020/03/22/java2/image179.png" alt></p>
<h2 id="其他List实现类"><a href="#其他List实现类" class="headerlink" title="其他List实现类"></a>其他List实现类</h2><p>在JDK1.2之前是没有完整的集合框架的。只有一些简单的可以自扩展的容器类，比如Vector，Stack，Hashtable等。这些容器类在使用的过程中由于效率问题饱受诟病，因此在Java 2中，Java设计者们进行了大刀阔斧的整改，重新设计，于是就有了现在的集合框架。需要注意的是，之前的那些容器类库并没有被弃用而是进行了保留，主要是为了向下兼容的目的，但我们在平时使用中还是应该尽量少用</p>
<p>Vector与ArrayList相似，但是Vector是同步的。所以说<strong>Vector是使用数组实现的线程安全的列表</strong>。它的操作与ArrayList几乎一样 </p>
<p>Vector在进行默认规则扩容时，<strong>新数组的长度=原始数组长度*2</strong> </p>
<p>Stack继承自Vector，实现一个<strong>后进先出的堆栈</strong> </p>
<p>Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置 </p>
<p>Stack刚创建后是空栈</p>
<h2 id="set实现类"><a href="#set实现类" class="headerlink" title="set实现类"></a>set实现类</h2><ul>
<li>EnumSet：<br>是枚举的专用Set。所有的元素都是枚举类型 </li>
<li>HashSet<br>HashSet堪称查询速度最快的集合，因为其<strong>内部是以HashCode来实现的</strong>。它内部元素的顺序是由哈希码来决定的，所以它不保证set的迭代顺序；特别是它不保证该顺序恒久不变 </li>
<li>TreeSet<br>基于TreeMap，生成一个<strong>总是处于排序状态的set</strong>，内部以TreeMap来实现。它是<strong>使用元素的自然顺序对元素进行排序，或者根据创建Set 时提供的 Comparator 进行排序</strong>，具体取决于使用的构造方法</li>
</ul>
<p><img src="/2020/03/22/java2/image180.png" alt></p>
<p><img src="/2020/03/22/java2/image181.png" alt></p>
<p>集合元素的hashCode方法返回的哈希值对HashSet而言非常重要，因为HashSet会优先使用这个哈希值来判定两个元素是否相同并确定元素的位置</p>
<p>如果我们在自定义元素类型时hashCode方法定义不够先进，就会出现逻辑和语义上的问题，甚至会造成内存泄露 </p>
<p>有可能造成内存泄露的原因是HashSet的remove方法也依赖于哈希值进行待删除节点定位，如果由于集合元素内容被修改而导致hashCode方法的返回值发生变更，那么，remove方法就无法定位到原来的对象，导致删除不成功，从而导致内存泄露</p>
<p><img src="/2020/03/22/java2/image182.png" alt></p>
<p><img src="/2020/03/22/java2/image183.png" alt><br>TreeSet扩展自AbstractSet，并实现了NavigableSet，AbstractSet扩展自AbstractCollection， TreeSet是一个有序的Set，其底层是一颗树，这样就能从Set里面提取一个有序序列了。为了实现排序的功能，TreeSet中存放的对象需要实现Comparable。在实例化TreeSet时，我们也可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序。树形集中提供了很多便捷的方法</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap是基于哈希表的Map接口的非同步实现，继承自AbstractMap，AbstractMap是部分实现Map接口的抽象类 </p>
<p>在之前的版本中，HashMap采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里（和我们在之前自行实现的哈希表相同）。但是当链表中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用数组+链表+红黑树（一种平衡搜索二叉树）实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间 </p>
<p><img src="/2020/03/22/java2/image184.png" alt></p>
<h2 id="map其他实现类"><a href="#map其他实现类" class="headerlink" title="map其他实现类"></a>map其他实现类</h2><p>和Vector类似，Map体系也有一个自JDK1.2之前遗留的集合工具：Hashtable，它的操作接口和HashMap相同，和HashMap的区别在于：<strong>Hashtable是线程安全的，而HashMap是非线程安全的</strong></p>
<p>LinkedHashMap继承自HashMap，它主要是用链表实现来扩展HashMap类，HashMap中条目是没有顺序的，但是在LinkedHashMap中元素既可以按照它们插入的顺序排序，也可以按它们最后一次被访问的顺序排序</p>
<p>TreeMap基于红黑树数据结构的实现，键值可以使用Comparable或Comparator接口来排序。TreeMap继承自AbstractMap，同时实现了接口NavigableMap，而接口NavigableMap则继承自SortedMap。SortedMap是Map的子接口，使用它可以确保图中的条目是排好序的</p>
<p>在实际使用中，如果更新Map时不需要保持图中元素的顺序，就使用HashMap，如果需要保持Map中元素的插入顺序或者访问顺序，就使用LinkedHashMap，如果需要使图按照键值排序，就使用TreeMap </p>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Properites类是Hashtable类的子类，所以也间接地实现了Map接口。</p>
<p>在实际应用中，常使用Properties类对属性文件进行处理（在国际化支持中我们也会使用另外一个工具来通过国际化方式读取属性文件： ResourceBundle ）</p>
<p>Properties类的常用方法： </p>
<ul>
<li>load()：加载文件； </li>
<li>getProperty(key)：通过key值获得对应的value值 </li>
<li>setProperty(String key,String value)给properties文件中写值</li>
</ul>
<p><img src="/2020/03/22/java2/image185.png" alt><br><img src="/2020/03/22/java2/image186.png" alt><br><img src="/2020/03/22/java2/image187.png" alt></p>
<p>总结<br>•Vector、ArrayList、LinkedList有什么区别？<br>•HashSet在什么情况下可能导致内存泄露？<br>•Map有什么特点？<br>•ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快<br>•有可能造成内存泄露的原因是HashSet的remove方法也依赖于哈希值进行待删除节点定位，如果由于集合元素内容被修改而导致hashCode方法的返回值发生变更，那么，remove方法就无法定位到原来的对象，导致删除不成功，从而导致内存泄露<br>•Map是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同 </p>
<h2 id="Comparable内部比较"><a href="#Comparable内部比较" class="headerlink" title="Comparable内部比较"></a>Comparable内部比较</h2><p>一个类如果想【支持排序】，那么就必须实现接口Comparable<T>，该接口被称为对象的内部比较器；</T></p>
<p>该接口中只有一个方法； </p>
<p><img src="/2020/03/22/java2/image188.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Product implements Comparable&lt;Product&gt;&#123;</span><br><span class="line">……</span><br><span class="line">@Override</span><br><span class="line">public int compareTo(Product o) &#123;</span><br><span class="line">//根据商品价格升序排序</span><br><span class="line">if(this.price&gt;o.price)&#123;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;else if(this.price&lt;o.price)&#123;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/22/java2/image189.png" alt><br><img src="/2020/03/22/java2/image190.png" alt></p>
<h2 id="外部比较器"><a href="#外部比较器" class="headerlink" title="外部比较器"></a>外部比较器</h2><p>一个类实现Comparable这个内部比较器后，该类支持排序，然而只能有一种排序逻辑，比较受限制；<br>可以使用外部比较器Comparator，灵活为类定义多种比较器，此时类本身不需要实现Comparable接口；<br>Comparator接口中有两个方法：<br><img src="/2020/03/22/java2/image191.png" alt></p>
<p><img src="/2020/03/22/java2/image192.png" alt><br><img src="/2020/03/22/java2/image193.png" alt><br>修改成枚举属性  增强数据安全性</p>
<p><img src="/2020/03/22/java2/image194.png" alt><br><img src="/2020/03/22/java2/image195.png" alt><br><img src="/2020/03/22/java2/image196.png" alt></p>
<h2 id="Arrays工具类型"><a href="#Arrays工具类型" class="headerlink" title="Arrays工具类型"></a>Arrays工具类型</h2><p>java.util.Arrays类是一个针对数组进行操作的工具类，其中提供了对对象数组进行排序的方法；<br>两个常用的对象数组排序方法如下： </p>
<p><img src="/2020/03/22/java2/image197.png" alt></p>
<h2 id="内部比较器的问题"><a href="#内部比较器的问题" class="headerlink" title="内部比较器的问题"></a>内部比较器的问题</h2><p>为什么Student类如果不实现Comparable接口，就会抛出ClassCastException异常？<br>Arrays.sort  要求  后面数据中的元素 要去实现这个接口，之后将当前类比较的方法compareTo获取，清楚比较规则，再去进行排序</p>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>和Arrays.sort()方法一样，Collections类也提供了sort()方法对集合内部中的元素按照元素的自然排序方式进行排序： </p>
<p><img src="/2020/03/22/java2/image198.png" alt><br><img src="/2020/03/22/java2/image199.png" alt></p>
<h2 id="新工具生成线程安全集合"><a href="#新工具生成线程安全集合" class="headerlink" title="新工具生成线程安全集合"></a>新工具生成线程安全集合</h2><p>集合框架中的新工具大多是非同步的，如果在并发环境中直接访问可能会导致各种问题，而Vector、Hashtable等老旧工具还继续保留的主要原因是维持向下兼容，因此我们希望能够获取新的集合工具的线程安全版本，而Collections工具类则为我们提供了这方面的支持</p>
<p><img src="/2020/03/22/java2/image200.png" alt><br>小结</p>
<ul>
<li>Collection和Collections有什么区别，Array和Arrays有什么区别？ </li>
<li>java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作</li>
<li>Array类提供了动态创建和访问 Java 数组的方法</li>
<li>Arrays包含用来操作数组（比如排序和搜索）的各种方法。此类还包含一个允许将数组作为列表来查看的静态工厂 </li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p><img src="/2020/03/22/java2/image201.png" alt><br>以上代码会出现异常<br><strong>java.util.ConcurrentModificationException</strong></p>
<p><img src="/2020/03/22/java2/image202.png" alt><br>如果是为了删除元素，可以利用break终止循环</p>
<p><img src="/2020/03/22/java2/image203.png" alt></p>
<h3 id="利用迭代器"><a href="#利用迭代器" class="headerlink" title="利用迭代器"></a>利用迭代器</h3><p>获取迭代器，在Collection接口中定义了一个iterator();  方法用于返回迭代器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Student&gt; it = stuList.iterator();  </span><br><span class="line">//迭代器方法介绍</span><br><span class="line">hasNext();判断是否还有下一个元素</span><br><span class="line">next();获取当前元素切换到下一个元素</span><br><span class="line">remove();移除元素</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/22/java2/image204.png" alt><br><img src="/2020/03/22/java2/image205.png" alt></p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>掌握Java中的垃圾回收机制和垃圾回收时机<br>掌握Java中的不同引用类型<br>了解Java的引用队列<br>了解Java中可能存在的内存泄露情况<br>了解finalize方法的作用与隐患<br>在JVM架构中，堆内存和垃圾回收器这两个部分和垃圾回收相关。堆内存是运行时用来存储实例对象的数据空间，垃圾回收器运行在堆内存上</p>
<p><img src="/2020/03/22/java2/image206.png" alt></p>
<h2 id="垃圾回收机制的概念"><a href="#垃圾回收机制的概念" class="headerlink" title="垃圾回收机制的概念"></a>垃圾回收机制的概念</h2><p>小李子用他神出鬼没波澜起伏的颜值变化告诉我们：多少没有演技的小鲜肉被无情的拍死在了沙滩上，因此：存活年代越久的老戏骨，生存欲望及能力越强<br>Java对象对小李子表示认同<br>在Java的内存模型中，最重要的是要了解堆内存的概念。运行时的Java实例对象(new Student())存储在堆内存空间中。当一个对象不再被引用了，它变成可被从堆内存中回收空间。在垃圾回收的过程中，这些对象将被从堆内存中清除，同时它们的空间也就被回收了。<br>就像小李子的演艺经历给我们揭示的道理一样，堆内存的空间根据对象的存活时限主要分成了三部分：年轻代、老年代、永久代</p>
<p><img src="/2020/03/22/java2/image207.png" alt><br>java堆内存中的对象分代存储（依据对象本身的存活时限）：<br><img src="/2020/03/22/java2/image208.png" alt><br>年轻代<br>a-Eden区(所有实例在运行时最初都分配到eden区中)<br>b-S0 Survivor Space(老一些的对象被从eden区移动到S0区，其实是eden区中的对象经过一次对eden区的Young GC还存活的对象被移动到S0)<br>c,-S1 Survivor Space(再老一些的对象被从S0区移动到S1区，其实是在Young GC过程中S0区已满，则会将eden区中还存活的对象和S0区中的存活对象移动到S1区中)<br>老年代<br>经过S0，S1中几轮迭代后还存活的对象被提升到老年代<br>永久代<br>包含一些元数据像类、方法等等<br>永久代空间在JDK8特性中已经被移除</p>
<p>Java垃圾回收是一个自动运行的管理程序运行时使用的内存的进程。通过GC的自动执行JVM将程序员从申请和释放内存的繁重操作中解放出来<br>主动调用<br>作为一个自动执行的进程，程序员不需要在代码中主动初始化GC。Java提供了System.gc()和Runtime.gc()这两个hook来请求JVM调用GC进程<br>尽管要求系统机制给程序员提供调用GC的机会，但是实际上这是由JVM负责决定的。<strong>JVM可以选择拒绝启动GC的请求</strong>，因此并不保证这些请求会真的调用垃圾回收。这是JVM基于内存堆空间的Eden区（年轻代）的使用情况做出的决定。<br>JVM规范将这个选择权利留给了各个JVM的具体实现，因此实际上JVM是如何选择的视不同JVM的实现而定(但应该始终记住的是，不能依赖于这两个方法的调用，<strong>它们是不被保证执行的</strong>)</p>
<p><img src="/2020/03/22/java2/image209.png" alt><br>Eden Space:当一个实例被创建的时候，它最初被存放在堆内存空间的年轻代的Eden区中<br>Survivor Space(S0 和S1):作为minor回收周期的一部分，还活着的对象(还有引用指向它)被从eden区中移动到survivor空间S0。同样的，垃圾回收器扫描S0并将活着的实例移动到S1<br>无用的对象被标记并回收。垃圾回收器决定这些被标记的实例是在扫描的过程中移出内存还是在另外独立的迁移进程中执行<br>Old Generation:老年代或者永久代是堆内存的第二个逻辑部分。当垃圾回收器在做minor GC周期中，S1 survivor区中还活着的实例会被提升到老年代中。S1区中不再被引用的对象被标记并清除<br>Major GC:在Java垃圾回收过程中实例生命周期的最后一个阶段。Major GC在垃圾回收过程中扫描属于Old Generation部分的堆内存。如果实例没有被任何引用关联，它们将被标记、清除;如果它们还被引用关联着，则将继续存留在old generation。<br>从上述过程可以看出：生存时限越长的对象，其被垃圾回收处理机制扫描的频率就越低<br>Fragmentation:<br>一旦实例从堆内存中删除了，它们原来的位置将空出来给以后分配实例使用。<strong>显然这些空闲空间很容易在内存空间中产生碎片。为了能够更快地分配实例地址，需要对内存做去碎片化操作。</strong>根据不同垃圾回收器的策略，被回收的内存将在回收的过程同时或者在GC另外独立的过程中压缩整合</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>Java中存在四种类型的垃圾回收器：</p>
<ul>
<li>Serial Garbage Collector</li>
<li>Parallel Garbage Collector</li>
<li>CMS Garbage Collector</li>
<li>G1 Garbage Collector</li>
</ul>
<p><img src="/2020/03/22/java2/image210.png" alt><br>不管那种回收器都会阻断应用线程面导致应用阻断，因此切忌慎用GC！</p>
<p>这四种类型的垃圾回收器都有各自的优点和缺点。最重要的是我们可以选择JVM使用哪种类型的垃圾回收器。我们可以通过传递不同的JVM参数来设置使用哪一个。各个垃圾回收器在不同应用场景下的效率会有很大的差异。因此了解各种不同类型的垃圾回收器以及它们的应用场景是非常重要的<br>在什么时候使用哪一个取决于应用场景，硬件配置和吞吐量要求</p>
<p><strong>Serial Garbage Collector：</strong><br>串行垃圾回收器控制所有的应用线程。它是为单线程场景设计的，只使用一个线程来执行垃圾回收工作。它暂停所有应用线程来执行垃圾回收工作的方式不适用于服务器的应用环境。它最适用的是简单的命令行程序<br>使用-XX:+UseSerialGC JVM参数来开启使用串行垃圾回收器</p>
<p><strong>Parallel Garbage Collector：</strong><br>并行垃圾回收器也称作基于吞吐量的回收器。它是JVM的默认垃圾回收器。与Serial不同的是，它使用多个线程来执行垃圾回收工作。和Serial回收器一样，它在执行垃圾回收工作是也需要暂停所有应用线程</p>
<p><strong>CMS Garbage Collector</strong>：<br>并发标记清除(Concurrent Mark Sweep,CMS)垃圾回收器，使用多个线程来扫描堆内存并标记可被清除的对象，然后清除标记的对象。CMS垃圾回收器只在下面这两种情形下暂停工作线程：<br>在老年代中标记引用对象的时候<br>在做垃圾回收的过程中堆内存中有变化发生<br>对比与并行垃圾回收器，CMS回收器使用更多的CPU来保证更高的吞吐量。如果我们可以有更多的CPU用来提升性能，那么CMS垃圾回收器是比并行回收器更好的选择<br>使用-XX:+UseParNewGC JVM参数来开启使用CMS垃圾回收器。</p>
<p><strong>G1 Garbage Collector：</strong><br>G1垃圾回收器应用于大的堆内存空间。它将堆内存空间划分为不同的区域，对各个区域并行地做回收工作。G1在回收内存空间后还立即对堆空闲空间做整合工作以减少碎片。CMS却是在全部停止(stop the world,STW)时执行内存整合工作。对于不同的区域G1根据垃圾的数量决定优先级<br>使用-XX:UseG1GC JVM参数来开启使用G1垃圾回收器<br>在使用G1垃圾回收器时，开启使用-XX:+UseStringDeduplacaton JVM参数。它会通过把重复的String值移动到同一个char[]数组来优化堆内存占用。这是Java 8 u 20引入的选项</p>
<p><img src="/2020/03/22/java2/image211.png" alt><br><img src="/2020/03/22/java2/image212.png" alt><br>java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseSerialGC -jar java-application.jar</p>
<h2 id="垃圾回收的判断"><a href="#垃圾回收的判断" class="headerlink" title="垃圾回收的判断"></a>垃圾回收的判断</h2><p>我们知道，GC主要处理的是对象的回收操作，那么什么时候会触发一个对象的回收的呢：<br><strong>对象没有引用</strong><br><strong>作用域发生未捕获异常</strong><br><strong>程序在作用域正常执行完毕</strong><br><strong>程序执行了System.exit()</strong><br><strong>程序发生意外终止（被杀进程等）</strong><br>在JDK1.2之前，使用的是引用计数器算法，即当类被加载到内存以后，就会产生方法区，堆栈、程序计数器等一系列信息，当创建对象的时候，为这个对象在堆栈空间中分配对象，同时会产生一个引用计数器，同时引用计数器+1，当有新的引用的时候，引用计数器继续+1，而当其中一个引用销毁的时候，引用计数器-1，当引用计数器被减为零的时候，标志着这个对象已经没有引用了，可以回收了</p>
<p>引用计数算法在JDK1.2之前的版本被广泛使用，但是随着业务的发展，很快出现了一个问题：<br>当我们的代码出现下面的情形时，该算法将无法适应<br> objA.obj = objB<br> objB.obj = objA</p>
<p><img src="/2020/03/22/java2/image213.png" alt><br>这样的代码会产生如下引用情形 objA指向objB，而objB又指向objA，这样当其他所有的引用都消失了之后，objA和objB还有一个相互的引用，也就是说两个对象的引用计数器各为1，而实际上这两个对象都已经没有额外的引用，已经是垃圾了<br>根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张有向图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点<br>目前java中可作为GC Root的对象有<br>虚拟机栈中引用的对象（本地变量表）<br>方法区中静态属性引用的对象<br>方法区中常量引用的对象<br>本地方法栈中引用的对象（Native对象）</p>
<h2 id="Java内存泄漏"><a href="#Java内存泄漏" class="headerlink" title="Java内存泄漏"></a>Java内存泄漏</h2><p><img src="/2020/03/22/java2/image214.png" alt><br>Java语言的一个关键的优势就是它的内存管理机制。你只管创建对象，Java的垃圾回收器帮你分配以及回收内存。然而，实际的情况并没有那么简单，因为内存泄漏在Java应用程序中还是时有发生的<br>事实上，在讲解Java中垃圾判定时，我们就看到了在JDK1.2之前，Java中的内存泄露甚至是一个比较常见的现象<br><strong>内存泄漏的定义：对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用着</strong></p>
<p><img src="/2020/03/22/java2/image215.png" alt><br>从刚才的图里面可以看出，里面有被引用对象和未被引用对象。未被引用对象会被垃圾回收器回收，而被引用的对象却不会。<br>未被引用的对象当然是不再被使用的对象，因为没有对象再引用它。然而无用对象却不全是未被引用对象。其中还有被引用的。就是这种情况导致了内存泄漏</p>
<p><img src="/2020/03/22/java2/image216.png" alt></p>
<h2 id="内存泄漏说明"><a href="#内存泄漏说明" class="headerlink" title="内存泄漏说明"></a>内存泄漏说明</h2><p><img src="/2020/03/22/java2/image217.png" alt><br>上例中，A对象引用B对象，A对象的生命周期（t1-t4）比B对象的生命周期（t2-t3）长的多。当B对象没有被应用程序使用之后，A对象仍然在引用着B对象。这样，垃圾回收器就没办法将B对象从内存中移除，从而导致内存问题，因为如果A引用更多这样的对象，那将有更多的未被引用对象存在，并消耗内存空间<br>B对象也可能会持有许多其他的对象，那这些对象同样也不会被垃圾回收器回收。所有这些没在使用的对象将持续的消耗之前分配的内存空间</p>
<p>下面是几条容易上手的建议，来帮助开发人员防止内存泄漏的发生：<br>不再使用的对象将指向其的引用置空指向null<br>特别注意一些像HashMap、ArrayList的集合对象，它们经常会引发内存泄漏。当它们被声明为static时，它们的生命周期就会和应用程序一样长<br>同样是集合，当原有对象的属性发生改变(hashCode变化)，remove()方法可能会失效，导致内存泄露（后续详细讲解）<br>特别注意系统中各种事件监听和回调。当一个监听器在使用的时候被注册，但不再使用之后却未被反注册<br>“如果一个类自己管理内存，那开发人员就得小心内存泄漏问题了。” 通常一些成员变量引用其他对象，初始化的时候需要置空<br>事实上，对于一些常用API的使用如果不了解其实现方式的话也很容易引起内存泄露</p>
<p>例如，String类常用的截取字串的方法substring()在JDK1.6中如果滥用就会导致比较严重的内存泄露</p>
<p><img src="/2020/03/22/java2/image218.png" alt><br><img src="/2020/03/22/java2/image219.png" alt><br>如果研究过Java的源代码，就会发现，Java中的字符串由char[]作为数据结构支持，String类中包含了3个成员：char[] value，int offset，int count,它们分别用于存放实际的字符序列，本字符串对象的第一个字符在字符数组中的位置以及字符串对象包含多少个字符<br>在JDK6中，substring()方法创建了一个新的String对象，但是新的String对象中的value成员指向了和源字符串相同的字符数组，只不过offset和count的取值发生了改变<br>这种情况下，如果你有一个非常长的字符串，但是只使用了substring()方法截取了很短的一部分字串来使用，根据JDK6的实现方式，虽然只是用了很短的字串，但是仍然保留了整个长字符串的所有字符，会引发大量的内存浪费并影响性能<br>因此，在JDK6中，如果需要使用substring()方法，建议使用如下的方式，它将明确构建一个新的字符串（包括用于支持内容的字符数组）：<br>x = x.substring(m, n) + “”；//生成一个新的字符串</p>
<p>在JDK7中，substring()方法已经做出了改进，会在对内存中为新的字符串对象创建一个新的字符数组：</p>
<p><img src="/2020/03/22/java2/image220.png" alt><br>1、hashSet内存泄漏        修改对象再删除 hashcode发生了变化无法删除<br>2、对象之间相互引用内存泄漏        1.2jdk对象之间相互引用  改进之后也ok了<br>3、Jdk1.6字符串substring内存泄漏  jdk1.7以后创建新字符串</p>
<h2 id="Finalize"><a href="#Finalize" class="headerlink" title="Finalize"></a>Finalize</h2><p>Java和C++不同，没有提供析构方法<br><strong>Object中包含了一个叫做finalize()的方法，提供在对象被回收时调用以释放资源，默认情况下其不执行任何动作</strong><br>由于Object是Java继承体系的根，因此事实上所有的<strong>Java类都具备finalize方法</strong><br>当垃圾回收器确定了一个对象没有任何引用时，其会调用finalize()方法。但是，<strong>finalize方法并不保证调用时机，因此也不建议重写finalize()方法</strong><br><strong>如果必须要重写finalize()方法，请记住使用super.finalize()调用父类的清除方法，否则对象清理的过程可能不完整</strong><br>每个对象只能被GC自动调用finalize( )方法一次。如果在finalize( )方法执行时产生异常（exception），则该对象仍可以被垃圾收集器收集<br>Java语言允许程序员为任何方法添加finalize( )方法，该方法会在垃圾收集器交换回收对象之前被调用。但不要过分依赖该方法对系统资源进行回收和再利用，因为该方法调用后的执行结果是不可预知的<br>当finalize( )方法尚未被调用时，<strong>System.runFinalization()方法可以用来调用finalize( )方法</strong>，并实现相同的效果，对无用对象进行垃圾收集<br>面试题 final  finalize finally的区别？</p>
<p><img src="/2020/03/22/java2/image221.png" alt><br><img src="/2020/03/22/java2/image222.png" alt></p>
<h2 id="强引用、软引用、弱引用及虚引用"><a href="#强引用、软引用、弱引用及虚引用" class="headerlink" title="强引用、软引用、弱引用及虚引用"></a>强引用、软引用、弱引用及虚引用</h2><p>在JDK1.2以前的版本中，<strong>当一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及状态，程序才能使用它</strong><br>这就像在日常生活中，从商店购买了某样物品后，如果有用，就一直保留它，否则就把它扔到垃圾箱，由清洁工人收走。一般说来，如果物品已经被扔到垃圾箱，想再 把它捡回来使用就不可能了<br>但有时候情况并不这么简单，你可能会遇到类似鸡肋一样的物品，食之无味，弃之可惜。这种物品现在已经无用了，保留它会占空间，但是立刻扔掉它也不划算，因为也许将来还会派用场。对于这样的可有可无的物品，一种折衷的处理办法是：如果家里空间足够，就先把它保留在家里，如果家里空间不够，即使把家里所有的垃圾清除，还是无法容纳那些必不可少的生活用品，那么再扔掉这些可有可无的物品</p>
<p>从JDK1.2版本开始，为了解决上述问题，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：<br>强引用<br>软引用<br>弱引用<br>虚引用</p>
<p><img src="/2020/03/22/java2/image223.png" alt><br><img src="/2020/03/22/java2/image224.png" alt><br><img src="/2020/03/22/java2/image225.png" alt></p>
<h2 id="强引用："><a href="#强引用：" class="headerlink" title="强引用："></a>强引用：</h2><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用:</p>
<pre><code>ClassName object = new ClassName();</code></pre><p>如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题</p>
<p><img src="/2020/03/22/java2/image226.png" alt></p>
<h2 id="软引用："><a href="#软引用：" class="headerlink" title="软引用："></a>软引用：</h2><p>如果一个对象只具有软引用，那就类似于可有可物的生活用品。<strong>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。<strong>软引用可用来实现内存敏感的高速缓存</strong></p>
<pre><code>String str=new String(&quot;abc&quot;);
SoftReference&lt;String&gt; softRef=new SoftReference&lt;String&gt;(str);</code></pre><h2 id="弱引用："><a href="#弱引用：" class="headerlink" title="弱引用："></a>弱引用：</h2><p>如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，<strong>一旦发现了只具有弱引用的对象</strong>，不管当前内存空间足够与否，都会回收它的内存。不过，由于<strong>垃圾回收器是一个优先级很低的线程</strong>， 因此不一定会很快发现那些只具有弱引用的对象</p>
<pre><code>String str=new String(&quot;abc&quot;);
 WeakReference&lt;String&gt; weakRef=new WeakReference&lt;String&gt;(str);</code></pre><h2 id="虚引用："><a href="#虚引用：" class="headerlink" title="虚引用："></a>虚引用：</h2><p>顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，<strong>在任何时候都可能被垃圾回收虚引用主要用来跟踪对象被垃圾回收的活动</strong>。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<strong>程序可以通过判断引用队列中是 否已经加入了虚引用</strong>，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动<br>虚引用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = new String(&quot;abc&quot;);</span><br><span class="line">ReferenceQueue&lt;String&gt; queue = new ReferenceQueue&lt;String&gt;();</span><br><span class="line">PhantomReference&lt;String&gt; phantomRef = new PhantomReference&lt;String&gt;(str, queue);</span><br></pre></td></tr></table></figure>
<p>由于虚引用的特点，绑定应用队列后是finalize()方法的理想替代品，一<strong>旦虚引用被加入引用队列，就没有任何办法获取虚引用指向的对象</strong>，因此不存在对象复活的隐患</p>
<h2 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h2><p>正如之前说的，软引用、弱引用、虚引用均可以和一个引用队列绑定使用<br>ReferenceQueue是作为 JVM GC与上层Reference对象管理之间的一个消息传递方式，它使得我们可以对所监听的对象引用可达发生变化时做一些处理<br>我们希望当一个对象被gc掉的时候通知用户线程，进行额外的处理时，就需要使用引用队列了。ReferenceQueue即这样的一个对象，当一个obj被gc掉之后，其相应的引用对象（软引用、弱引用、虚引用），即ref对象会被放入queue中。我们可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理<br>实现了一个队列的入队(enqueue)和出队(poll还有remove)操作，内部元素就是泛型的Reference，并且Queue的实现，是由Reference自身的链表结构所实现的<br><strong>引用队列的入队操作是由垃圾回收器完成的，当其发现回收的对象具备软引用、弱引用或虚引用时，会自动将对象的引用对象入队</strong><br>我们只需要在必要时执行出队操作即可监控到有哪些对象被回收并执行相关的资源操作</p>
<p><img src="/2020/03/22/java2/image227.png" alt></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>掌握Java中为字符串提供的常量池，以及由常量池带来的字符串操作特性<br>掌握字符串的subString\equals\toCharArray\startsWith\endsWith\compareTo\equalsIgnoreCase\getBytes等常用方法的使用及参数特征，熟练掌握字符串的不同构造方法的功能</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Java语言使用Unicode字符集，默认使用UTF-8格式；因此Java的字符串也使用UTF-8编码；<br>UTF-8是一种针对Unicode的可变长度字符编码，用1到4个字节编码Unicode字符；<br>Java语言中的字符串实际上是使用字符型数组char[]存储;<br>String str = “abc”;<br>等同于：<br> char data[] = {‘a’, ‘b’, ‘c’};<br> String str = new String(data);</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>字符串可以用两种方式赋值，且有一个非常重要的特征，即不可变性（immutable）;<br><strong>不可变的意思是：一旦一个字符串被创建后，它的值就不能被修改；</strong><br>String s1=”Hello”;<br>s1=”World”;</p>
<p><img src="/2020/03/22/java2/image228.png" alt><br>并不是把Hello改为了World，而是重新分配空间存储World;<br>s1的值发生了改变，指向了新的空间；</p>
<p><img src="/2020/03/22/java2/image229.png" alt><br><img src="/2020/03/22/java2/image230.png" alt><br><img src="/2020/03/22/java2/image231.png" alt><br><img src="/2020/03/22/java2/image232.png" alt><br>为了能够重用这些不变的字符串，Java使用了字符串常量池；<br><strong>凡是用=直接赋值的方式得到的字符串，都存储在常量池中；相同的共用一个具体字符串；使用new创建的字符串不适用常量池，每次都分配新的内存空间；</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s2=&quot;Hello&quot;;</span><br><span class="line">String s3=&quot;Hello&quot;;</span><br><span class="line">String s4=new String(&quot;Hello&quot;);</span><br><span class="line">String s5=new String(&quot;Hello&quot;);</span><br></pre></td></tr></table></figure>
<p>s2与s3使用=赋值，所以使用到常量池，指向同一个Hello；<br>s4与s5使用new创建，没有用常量池，每次都分配新的空间，指向一个新的Hello;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s2=&quot;Hello&quot;;</span><br><span class="line">String s3=&quot;Hello&quot;;</span><br><span class="line">String s4=new String(&quot;Hello&quot;);</span><br><span class="line">String s5=new String(&quot;Hello&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;s2==s3&quot;+(s2==s3));</span><br><span class="line">System.out.println(&quot;s4==s5&quot;+(s4==s5));</span><br><span class="line">System.out.println(&quot;s2==s4&quot;+(s2==s4));</span><br><span class="line">结果显示如下：</span><br><span class="line">s2==s3 true</span><br><span class="line">s4==s5 false</span><br><span class="line">s2==s4 false</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/22/java2/image233.png" alt><br><img src="/2020/03/22/java2/image234.png" alt></p>
<h2 id="字符串方法介绍"><a href="#字符串方法介绍" class="headerlink" title="字符串方法介绍"></a>字符串方法介绍</h2><p>String类中定义了一系列字符串相关方法，可以根据API文档进行学习，练习；<br>子串截取相关方法：</p>
<p><img src="/2020/03/22/java2/image235.png" alt><br>String类中定义了一系列字符串相关方法，可以根据API文档进行学习，练习；<br>检索相关方法：</p>
<p><img src="/2020/03/22/java2/image236.png" alt><br><img src="/2020/03/22/java2/image237.png" alt><br>String类中定义了一系列字符串相关方法，可以根据API文档进行学习，练习；<br>检索相关方法代码演示：<br>public static void main(String[] args) {<br>String s=”beijingETC”;<br>//返回字符串s中第一次出现i的位置索引，为2<br>System.out.println(s.indexOf(‘i’));<br>//返回字符串s中最后一次出现i的位置索引，为4<br>System.out.println(s.lastIndexOf(‘i’));<br>//返回字符串s中第3个字符以后，第一次出现字符i的位置索引，为4<br>System.out.println(s.indexOf(‘i’,3));<br>//返回字符串中第一次出现jing的索引位置，为3<br>System.out.println(s.indexOf(“jing”));<br>//返回字符串中，第4个字符后，第一次出现jing的位置索引，由于没有，所以返回-1<br>System.out.println(s.indexOf(“jing”,4));<br>//返回字符串中的第二个字符，为i，注意索引从0开始<br>System.out.println(s.charAt(2));<br>}</p>
<h2 id="转化成字符串的方法"><a href="#转化成字符串的方法" class="headerlink" title="转化成字符串的方法"></a>转化成字符串的方法</h2><p>String类中定义了一系列字符串相关方法，可以根据API文档进行学习，练习；<br>类型转换相关方法：</p>
<p><img src="/2020/03/22/java2/image238.png" alt><br>String类中定义了一系列字符串相关方法，可以根据API文档进行学习，练习；<br>类型转换代码演示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int i=10;</span><br><span class="line">//将i转换为String类型</span><br><span class="line">String si=String.valueOf(i);</span><br><span class="line"></span><br><span class="line">char[] c1=&#123;&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;&#125;;</span><br><span class="line">//将char数组转换为String类型</span><br><span class="line">String sc1=String.valueOf(c1);</span><br><span class="line"></span><br><span class="line">// 将char数组中的第1到第4个字符转换为String类型</span><br><span class="line">String sc2=String.valueOf(c1,1,4);</span><br><span class="line"></span><br><span class="line">//分别输出hello及ello</span><br><span class="line">System.out.println(sc1);</span><br><span class="line">System.out.println(sc2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/22/java2/image239.png" alt><br>其他方法<br>String类中定义了一系列字符串相关方法，可以根据API文档进行学习、练习；<br>其他方法：<br><img src="/2020/03/22/java2/image240.png" alt></p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>1、掌握Java中正则表达式的基本格式、转义字符、数量词、匹配规则等<br>2、能够利用正则表达式进行字符串格式验证或子串检索<br>在编写程序的时候，往往对某些字符串的规则有特定的逻辑要求；<br>例如，邮件地址，手机号码，身份证号码，都可能使用字符串表示，而这些字符串都有着自己的逻辑要求；<br>1、手机号码11位<br>2、前三位固定格式+后8位任意数<br>3、前三位格式有：<br>（1）13+任意数<br> （2） 15+除4的任意数<br> （3） 18+除1和4的任意数<br> （4） 17+除9的任意数<br>正则表达式（regular expression）就是<strong>用来描述字符串逻辑规则的工具</strong>；<br>用分支语句写代码进行判断，可想而知多么复杂。尤其如果改了规则，就要重新编写代码；太复杂！<br>可以用正则表达式，把规则描述出来，每次看一下是否匹配就OK啦，如果规则改变，只要把正则表达式修改就行了！</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p><strong>正则表达式本身也是个字符串</strong>，不过这些字符串是使用系列“元字符”组成；<br>所谓“元字符”就是预先定义的，有特殊意义的字符；例如\d用来匹配一个数字； \w用来匹配字母或数字或下划线或汉字等；<br>很多语言多对正则表达式提供了支持，例如JavaScript、Java等；<br>不同语言中使用正则表达式时，正则表达式的具体编写规则会有些小的差别，但是大体相同；<br>要使用正则表达式，首先要学会根据规则编写正则表达式；<br>正则表达式由“元字符”组成，掌握了元字符的含义，就可以开始编写正则表达式；<br>常用元字符：</p>
<p><img src="/2020/03/22/java2/image241.png" alt><br><img src="/2020/03/22/java2/image242.png" alt><br><img src="/2020/03/22/java2/image243.png" alt><br>[abc]:只是匹配单个单词<br>[abc]*:表示a、b、c出现0或者多次</p>
<p><img src="/2020/03/22/java2/image244.png" alt><br>正则表达式中往往需要对一些字符出现的次数进行规定，则需要量词；<br>量词有不同的策略，Java中有三种策略，此处列出的是Greedy策略；<br>常用量词：</p>
<p><img src="/2020/03/22/java2/image245.png" alt></p>
<h2 id="Java如何进行表达式验证"><a href="#Java如何进行表达式验证" class="headerlink" title="Java如何进行表达式验证"></a>Java如何进行表达式验证</h2><p>Java语言中有一个包java.util.regex，提供了对正则表达式进行匹配的相关类，<br>该包里主要有两个类：</p>
<p><img src="/2020/03/22/java2/image246.png" alt><br><img src="/2020/03/22/java2/image247.png" alt><br><img src="/2020/03/22/java2/image248.png" alt><br><img src="/2020/03/22/java2/image249.png" alt></p>
<h2 id="String中正则表达式"><a href="#String中正则表达式" class="headerlink" title="String中正则表达式"></a>String中正则表达式</h2><p>String类中也有与正则表达式有关的方法，上页提到的matches就是其中一个，用来对字符串进行匹配使用；其实这些方法也都是调用了Pattern和Matcher类的相关方法；<br>String类中与正则表达式有关的方法：</p>
<p><img src="/2020/03/22/java2/image250.png" alt><br><img src="/2020/03/22/java2/image251.png" alt></p>
<h2 id="字符串缓冲"><a href="#字符串缓冲" class="headerlink" title="字符串缓冲"></a>字符串缓冲</h2><p>熟练掌握String、StringBuffer、StringBuilder之间的差异与适用场景<br>Java语言中的有一个StringBuffer类，称为字符串缓冲区；所表示的也是一个字符序列；<br>这个类型必须用new创建对象，和String相反，它是可变的类；<br>StringBuffer sbf1=new StringBuffer (“Etc”);<br>StringBuffer sbf2=new StringBuffer (“ Java”);<br>sbf1.append(sbf2);//用于字符串拼接<br>System.out.println(sbf1);<br>输出结果为：Etc Java<br>证明：<strong>StringBuffer是一个可变的字符串类</strong><br>Java语言中的还有一个StringBuilder类，与StringBuffer兼容，但是不保证线程同步；</p>
<h2 id="三个类的区别"><a href="#三个类的区别" class="headerlink" title="三个类的区别"></a>三个类的区别</h2><p><strong>String类是不可变的</strong>，对象一旦被创建，就不能被修改；可以使用=直接赋值，此时使用常量池；也可以使用new创建，不使用常量池；<br><strong>StringBuffer是可变的</strong>，对象创建后，可以修改；必须使用new关键字；<br><strong>StringBuilder是不同步的</strong>，在单线程情况下使用比StringBuffer高效；必须使用new关键字；</p>
<h2 id="数学API"><a href="#数学API" class="headerlink" title="数学API"></a>数学API</h2><p>熟练使用Math类提供的各类数学方法<br>能够使用BigDecimal、BigInteger工具进行超出Java基本数据类型范围的数字之间的数学运算、比较运算、位运算<br>了解大整数工具的基本实现原理<br>Math类位于java.lang包中，是一个final类，不能被继承；<br>Math类中所有方法都是static方法，可以直接使用类名Math调用；<br>Math中定义了大量与数学运算有关的方法，包括求绝对值、三角函数、平方根等；<br>部分方法如下：</p>
<p><img src="/2020/03/22/java2/image252.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//	使用字符串表示超出范围的大整数</span><br><span class="line">	String s1=&quot;29219291291919391912919283232323&quot;;</span><br><span class="line">	String s2=&quot;2007594379874134134134127943&quot;;</span><br><span class="line"></span><br><span class="line">//	将字符串作为参数，创建大整数BigInteger对象	</span><br><span class="line">	BigInteger bi1=new BigInteger(s1);</span><br><span class="line">	BigInteger bi2=new BigInteger(s2);</span><br><span class="line"></span><br><span class="line">//	调用BigInteger类中的方法进行运算,下面是加法和出发	</span><br><span class="line">	System.out.println(bi1.add(bi2));</span><br><span class="line">	System.out.println(bi1.divide(bi2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java.math包中还有一个类叫BigDecimal，虽然和整数无关，我们也在此一起学习；<br>BigDecimal是用来针对浮点型进行精确运算的;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//使用double类型进行运算</span><br><span class="line">	double d1=4.3;</span><br><span class="line">	double d2=5.8;</span><br><span class="line">	System.out.println(d1+d2);</span><br><span class="line">10.1</span><br><span class="line"></span><br><span class="line">//	使用BigDecimal类型进行运算</span><br><span class="line">	BigDecimal bd1=new BigDecimal(d1);</span><br><span class="line">	BigDecimal bd2=new BigDecimal(d2);</span><br><span class="line">	System.out.println(bd1.add(bd2));</span><br><span class="line">结果：10.09999999999999964472863211994990706443786621093750</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/22/java2/image253.png" alt></p>
<h2 id="随机API"><a href="#随机API" class="headerlink" title="随机API"></a>随机API</h2><p>熟练使用Math.random以及Random类的相关方法获取符合要求的随机数值<br>熟悉UUID的定义及功能<br>熟练使用UUID工具</p>
<p>Math类中的random方法可以产生随机数，上节演示过。然而，该方法只能生成[0.0,1.0)范围的double值；很多时候，可能需要生成不同类型不同范围的随机值；<br>java.util包中的Random类可以用来生成不同类型的随机值，功能更为强大；<br>Random类创建对象两种方式:</p>
<p><img src="/2020/03/22/java2/image254.png" alt><br>java.util包中的Random类有多个生成随机数的相关方法：</p>
<p><img src="/2020/03/22/java2/image255.png" alt><br><img src="/2020/03/22/java2/image256.png" alt></p>
<h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>UUID是<strong>通用唯一识别码</strong> (Universally Unique Identifier)的缩写，是<strong>唯一的机器生成的标识符</strong>；<br>UUID都<strong>不能是人工生成</strong>的，这样风险太高；<br>UUID是<strong>16字节128位长的数字</strong>，通常以36字节的字符串表示，示例如下：3F2504E0-4F89-11D3-9A0C-0305E82C3301<br>通常在<strong>分布式系统中用来生成唯一ID</strong></p>
<p>UUID具有多个版本，每个版本的算法不同；<br>UUID Version 1：基于时间的UUID<br>通过计算当前时间戳、随机数和机器MAC地址得到。<br>UUID Version 2：DCE安全的UUID<br>和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID。这个版本的UUID在实际中较少用到。<br>UUID Version 3：基于名字的UUID（MD5）<br>通过计算名字和名字空间的MD5散列值得到。<br>UUID Version 4：随机UUID<br>根据随机数，或者伪随机数生成UUID。<br>UUID Version 5：基于名字的UUID（SHA1）<br>和版本3的UUID算法类似，只是散列值计算使用SHA1（Secure Hash Algorithm 1）算法。<br>Java中对UUID的生成提供了支持，java.util.UUID 类定义了生成UUID的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">	UUID uuid=UUID.randomUUID();</span><br><span class="line">	System.out.println(uuid);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/22/java2/image257.png" alt></p>
<h2 id="JAVA日期与时间相关API"><a href="#JAVA日期与时间相关API" class="headerlink" title="JAVA日期与时间相关API"></a>JAVA日期与时间相关API</h2><p>了解Java中时间的表达方式<br><strong>掌握Date对象及Calendar对象的创建方法以及设置、获取时间的API调用</strong><br><strong>掌握日期与时间数据的格式化方法</strong></p>
<p><img src="/2020/03/22/java2/image258.png" alt></p>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>java.util.Date类表示时间，<strong>不过由于对国际化支持有限</strong>，所以JDK1.1之后推荐使用java.util.Calendar类；<br>java.util.Date类中很多构造方法和方法已经过时（Deprecated），不推荐使用，此处只学习两个没过时的构造方法；</p>
<p><img src="/2020/03/22/java2/image259.png" alt><br><img src="/2020/03/22/java2/image260.png" alt></p>
<h2 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h2><p>JDK1.1版本开始，增加Calendar类，建议使用Calendar类代替Date类；<br>Calendar是抽象类，不能直接使用new创建对象；<br>Calendar类中定义了获得实例的方法：</p>
<p><img src="/2020/03/22/java2/image261.png" alt><br>//使用默认时区和语言环境获得日历对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar1=Calendar.getInstance();</span><br></pre></td></tr></table></figure>
<p>//使用指定时区和语言环境获得日历对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar2=Calendar.getInstance(TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;),Locale.CHINA);</span><br></pre></td></tr></table></figure>
<p>获得日历对象后，可以为该对象的年、月、日、时、分、秒等进行赋值：<br><img src="/2020/03/22/java2/image262.png" alt><br>对Calendar的字段赋值后，可以根据实际需要返回相应字段值；<br><img src="/2020/03/22/java2/image263.png" alt><br>对Calendar的字段赋值后，可以对其值进行修改；</p>
<p><img src="/2020/03/22/java2/image264.png" alt><br>//修改Calendar的字段值,将年份加1<br>calendar2.add(Calendar.YEAR , 1);</p>
<h2 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h2><p>实际编程中，往往需要对时间用不同的格式进行展示；<br>SimpleDateFormat中定义了<strong>对时间进行格式化的方法</strong>；该类继承了抽象父类DateFormat，某些方法在父类中定义，查阅API文档时注意；<br>可以自定义一个<strong>模式字符串来构建SimpleDateFormat对象</strong>：</p>
<p><img src="/2020/03/22/java2/image265.png" alt></p>
<p>通常使用format方法进行格式化；<br><img src="/2020/03/22/java2/image266.png" alt><br>SimpleDateFormat类的API文档中，对pattern中出现的字符含义有详细描述：<br><img src="/2020/03/22/java2/image267.png" alt><br>在实际编程中，往往一些时间内容都是通过用户输入获得，得到的是字符串，需要解析成日期时间类型进行处理；<br>SimpleDateFormat类不仅能够格式化时间，还能解析时间字符串；<br><img src="/2020/03/22/java2/image268.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf1=new SimpleDateFormat(&quot;yyyy年MM月dd日hh时mm分ss秒&quot;);</span><br><span class="line">//字符串str1表示时间信息</span><br><span class="line">String str1=&quot;2002年5月1日8时12分9秒&quot;;</span><br><span class="line">try &#123;</span><br><span class="line">//使用SimpleDateFormat类的parse方法，把字符串转换成Date类型对象</span><br><span class="line">Date date2=sdf1.parse(str1);</span><br><span class="line">System.out.println(date2);</span><br><span class="line">&#125; catch (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/22/java2/image269.png" alt></p>
<h2 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h2><p>JDK8中定义了java.time.LocalDate，用来表示日期，默认格式是yyyy-MM-dd；该类不包含时间信息；<br>常用的获得LocalDate对象的方式如下：<br><img src="/2020/03/22/java2/image270.png" alt><br><img src="/2020/03/22/java2/image271.png" alt><br><img src="/2020/03/22/java2/image272.png" alt></p>
<h2 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h2><p>LocalDate类只表示日期，JDK8中定义了新类LocalTime用来表示时间，用法与LocalDate类似；<br><img src="/2020/03/22/java2/image273.png" alt><br>LocalDate类只表示日期，LocalTime只表示时间，JDK8中还定义了一个LocalDateTime类，同时包含日期与时间，用法与LocalDate及LocalTime类似；<br><img src="/2020/03/22/java2/image274.png" alt></p>
<p>对于格式化及解析，JDK8中使用DateTimeFormatter类实现；<br>获得DateTimeFormatter对象的部分方法：<br><img src="/2020/03/22/java2/image275.png" alt><br>LocalDate、LocalTime、LocalDateTime类都可以使用DateTimeFormatter对象进行格式化；<br>另外，LocalDate、LocalTime、LocalDateTime类都定义了parse方法，可以使用DateTimeFormatter对象把字符串按照指定的格式转换成时间日期类型对象。<br><img src="/2020/03/22/java2/image276.png" alt></p>
<h2 id="Java国际化"><a href="#Java国际化" class="headerlink" title="Java国际化"></a>Java国际化</h2><p>熟练掌握Java中的properties配置文件的结构<br>了解Java中对语言和地区后缀的规定<br>掌握使用properties配置文件的几种方法，熟记Java获取properties文件时对语言和地区的匹配规则<br>掌握利用properties配置文件进行国际化支持的方法<br>了解MessageFormat对字符串的格式化以及｛数字｝占位符的使用</p>
<p>所谓<strong>国际化（internationalization，简称i18n）</strong>指的是<strong>一个应用程序能够支持多种语言，根据客户的语言环境返回不同语言的界面；</strong><br>要实现国际化，简单地说，就是要为应用程序准备几套不同语言版本的资源文件，这些资源文件按照命名规范放置在不同的目录下，应用程序能够根据客户的语言环境自动匹配使用不同版本的资源文件；<br>“国际化信息”也被称为“本地化信息”，要确定一个特点类型的“本地化信息”，起码需要确定** “语言类型”和“国家/地区的类型”；**<br><strong>Java.util.Locale</strong>是表示语言和国家/地区信息的本地化类，是Java创建国际化应用的基础。</p>
<p>如果应用系统中某些信息需要支持国际化功能，则必须为希望支持的不同本地化类型分别提供对应的资源文件，并以规范的方式进行命名；<br>国际化资源文件的命名规范规定资源名称采用以下的方式进行命名：<br>&lt;资源名&gt;_&lt;语言代码&gt;_&lt;国家/地区代码&gt;.properties<br>其中，语言代码和国家/地区代码都是可选的；<br>&lt;资源名&gt;.properties命名的国际化资源文件是默认的资源文件，即某个本地化类型在系统中找不到对应的资源文件，就采用这个默认的资源文件；</p>
<p>例如一个应用系统希望支持中国和美国两个地区，那么国际化的信息就可以分别存在两个properties文件中<br>properties文件中都是用键值对的形式存储信息，例如：<br><img src="/2020/03/22/java2/image277.png" alt><br>假设资源文件名称是message，那么名字可以分别是message_zh_CN.properties，message_en_US.properties；如果语言和地区环境既不是中国又不是美国，则默认使用message.properties<br><img src="/2020/03/22/java2/image278.png" alt><br>properties资源文件对内容有严格要求，只能是ASCII码。例如，当我们编写中文内容时，就要想办法把中文进行转换；<br>对属性文件（即<em>.properties文件）的处理，Java API中有两个类可以实现，即Properties类及*</em>ResourceBundle<strong>类；<br>**如果不考虑国际化，只读取属性内容，一般使用Properties类即可；<br>考虑到国际化，往往使用ResourceBundle</strong><br><img src="/2020/03/22/java2/image279.png" alt><br><img src="/2020/03/22/java2/image280.png" alt></p>
<h2 id="MessageFormat"><a href="#MessageFormat" class="headerlink" title="MessageFormat"></a>MessageFormat</h2><p>国际化过程中，最常用到各种文本消息，很多时候需要对消息进行格式化；<br>java.text.MessageFormat类可以用来进行消息文本格式化；<br>本类常用方法如下：<br><img src="/2020/03/22/java2/image281.png" alt><br>模式字符串的格式有三种：<br><strong>{ 参数索引 }<br>{ 参数索引 , 类型 }<br>{ 参数索引 , 类型，风格}</strong><br>类型： number 、date、 time 、choice<br>风格：short、medium、 long、 full、integer、 currency、percent、 SubformatPattern<br>//创建pattern<br>String pattern=”{0}顾客您好，应付金额{1,number,currency}”;<br>System.out.println(MessageFormat.format(pattern, new Object[]{“Alice”,134.8}));<br>System.out.println(MessageFormat.format(pattern, new Object[]{“章紫”,4334.8}));<br>进行国际化的properties文件中也可以使用格式化的字符串，如下是resource_en_US.properties文件中的一个key值：<br>msg.order=hello,{0},you will pay{1,number,currency}.<br>使用ResourceBundle获取某个key值后，可以使用MessageFormat进行格式化操作：<br>System.out.println(MessageFormat.format(rb2.getString(“msg.order”),newObject[]{“Alice”,134.8}));<br><img src="/2020/03/22/java2/image282.png" alt></p>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>掌握Java中对文件/文件夹的各种操作方法<br>了解输入输出流的概念<br>掌握Java中输入输出流的分类<br>掌握Java输入输出类型的继承树即常用输入输出流的功能与基本使用方法<br>了解nio的特性</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>什么是文件？<br>文件可以认为是相关记录或存放在一起的数据的集合<br>文件一般是存放在存储设备上的，例如：硬盘、光盘和移动存储设备等等<br>java.io包是JDK内置的包，其中包含一系列对文件和目录的属性进行操作，对文件进行读写操作的类；<br>程序中如果要使用到该包中的类，对文件或流进行操作，则必须显式地声明如下语句：<br>import java.io.*;   导入io包<br><img src="/2020/03/22/java2/image283.png" alt></p>
<h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p>java.io.File类的对象可以表示文件和目录，<strong>在程序中一个File类对象可以代表一个文件或目录</strong><br>当创建一个File对象后，就可以利用它来对文件或目录的属性进行操作，如：文件名、最后修改日期、文件大小等等<br>需要注意的是，<strong>File对象并不能直接对文件内容进行读/写操作，只能查看文件的属性</strong></p>
<p>File类的构造方法有4种重载方式，常用的如下：<br><img src="/2020/03/22/java2/image284.png" alt><br>File f1 = new File(“chinasofti.txt”);   //相对路径  以当前类为参照物找文件<br>File f2 = new File(“D:\Java\Hello.java”);//绝对路径  从磁盘路径取查询</p>
<p>构建File对象是需要注意的要点：<br>提供给构造方法的路径可以<strong>指向一个具体的文件</strong>，这时候<strong>File对象能够操作</strong>这个<strong>文件的属性</strong>，也可以<strong>指向一个文件夹</strong>，这时候<strong>File对象操作</strong>的就是<strong>文件夹的属性</strong><br>注意上例第二个对象的路径表达，由于<strong>在Java中“\”符号表示转意，因此如果使用”\”作为路径分割符，则实际需要编写“\”，当然一个更好的替代方法是使用Unix系统中常用的”/”作为路径分割，则不需要转意</strong><br>特别注意，Java中的相对路径体系和我们日常所见的文件系统相对路径体系有较大的区别：<br><strong>如果以路径以“/”或“\”开头，则相对路径的根为当前项目所在磁盘的根目录</strong>（Unix没有磁盘分区的概念，因此直接使用/，即文件系统的根作为相对路劲的根）<br><strong>如果不以“/”开头则相对路径的根为项目根目录，而不是当前类所在目录</strong>，这一点非常容易引起误区，因为类从属于某个包之后，类文件实际是位于项目中的某个子文件夹中的，如com.chinasoft.Hello这个类是位于项目中的com\chinasofti子文件夹中，如果在Hello类中构建一个File对象：FIle f = new File(“icss/chinasofti.txt”)，那么这个文件位于项目根目录的icss子文件中，跟当前类自己的位置无关</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><img src="/2020/03/22/java2/image285.png" alt><br><img src="/2020/03/22/java2/image286.png" alt></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>File对象可不可以描述文件夹？<br>Java中的相对路径有什么规则？<br>在程序中<strong>一个File类对象可以代表一个文件或目录</strong><br><strong>File f=new File()不能证明f是存在 f只是JVM内存中创建的对象实际磁盘不会直接创建</strong><br>Java中的相对路径体系和我们日常所见的文件系统相对路径体系有较大的区别：如果以路径以“/”或“\”开头，则相对路径的根为当前项目所在磁盘的根目录（Unix没有磁盘分区的概念，因此直接使用/，即文件系统的根作为相对路劲的根），如果不以“/”开头则相对路径的根为项目根目录，而不是当前类所在目录，这一点非常容易引起误区，因为类从属于某个包之后，类文件实际是位于项目中的某个子文件夹中的，如com.chinasoft.Hello这个类是位于项目中的com\chinasofti子文件夹中，如果在Hello类中构建一个File对象：FIle f = new File(“icss/chinasofti.txt”)，那么这个文件位于项目根目录的icss子文件中，跟当前类自己的位置无关</p>
<h2 id="IO输出入流"><a href="#IO输出入流" class="headerlink" title="IO输出入流"></a>IO输出入流</h2><p><img src="/2020/03/22/java2/image287.png" alt><br>为什么好好的Bus不叫巴士而要翻译成“总线呢”?原因是这样在描述其寻址、数据传输的功能基础上更能描述其最核心的物理特性，对，总线就是“汇总的线”，最基础的总线物理结构（不考虑控制芯片带来的频率等特性）就如你看到的排线<br>计算机内部充斥着各种独立的、印刷的能够同事传输多个脉冲信号的排线（总线）<br>从逻辑上网线也是一种数据总线，那么如果将网线看作数据总线的话，它的位宽（能够一次性传输多少bit，一般有总线物理传输数据的数据线数量决定）是多少？<br>从示意图看出，网线中有4根线没有定义用途（备用），剩下4根每两根利用差分信号分别发送/接受数据，由于网线是全双工通讯，因此对于特定的应用程序的输入或输出而言，网线的逻辑总线位宽为1位</p>
<p><img src="/2020/03/22/java2/image288.png" alt><br><img src="/2020/03/22/java2/image289.png" alt></p>
<p>从上例可以看出，当数据在逻辑上的总线上传输时，发生总线位宽大小变化，都将需要一个缓存和流式串行传输的过程，因此我们把操作这个过程的工具称为：流（Stream）<br>逻辑总线由宽变窄的过程是高位宽并发传输-&gt;缓存-&gt;低位宽流式串行传输<br>逻辑总线由窄变宽的过程是低位宽流式串行传输-&gt;缓存-&gt;高位宽并发传输<br>不管如何变化，但是只要发生了逻辑总线位宽变化时均需要使用流<br>流的特点：<br>流是一串连续不断的数据的集合，就象水管里的水流，在水管的一端一点一点地供水，而在水管的另一端看到的是一股连续不断的水流。数据写入程序可以是一段、一段地向数据流管道中写入数据，这些数据段会按先后顺序形成一个长的数据流。对数据读取程序来说，看不到数据流在写入时的分段情况，每次可以读取其中的任意长度的数据，但只能先读取前面的数据后，再读取后面的数据。不管写入时是将数据分多次写入，还是作为一个整体一次写入，读取时的效果都是完全一样的<br>流是磁盘或其它外围设备中存储的数据的源点或终点</p>
<h2 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h2><p><img src="/2020/03/22/java2/image290.png" alt></p>
<p>对于输入和输出流，由于传输格式的不同，又分为字节流和字符流：<br>字节流是指8位的通用字节流，以字节为基本单位，在java.io包中，<strong>对于字节流进行操作的类大部分继承于InputStream（输入字节流）类和OutputStream（输出字节流）类</strong><br>字符流是指16位的Unicode字符流，以字符（两个字节）为基本单位，非常适合处理字符串和文本，<strong>对于字符流进行操作的类大部分继承于Reader（读取流）类和Writer（写入流）类</strong></p>
<p>Java I/O主要包括如下几个层次，包含三个部分：<br><strong>流式部分:IO的主体部分；</strong><br><strong>非流式部分:主要包含一些辅助流式部分的类，如：File类、RandomAccessFile类和FileDescriptor等类；</strong><br><strong>其他类:文件读取部分的与安全相关的类</strong>，如：SerializablePermission类，以及与本地操作系统相关的文件系统的类，如：FileSystem类和Win32FileSystem类和WinNTFileSystem类。</p>
<p><img src="/2020/03/22/java2/image291.png" alt></p>
<h3 id="输入流树状结构"><a href="#输入流树状结构" class="headerlink" title="输入流树状结构"></a>输入流树状结构</h3><p><img src="/2020/03/22/java2/image292.png" alt><br><img src="/2020/03/22/java2/image293.png" alt><br><img src="/2020/03/22/java2/image294.png" alt><br><img src="/2020/03/22/java2/image295.png" alt></p>
<h2 id="线程特性"><a href="#线程特性" class="headerlink" title="线程特性"></a>线程特性</h2><p>java.io.*包是Java中最传统的IO操作（相对于nio,nio将在本章最后一节介绍），在利用io包的输入流工具（InputStream、Reader）进行数据读取操作时，如果无法读取到需要的内容，将会导致执行读取数据操作的线程陷入阻塞状态<br>因此，在进行流的写入和读取时要尤为小心，保证数据读取的数量和顺序的准确性，否则可能导致应用执行异常</p>
<h2 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h2><p>如果需要将Java中能够表达所有数据缓存在内存中（包括字符类型或二进制类型），最适宜于使用的数据类型是：byte[]<br>OutputStream是一个抽象类，提供了Java向流中以字节为单位写入数据的公开接口，大部分字节输出流都继承自OutputStream类，重要的写入方法如下：<br>原因是Java中所有的数据类型占据的空间都是byte型的整数倍数<br>void write(byte[] b, int off, int len)：将字节数组b进行写出 从oof下标开始，一直len结束<br><img src="/2020/03/22/java2/image296.png" alt></p>
<h2 id="实现类FileOutputStream"><a href="#实现类FileOutputStream" class="headerlink" title="实现类FileOutputStream"></a>实现类FileOutputStream</h2><p>为了解决之前提出的向数据文件中写入持久化运算结果的问题，我们需要使用FileOutputStream类，它称为文件输出流，继承于OutputStream类，是进行文件内容写操作的最基本类工具<br>FileOutputStream能够将内存中的数据输出到文件中<br><img src="/2020/03/22/java2/image297.png" alt><br><img src="/2020/03/22/java2/image298.png" alt></p>
<h2 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h2><p>java的IO模型设计非常优秀，它使用Decorator模式，按功能划分Stream，我们可以动态装配这些Stream，以便获得需要的功能。例如需要一个具有缓冲的文件输入流，则应当组合使用FileInputStream和BufferedInputStream<br>InputStream也是一个抽象类，提供了Java中从流中以字节为单位读取数据的公开接口，大部分字节输入流都继承自InputStream类<br>InputStream提供了针对数据流读取的公共接口，其中比较重要的数据读取方法如下：<br>int read(byte[] b, int off, int len)<br><img src="/2020/03/22/java2/image299.png" alt><br><img src="/2020/03/22/java2/image300.png" alt></p>
<h2 id="文件字节输入流FileInputStream"><a href="#文件字节输入流FileInputStream" class="headerlink" title="文件字节输入流FileInputStream"></a>文件字节输入流FileInputStream</h2><p><img src="/2020/03/22/java2/image301.png" alt></p>
<h2 id="DataOutput"><a href="#DataOutput" class="headerlink" title="DataOutput"></a>DataOutput</h2><p>DataOutput接口规定一组操作，<strong>用于以一种与机器无关（当前操作系统等）的方式</strong>，直接向流中写入基本类型的数据和字符串：<br>DataInput对基本数据类型的写入分别提供了不同的方法，方法名满足writeXXX()的规律，其中XXX即为基本类型说明符（首字母大写），如writeInt()表示向流中写入一个int型数据<br>写入字符串的方法为writeUTF()，该方法的功能声明将标准的UTF-8字符编码表示形式做出了稍许修改<br>DataInput接口规定一组操作，用于以一种与机器无关（当前操作系统等）的方式，直接在流中读取基本类型的数据和字符串：<br>DataInput对基本数据类型的读取分别提供了不同的方法，方法名满足readXXX()的规律，其中XXX即为基本类型说明符（首字母大写），如readInt()表示从流中读取一个int型数据<br>读取字符串的方法为readUTF()，该方法的功能声明将标准的UTF-8字符编码表示形式做出了稍许修改，接口还提供了readLine()方法，但是在一些常用的实现中不建议使用<br>事实上，DataInput和DataOutput对应，即DataInput读取由DataOutput写入的数据<br><img src="/2020/03/22/java2/image302.png" alt></p>
<p>在使用输出流之前需要了解一下FilterOutputStream 的作用 用来进行装饰 （功能加强）<br>FilterOutputStream是用来封装其它的输出流，并为它们提供额外的功能。它的实现主要包括BufferedOutputStream, DataOutputStream和PrintStream<br><strong>BufferedOutputStream的作用就是为输出流提供缓冲功能</strong><br><strong>DataOutputStream 是用来装饰其它输出流，它实现了DataOutput接口</strong>，将DataOutputStream和DataInputStream输入流配合使用，允许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型和字符串<br><strong>PrintStream 是用来装饰其它输出流。</strong>它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式</p>
<h2 id="文件拷贝案例"><a href="#文件拷贝案例" class="headerlink" title="文件拷贝案例"></a>文件拷贝案例</h2><p>也可以通过输入输出流进行文件移动或拷贝操作<br>如果利用nio进行文件拷贝操作，在高并发情况下，效率将比传统IO更高（nio小节介绍），但是需要注意，在JDK1.4+的版本上大部分IO工具都利用NIO的块操作模式重新实现，所以性能有很大进步<br><img src="/2020/03/22/java2/image303.png" alt></p>
<p>缓存的新应用之一就是回推的实现。回推用于输入流，以允许读取字节，然后再将它们返回（回推）到流中，PushbackInputStream类实现了这一思想，提供了一种机制，可以“偷窥”来自输入流的内容而不对它们进行破坏<br>PushbackInputStream类具有以下构造函数：<br>PushbackInputStream(InputStream inputStream)<br>PushbackInputStream(InputStream inputStream,int numBytes)<br>第一种形式创建的流对象允许将一个字节返回到输入流； 第二种形式创建的流对象具有一个长度为numBytes的回推缓存，从而允许将多个字节回推到输入流中<br>除了熟悉的来自InputStream的方法外，PushbackInputStream类还提供了unread()方法：<br>void unread(int b)<br>void unread(byte[] buffer)<br>void unread(byte[] buffer,int offset,int numBytes)<br>第一种形式回推b的低字节，这会使得后续的read()调用会把这个字节再次读取出来。第二种形式回推buffer中的字节。第三种形式回推buffer中从offset开始的numBytes个字节。当回推缓存已满时，如果试图回推字节，就会抛出IOException异常<br><img src="/2020/03/22/java2/image304.png" alt><br>PushbackInputStream对象会使得InputStream对象（用于创建PushbackInputStream对象）的mark()或reset()方法无效。对于准备使用mark()或reset()方法的任何流来说，都应当使用markSupported()方法进行检查<br>程序对应的基本输入为键盘输入，基本输出为显示器输出。Java中，System类的in和out两个成员代表了基本输入输出的抽象<br>System.in:    new Scanner(System.in);<br>基本输入，对应InputStream<br>System.out:    System.out.println()<br>基本输出，对应PrintStream</p>
<h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><p>之前通过流访问文件都是循序访问的，在某些时候我们需要对文件进行随机访问，就需要借助与RandomAccessFile工具<br>RandomAccessFile类可以在文件中<strong>任何位置查找或写入数据</strong><br>RandomAccessFile同时实现了<strong>DataInput和DataOutput接口</strong><br><strong>磁盘文件</strong>都是可以随机访问的， 但是从<strong>网络而来</strong>的数据流却不是<br>通过构造器打开一个随机访问文件工具对象，通过参数可以确定只用于读取数据或同时用于读写：<br>RandomAccessFile in= new RandomAccessFile(“data.bin”, “r”);//读取<br>RandomAccessFile inOut = new RandomAccessFile(“data.bin”, “rw”);//写w 读写rw<br>seek 方法：<br>随机访问文件有一个表示下一个将被读入或写出的字节所处的位置的文件指针， seek方法可以将这个文件指针设置到文件中任意字节的位置<br>使用RandomAccessFile工具要点：<br>假设想读入第三条数据：<br>long n = 3;<br>in.seek((n-1) * RECORD_SIZE);<br>如果希望修改数据，切记将文件指针重置到希望写入文件的开始处：<br>in.seek((n-1) * RECORD_SIZE);<br>e.writeData(out);<br>length()方法:<br>确定文件大小，使用 length 方法；<br>RandomAccessFile的具体使用参见课堂案例（课堂案例：RandomFileTest.java）<br>整数和浮点值在二进制格式中都有固定的尺寸， 但处理字符串就存在麻烦，之前提到过如果使用writeUTF()实际是对Unicode编码做了简单的处理，每个字符长度并不相同，因此在示例代码中我们提供了两个自定义方法来读写具有固定尺寸的字符串：<br>writeFixedString 方法：<br>写出从字符串开头开始的指定数量的字符编码<br>readFixedString 方法：<br>从输入流中读入字符，直至读入参数个字符编码， 或者直至到具有0值的字符值，然后跳过输入字段中剩余的0值；为了提高效率，使用 StringBuilder 类来读入字符串<br><img src="/2020/03/22/java2/image305.png" alt></p>
<h2 id="字节数组输入输出流"><a href="#字节数组输入输出流" class="headerlink" title="字节数组输入输出流"></a>字节数组输入输出流</h2><p>ByteArrayOutputStream提供工具将<strong>内存中以串行序列存在的流式数据以一个字节为单位进行切分，形成一个byte[]数组</strong><br>而ByteArrayInputStream则正好相反，提供工具将<strong>内存中的byte[]数组中的数据进行串行序列化拼接，形成一个可供操作的流式数据</strong><br>从功能上看，ByteArrayOutpuStream可以将任意数据组合转换为byte[]，而ByteArrayInputStream可以将这个数组还原，从而以流的形式读取任意数据组合</p>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>FileInputStram类和FileOutputStream类虽然可以高效率地读/写文件，但对于Unicode编码的文件，我们需要自行将读取到的字节数据根据编码规则还原为字符串，因此使用它们有可能出现乱码<br>考虑到Java是跨平台的语言，要经常操作Unicode编码的文件，使用基于字符为读、写基本单元的字符流操作文件是有必要的,以字符为单位进行数据输出的工具继承自Writer<br>Writer和OutputStream类似也提供了统一的往流中写入数据的方法，和OutputStream不同的是，写入数据的单位由字节变成了字符：<br><img src="/2020/03/22/java2/image306.png" alt><br><img src="/2020/03/22/java2/image307.png" alt><br><img src="/2020/03/22/java2/image308.png" alt><br><img src="/2020/03/22/java2/image309.png" alt></p>
<p>以字符为单位进行数据读取的工具继承自Reader，Reader会将读取到的数据按照标准的规则转换为Java字符串对象<br>字符输入流Reader也提供的统一读取数据的方法（和InputStream不同，实际开发时更多的调用不同Reader提供的特殊读取方法，如BufferedReader的readLine()，能够简化操作）：<br><img src="/2020/03/22/java2/image310.png" alt></p>
<h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><p>类称为文件读取流，允许以字符流的形式对文件进行读操作，其构造方法有3种重载方式，以下是常用的几种：<br><img src="/2020/03/22/java2/image311.png" alt><br>与FileWriter相似，该类将从文件中逐个地读取字符，效率比较低下，因此一般也将该类对象包装到缓冲流中进行操作<br><img src="/2020/03/22/java2/image312.png" alt><br><img src="/2020/03/22/java2/image313.png" alt></p>
<p>FileWriter将逐个向文件写入字符，效率比较低下，因此一般将该类对象包装到缓冲流BufferedWriter中进行操作<br>还可以使用PrintWriter对流进行包装，提供更方便的字符输出格式控制<br>利用缓冲流包装FileReader<br><img src="/2020/03/22/java2/image314.png" alt></p>
<p>和PushbackInputStream类似，Java也提供了PushbackReader，提供了在读取流的同时将字符推回流的能力，使用方法和PushbackInputStream类似<br><img src="/2020/03/22/java2/image315.png" alt></p>
<h2 id="字节流与字符流适配器-桥转换"><a href="#字节流与字符流适配器-桥转换" class="headerlink" title="字节流与字符流适配器(桥转换)"></a>字节流与字符流适配器(桥转换)</h2><p>在某些时候虽然我们操作的是字符串，但是不得不面对数据来源是InputStream（字节输入流）的情况，在这种情况下，Java提供了将InputStream和Reader之间进行转换的工具，事实上，字节输出流和字符输出流之间也存在这种工具，称为：字节流与字符流的适配器：</p>
<h3 id="InputStreamReader："><a href="#InputStreamReader：" class="headerlink" title="InputStreamReader："></a>InputStreamReader：</h3><p><strong>字节流通向字符流的桥梁</strong>，它使用指定的<strong>charset 读取字节并将其解码为字符</strong>。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集<br>每次调用 InputStreamReader 中的一个 read() 方法都会导致从底层输入流读取一个或多个字节。要启用从字节到字符的有效转换，可以提前从底层流读取更多的字节，使其超过满足当前读取操作所需的字节</p>
<h3 id="OutputStreamWriter："><a href="#OutputStreamWriter：" class="headerlink" title="OutputStreamWriter："></a>OutputStreamWriter：</h3><p><strong>字符流通向字节流的桥梁</strong>，使用指定的 <strong>charset 将要写入流中的字符编码成字节</strong>。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集<br>每次调用 write() 方法都会导致在给定字符（或字符集）上调用编码转换器。在写入底层输出流之前，得到的这些字节将在缓冲区中累积。可以指定此缓冲区的大小，不过，默认的缓冲区对多数用途来说已足够大。注意，传递给 write() 方法的字符没有缓冲<br><img src="/2020/03/22/java2/image316.png" alt><br>例如，为了提高效率，可以将代表基本输入的字节流System.in包装到BufferedReader中用以一次性捕获键盘输入的一行字符串数据：<br><img src="/2020/03/22/java2/image317.png" alt><br>Java还提供了另一个包装工具来方便的进行流中数据的读取:Scanner<br>Scanner类位于<strong>java.util</strong>包中，不在java.io包中，<strong>不属于IO流</strong><br>Scanner是一个工具类，主要目标是<strong>简化文本的扫描</strong>，最常使用此类获取控制台输入,Scanner获取控制台输入的步骤:<br><strong>使用控制台输入创建Scanner对象<br>Scanner  scanner=new  Scanner(System.in);<br>调用Scanner中的nextXXX方法，获得需要的数据类型</strong><br>例如：next、 nextLine、nextInt、nextByte等<br><img src="/2020/03/22/java2/image318.png" alt><br>java中有几种类型的流？jdk为每种类型的流提供了一些抽象类以供继承，请说出它们分别是什么？</p>
<p>Java中的输入输出流分为字符流和字节流。<strong>字节流继承inputStream和OutputStream,字符流继承自Reader和Writer。</strong>在java.io包中还有许多其他的流，主要是为了提高性能和使用方便<br>Java为字节流和字符流提供了转换适配器：InputStreamReader，OutputStreamWriter</p>
<h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><p>Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能<br>使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量<br>除了在持久化对象时会用到对象序列化之外，当使用RPC(包括Java标准RMI远程方法调用)，或在网络中传递对象时，都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制</p>
<p>在Java中，<strong>只要一个类实现了java.io.Serializable接口，那么它就可以被序列化</strong><br>java.io.Serializable是一个标识接口，<strong>即意味着它仅仅是为了说明类的可序列化属性，接口没有包含任何需要子类实现的抽象方法</strong></p>
<h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><p><strong>将对象的状态信息保存到流中的操作，称为序列化</strong>，可以使用Java提供的工具ObjectOutputStream. writeObject(Serializable obj)来完成<br><strong>从流中读取对心状态信息的操作称为反序列化</strong>，可以使用Java提供的工具ObjectInputStream.readObject()来完成<br><img src="/2020/03/22/java2/image319.png" alt><br><img src="/2020/03/22/java2/image320.png" alt></p>
<p>上例是一个简单的序列化程序，它先将一个Person对象保存到缓存中，然后再从该缓存中读出被存储的Person对象，并打印该对象<br>从上例的运行结果可以看出的要点：<br>对于Serializable反序列化后的对象，不需要调用构造方法重新构造，对象完全以它存储的二进制位作为基础来构造，而不调用构造方法<br>对象序列化过程不仅仅保存单个对象，还能追踪对象内所包含的所有引用，并保存那些对象（这些对象也需实现了Serializable接口）<br>序列前的对象与序列化后的对象是深复制，反序列化还原后的对象地址与原来的的地址不同，但是内容是一样的，而且对象中包含的引用也相同。换句话说，通过序列化操作，我们可以实现对任何可Serializable对象的”深度复制“，这意味着复制的是整个对象网，而不仅仅是基本对象及其引用。对于同一流的对象，他们的地址是相同，说明他们是同一个对象，但是与其他流的对象地址却不相同。也就说，只要将对象序列化到单一流中，就可以恢复出与我们写出时一样的对象网，而且只要在同一流中，对象都是同一个<br>上面提到，如果仅仅只是让某个类实现Serializable接口，而没有其它任何处理的话，则就是使用默认序列化机制。</p>
<h2 id="忽略序列化属性"><a href="#忽略序列化属性" class="headerlink" title="忽略序列化属性"></a>忽略序列化属性</h2><p>使用默认机制，在序列化对象时，不仅会序列化当前对象本身，还会对该对象引用的其它对象也进行序列化，同样地，这些其它对象引用的另外对象也将被序列化，以此类推。所以，如果一个对象包含的成员变量是容器类对象，而这些容器所含有的元素也是容器类对象，那么这个序列化的过程就会较复杂，开销也较大<br>在现实应用中，有些时候不能使用默认序列化机制。比如，希望在序列化过程中忽略掉敏感数据，或者简化序列化过程<br><strong>当某个字段被声明为transient后，默认序列化机制就会忽略该字段</strong><br>课堂案例：<br><img src="/2020/03/22/java2/image321.png" alt><br>对于上述已被声明为transient的字段weight，除了将transient关键字去掉之外，是否还有其它方法能使它再次可被序列化？方法之一就是在Person类中添加两个方法：writeObject()与readObject()<br><img src="/2020/03/22/java2/image322.png" alt><br><img src="/2020/03/22/java2/image323.png" alt><br><img src="/2020/03/22/java2/image324.png" alt></p>
<p>注意：刚辞说的是<strong>添加方法而不是“覆盖”或者“实现”</strong>，因为这两个方法不是基类Object也不是接口Serializable中的方法）<br><strong>一旦对象被序列化或者反序列还原，就会自动地分别调用者两个方法</strong>。也就是说，只要我们提供了这两个方法，就会使用它们而不是默认的序列化机制<br>这个两个方法必须在类内部自己实现。大家应该注意到这两个方法其实是private类型。也就是说这两个方法仅能被这个类的其他成员调用，但其实我们没有在这个类的其他的方法中调用这两个方法。那么到底是谁调用这两个方法呢？是ObjectOutputStream和ObjectInputStream对象的writeObject和readObject()方法分别调用者两个方法（通过过反射机制来访问类的私有方法），在调用ObjectOutputStream.writeObject()时，会检查所传递的Serializable对象，<strong>利用反射来搜索是否有writeObject()方法。如果有，就会跳过正常的序列化过程，转而调用这个它的writeObject()方法，readObject方法处理方式也一样</strong><br>writeObject()内部可以通过ObjectOutputStream.defaultWriteObject()来执行默认的writeObject()（非transient字段由这个方法保存），同样的，在类readObject内部，可以通过ObjectInputStream.defalutReadObject()来执行默认的readObject()方法<br><img src="/2020/03/22/java2/image325.png" alt></p>
<p>如果我们不显式提供serialVersionUID的值，则Java会根据以下几个属性进行自动计算：<br>类的名字<br>属性字段的名字<br>方法的名字<br>已实现的接口<br><strong>改动上述任意一项内容（无论是增加或删除），都会引起编码值变化，从而引起类似的异常警报。</strong>这个数字序列称为<strong>“串行化版本统一标识符”（serial version universal identifier）</strong>，简称UID。解决这个问题的办法是在类里面新增一个域serialVersionUID，强制类仍旧使用原来的UID</p>
<h2 id="Externalizable"><a href="#Externalizable" class="headerlink" title="Externalizable"></a>Externalizable</h2><p>无论是使用transient关键字，还是使用writeObject()和readObject()方法，其实都是基于Serializable接口的序列化<br>JDK中还提供了另一个序列化接口：Externalizable，使用该接口之后，之前基于Serializable接口的序列化机制就将失效，对象将按照我们自定义的方式进行序列化或反序列化，这对于一些信息敏感应用或对序列化反序列化性能要求较高来说非常重要<br>Externalizable继承于Serializable，当使用该接口时，序列化的细节需要由我们自己完成<br>另外，使用Externalizable进行序列化时，当读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。由于这个原因，实现Externalizable接口的类必须要提供一个无参的构造器，且它的访问权限为public<br><img src="/2020/03/22/java2/image326.png" alt><br><img src="/2020/03/22/java2/image327.png" alt></p>
<h2 id="Java中对象序列化的一般方法是什么？"><a href="#Java中对象序列化的一般方法是什么？" class="headerlink" title="Java中对象序列化的一般方法是什么？"></a>Java中对象序列化的一般方法是什么？</h2><p>在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化，将对象的状态信息保存到流中的操作，称为序列化，可以使用Java提供的工具ObjectOutputStream. writeObject(Serializable obj)来完成，从流中读取对心状态信息的操作称为反序列化，可以使用Java提供的工具ObjectInputStream.readObject()来完成<br>NIO<br>知识点1：nio与io的区别<br>知识点2： Buffer<br>知识点3： Channel<br>知识点4：事件及nio的非阻塞读取<br>NIO和IO之间最大的区别是：IO是面向流的，NIO是面向块（缓冲区）的<br> Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性</p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Java NIO中的Buffer用于和NIO通道进行交互。数据是从通道读入缓冲区，从缓冲区写入到通道中的<br>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Java NIO的通道类似流，但又有些不同：<br>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的<br>通道可以异步地读写<br>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入<br>Java NIO的事件选择器<strong>允许一个单独的线程来监视多个输入通道</strong>，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道<br>由于有了事件选择器，因此<strong>NIO可以以非阻塞的方式读取数据</strong><br>NIO的这些特性在网络通讯方面非常有用，我们将在网络章节利用示例为大家具体介绍非阻塞的网络IO操作<br><img src="/2020/03/22/java2/image328.png" alt></p>
<p>小结<br>nio和io有什么区别？<br>Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性<br><strong>nio提供了事件选择器和非阻塞访问</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jinyeeeee.github.io/2020/03/22/java2/" data-id="ck98ac8lu000jvsv03qkq4yj3"
         class="article-share-link">分享</a>
      
    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2020/04/06/spring-aop/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            spring_aop
          
        </div>
      </a>
    
    
      <a href="/2020/03/02/js%E8%B0%83%E4%BC%98/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">js调优</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
    </div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/technology.js"></script>

  </div>
</body>
</html>