<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    java |
    
    yuchen</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/technology.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <section class="outer">
  <article id="post-java" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java
    </h1>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2020/03/02/java/" class="article-date">
  <time datetime="2020-03-02T00:41:54.000Z" itemprop="datePublished">2020-03-02</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h1 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h1><h2 id="Java历史"><a href="#Java历史" class="headerlink" title="Java历史"></a>Java历史</h2><ul>
<li><strong>1991年</strong>，<strong>SUN</strong>MicroSystem公司的<strong>JameGosling</strong>、BillJoe等人为在电视、控制烤箱等家用消费类电子产品上进行交互式操作而开发了一个名为Oak的软件。</li>
<li>Oak—&gt;Java：互联网给Java带来新的生机</li>
<li><strong>1995年Sun向公众推出Java</strong>并引起业界的轰动。</li>
<li>发展：面向网络应用，类库不断丰富，性能不断提高，应用领域不断拓展。（1995年以来）</li>
<li><strong>2009年Oracle公司宣布正式以74亿美元的价格收购Sun公司</strong>，Java商标从此正式归Oracle所有； </li>
<li>Java不仅仅是一门编程语言，<strong>同时也是一个技术平台</strong>；</li>
<li>Java是当今最流行的软件开发语言之一，企业版本使Java具有更广泛的用途，适用于各种应用开发，尤其是<strong>网络应用，网络服务，嵌入式系统</strong>等。<h2 id="Java版本"><a href="#Java版本" class="headerlink" title="Java版本"></a>Java版本</h2></li>
</ul>
<p><strong>里程碑版本，被称为Java2平台</strong>。开始拆分为<strong>JavaSE、JavaEE、JavaME</strong>三个技术方向。</p>
<ul>
<li><strong>JavaSE</strong>：java基础阶段–标准版本</li>
<li><strong>JavaME</strong>：移动应用（不怎么使用） 安卓、苹果系统</li>
<li><strong>JavaEE</strong>：企业级应用<h2 id="Java优点"><a href="#Java优点" class="headerlink" title="Java优点"></a>Java优点</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a><strong>面向对象</strong></h3></li>
<li>Java是一门面向对象的语言；面向对象（Object Oriented）简称OO；</li>
<li>面向对象与面向过程是两种有代表性的编程思想；</li>
<li>面向对象思想有三大特征：封装、继承、多态<h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a><strong>健壮性</strong></h3><blockquote>
<p>健壮性又称鲁棒性（robustness）；</p>
</blockquote>
</li>
<li>Java的强类型机制保证任何数据必须有明确的数据类型；</li>
<li>Java提供异常处理机制，能够统一处理异常事件；</li>
<li>Java不再使用指针，实现垃圾自动回收，程序员不需要手动回收内存；<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a><strong>分布式</strong></h3></li>
<li>提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、 ServerSocket等；</li>
<li>Java的RMI(远程方法调用)机制是开发分布式应用的重要手段；<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a><strong>多线程</strong></h3></li>
<li>Java语言支持多线程编程；</li>
<li>提供多线程机制允许程序中有多个任务并发执行；</li>
<li>提供的同步机制允许共享数据；</li>
</ul>
<h3 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a><strong>动态性</strong></h3><ul>
<li>允许程序动态地装人运行过程中所需要的类；也可以通过网络来载入所需要的类；</li>
<li>Java中能进行运行时的类型检查<h2 id="java环境和开发工具搭建"><a href="#java环境和开发工具搭建" class="headerlink" title="java环境和开发工具搭建"></a>java环境和开发工具搭建</h2><h3 id="JDK下载"><a href="#JDK下载" class="headerlink" title="JDK下载"></a>JDK下载</h3>登录官网：<a href="https://www.oracle.com/cn/java/technologies/javase-jdk8-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/cn/java/technologies/javase-jdk8-downloads.html</a><h3 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h3>1、在d盘创建一个文件夹管理安装软件 dev<br>2、在dev里面创建了两个文件夹  用于存储安装的JDK以及JRE名称叫jdk、jre<br>3、点击jdk安装文件 第一次装到jdk  第二次安装到jre<br>4、其他内容都是”下一步”<h3 id="Java环境配置"><a href="#Java环境配置" class="headerlink" title="Java环境配置"></a>Java环境配置</h3>1、鼠标右键点击“此电脑” “我的电脑””我的计算机”<br>2、鼠标点击属性，然后弹出了一个窗口<br>3、找到高级系统设置点击<br>4、点击“环境变量”弹出了环境变量的窗口<br>5、下面窗口添加系统变量<br>6、点击“新建”变量名：<strong>CLASSPATH</strong> 变量值：  .<br>7、找到系统变量”path” 双击<br>8、Win7:“c:\programxxxx\xxx” 在原有的变量值基础上添加一个;(英文分号)与前面分开,添加jdk安装目录下的bin路径”D:\dev\jdk\bin”<br>9、Win10点开path,弹出一个窗口,点击新建,将jdk安装目录下的bin路径”D:\dev\jdk\bin”添加进去就可以了。<h3 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h3><blockquote>
<p>***注意1、安装软件不要有中文目录.2、Path 配置也不要有中文符号“;”千千万万不能中文<br>1、Win按键+R：打开运行<br>2、输入cmd 回车打开黑窗口<br>3、输入 java -version :查看java版本<br>4、输入javac 查看path是否配置成功<br>(1)弹出提示表示成功<br>(2)如果出现”javac不是内部指令”表示配置失败</p>
</blockquote>
<h3 id="开发工具介绍"><a href="#开发工具介绍" class="headerlink" title="开发工具介绍"></a>开发工具介绍</h3><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4></li>
</ul>
<p><strong>JDK</strong>是<strong>Java开发工具包（Java  Development Kit）</strong>的简称，是一个软件；<br>如果要用Java语言编写程序，就必须在计算机上安装JDK；</p>
<h4 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h4><p><strong>JRE</strong>是<strong>Java运行环境（Java  Runtime Environment）</strong>的简称<br>如果要在机器上运行Java程序，就必须要有JRE；</p>
<p>根据不同的操作系统，下载不同版本JDK软件安装即可<br>只要计算机上有JDK，就有JRE（因为做完java程序之后，测试一下，运行java程序，所以需要JRE）。如果不需要开发，只运行Java程序，也可以单独安装JRE。</p>
<p><strong>JVM（Java Virtual Machine）称为Java虚拟机</strong>，<strong>在Java平台中有着举足轻重的地位</strong>；<br>JVM可以理解为Java编译器和操作系统间的虚拟处理器；<br>编译器编译出的字节码只要JVM认识即可；<br>JVM再将字节码解释成操作系统认识的机器码；<br>只要需要运行Java程序的设备，都需要安装JVM；</p>
<p><strong>JDK=JRE+开发工具</strong><br><strong>JRE=JVM+java类库</strong></p>
<h3 id="JDK工具"><a href="#JDK工具" class="headerlink" title="JDK工具"></a>JDK工具</h3><p>JDK是开发工具包，提供了一系列的工具，都存在bin目录下，是一系列的.exe文件，可以直接在DOS窗口调用使用；<br>javac – 编译器，将源程序转成字节码；<br>java – 运行编译后的java程序（.class后缀的）；<br>jar – 打包工具，将相关的类文件打包成一个文件；<br>javadoc – 文档生成器，从源码注释中提取文档；<br>jdb – debugger，查错工具；<br>appletviewer：小程序浏览器，执行HTML文件上的Java小程序的Java浏览器；<br>javah：产生可以调用Java过程的C过程，或建立能被Java程序调用的C过程的头文件；<br>javap：Java反汇编器，显示编译类文件中的可访问功能和数据，同时显示字节代码含义；<br>jconsole: Java进行系统调试和监控的工具；</p>
<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>人说话——自然语言<br>机器——–机器语言<br>二进制系统：01100110</p>
<p>普遍编程语言转换方式<br><strong>编译</strong>：会生成一个新的文件，运行效率快                    不能跨平台<br><strong>解释</strong>：不会生成新的文件，逐行翻译，逐行运行，运行效率低     可以跨平台<br>Java运行方式：<br><strong>先编译，后解释运行</strong></p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>Java虚拟机是一个想象中的机器,在实际的计算机上通过软件模拟来实现。Java虚拟机有自己想象中的硬件,如处理器、堆栈、寄存器等,还具有相应的指令系统。不同的操作系统有不同的虚拟机。</p>
<p>Java程序的运行一般经过五个步骤：<strong>编写源代码，编译源代码，装载，校验，运行</strong>。</p>
<p>1、创建一个文件(java叫做”源文件”),以”.java”为后缀，编写代码<br>2、由编译器对源文件进行编译，生成一个新的文件以”.class”为后缀(java叫做”字节码文件”)<br>3、字节码载入器，进行装载<br>4、检查代码是否有错(字节码校验器)<br>5、解释器进行解释运行到系统操作平台上</p>
<h3 id="编写第一java程序"><a href="#编写第一java程序" class="headerlink" title="编写第一java程序"></a>编写第一java程序</h3><ol>
<li>在f盘新建一个记事本文件</li>
</ol>
<ol start="2">
<li>修改文件名称，修改成”Test.java”</li>
</ol>
<ul>
<li>修改后缀为.java</li>
<li>Win10 文件夹上方有一个查看  文件扩展名挑勾</li>
<li>Win7 “文件夹”上方 点击“组织”—-”文件夹XXX选项”  弹出菜单”查看”   滚动滚动条，下方有一个”文件夹后缀”  取消隐藏文件扩展名  不挑勾</li>
</ul>
<ol start="3">
<li>编写代码，保存代码</li>
<li>Win+R 弹出运行 输入cmd</li>
<li>打开F盘</li>
<li>利用编译器进行编译  javac+空格+文件名.后缀  回车  生成.class文件</li>
<li>解释运行字节码文件   java +空格+字节码文件的名称(类名，不包含后缀名)   回车</li>
<li>生成结果<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong><strong>注意事项</strong></strong></h4></li>
</ol>
<ul>
<li><p>类前面常常使用public修饰，成为公共类，具体含义暂时不用理解，后续将学习；然而，用public修饰的类所在源文件命名就有要求：.java文件的名字必须与源文件中的class名字完全一致，大小写也需要一致；Test.java:1: 错误: 类Hello是公共的, 应在名为 Hello.java 的文件中声明</p>
</li>
<li><p>在一个.java文件中可以有多个Java类；最多只能有一个public类；也可以没有public类；实际编程中，尽量不要在一个文件中存在多个类，可读性比较差；</p>
</li>
<li><p>main方法是Java类运行的入口；也就是说，一个Java类如果没有main方法，就不能运行；没有main报错如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误: 在类 One 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   public static void main(String[] args)</span><br><span class="line">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span><br></pre></td></tr></table></figure>
<p>main方法的声明如下所示：<br>public static void main(String[] args)  {</p>
<p>}</p>
</li>
</ul>
<p><strong>其中public  static void main 都不能修改，参数类型也必须是String[]<br>方法格式如下：<br>访问修饰符+返回值类型+方法名称+(参数列表)+抛出的异常{<br>代码块—方法体</strong><br>}<br>参数名称args可以修改;</p>
<h3 id="CLASSPATH：为什么要去配置"><a href="#CLASSPATH：为什么要去配置" class="headerlink" title="CLASSPATH：为什么要去配置 ."></a>CLASSPATH：为什么要去配置 .</h3><p>Java +类名运行java代码的时候，JVM去哪里找字节码文件(即.class文件)<br>查看当前classpath（类的路径是哪里）:set classpath<br>.：表示的是当前目录<br>如果classpath配置出现问题，就会出现一下错误：<br>错误: 找不到或无法加载主类 Hello</p>
<h3 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h3><ol>
<li><p>安装<br>(1)直接解压就可以使用<br>(2)安装版，可能需要选择版本 next 选择目录 一直next就可以</p>
</li>
<li><p>如果打开之后出现以下问题：表示jdk版本与eclipse版本是不匹配<br>(1)Jdk 64位<br>(2)Eclipse是32位<br><img src="/2020/03/02/java/eclipse01.png" alt="error"><br>(3)</p>
</li>
<li><p>设置eclipse 的编码方式，以后创建项目都是同一个编码方式<br>(1)找到Window选项卡—-Preferences首选项<br>(2)搜索encoding<br>(3)找到workspace<br>(4)左下角 编码  改成other ：UTF-8</p>
</li>
<li><p>打开eclipse 的时候会有一个操作<br><img src="/2020/03/02/java/eclipse02.png" alt="workspace"><br>(1)选择工作空间，今后创建项目的位置<br>(2)再f盘 创建了一个javaseworkspace作为今后javase阶段代码存储的目录（工作空间）<br>(3)让eclipse workspace指向当前的文件夹就可以了<br>(4)是否一直以当前的目录作为工作空间打开，挑勾</p>
</li>
<li><p>创建项目<br>(1)File–new–project（java project 直接点击就行）—java project—点击nect出现以下界面<br>(2)<br>(3)创建项目名称   sutdent manager score    sms     不要纯数字和中文名称<br>(4)点击next<br>(5)点击完成</p>
</li>
<li><p>创建类<br>(1)鼠标右键点击src  —–new——class<br>(2)类名，首字母要大写<br>(3)点击完成</p>
</li>
<li><p>调整文字大小<br>(1)找到Window选项卡—-Preferences首选项<br>(2)搜索font<br>(3)找到colors and fonts<br>(4)找到Basic 点开<br>(5)选择展开后的 Text font 鼠标点击打开<br>(6)选择字号 点击完成</p>
</li>
<li><p>提示键Alt+？(/)</p>
</li>
<li><p>主函数  输入main 点击Alt+/</p>
</li>
<li><p>打印语句 syso 点击 Alt+/</p>
</li>
<li><p>运行<br>(1)鼠标在当前代码点击鼠标右键<br>(2)Run As<br>(3)Java Appliction<br>(4)也可以点击下图标</p>
</li>
<li><p>如果在eclipse中出现错误代码，一般在代码左边都会有一个红色的小叉，鼠标移到小叉上面，点击F2这个按键，弹出提示信息</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量：程序中的基本存储单元，其定义包括变量名、变量类型和作用域几个部分存储数据的容器.计算机中的数据 ：二进制数</p>
<h3 id="为什么进行数据类型划分"><a href="#为什么进行数据类型划分" class="headerlink" title="为什么进行数据类型划分"></a>为什么进行数据类型划分</h3></li>
</ol>
<p><strong>不同的变量有不同的用途</strong>，例如，可以用变量来表示年龄，或者用变量来表示成绩。而年龄只能是整数，而成绩却可能出现小数；<br><strong>如果不把数据划分为不同的类型，那么就没有办法区分出数据之间的差别</strong>;<br>计算机可以根据不同的数据类型，把数据“合理”地存放到内存中；<br>计算机从内存中读取数据时，也可以根据其数据类型就能确认取到的数据的特征，从而正确地去处理;</p>
<h3 id="数据类型树"><a href="#数据类型树" class="headerlink" title="数据类型树"></a>数据类型树</h3><p>Java语言是强类型语言，任何一个变量或常量在Java中必须有确定的数据类型；<br>Java语言的数据类型有两种，即<strong>基本数据类型</strong>和<strong>引用类型</strong><br><img src="/2020/03/02/java/eclipse03.png" alt="数据类型树"></p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Java语言中的基本数据类型可以分为数值型、字符型、布尔型三大类，具体包含8个类型；<br><img src="/2020/03/02/java/5.png" alt="基本数据类型"></p>
<ul>
<li>byte：字节型</li>
<li>short：短整型</li>
<li>int:整型</li>
<li>long：长整型</li>
<li>float:单精度浮点型</li>
<li>double:双精度浮点型</li>
<li>char：字符型</li>
<li>boolean：布尔型true false<br>每种数据类型在内存中占有不同的长度；<br>计算机存储设备的<strong>最小信息单元叫“位（bit）”</strong>，又称之为“比特位”；</li>
</ul>
<p><strong>连续的8个位成为1个“字节（byte）</strong>”；<br>操作系统分配内存最少1个字节，即8 个位，而不是1个位；<br>长度越长，所表示的范围就越大；<br><img src="/2020/03/02/java/6.png" alt></p>
<h3 id="基本数据类型默认值"><a href="#基本数据类型默认值" class="headerlink" title="基本数据类型默认值"></a>基本数据类型默认值</h3><p>每种具体类型都有不同的默认值；<br>当没有为一个属性变量赋值时，会根据类型为其赋值为默认值；<br>注意：char的默认值是<strong>\u0000</strong>，等同于一个空字符；boolean的默认值是<strong>false</strong><br><img src="/2020/03/02/java/7.png" alt></p>
<h3 id="内存简单介绍"><a href="#内存简单介绍" class="headerlink" title="内存简单介绍"></a>内存简单介绍</h3><p><strong>数据都是存放在内存中</strong>，了解Java内存的基本结构有助于深入理解数据类型；<br>Java内存大体可以分为<strong>堆、栈、常量池、方法区</strong><br><img src="/2020/03/02/java/4.png" alt><br>先“粗略”了解基本区别：<strong>基本数据类型存储在栈中；引用类型存储在堆中；</strong><br>以上的“基本区别”可以稍加细化：<br><strong>在函数（方法）中定义的基本数据类型变量存储在栈中；<br>引用类型实例的引用（reference）也是存储在栈中；<br>引用类型实例的成员变量，存储在堆中；</strong></p>
<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>用“=”可以为任何一种基本数据类型的变量赋值；<br><strong>赋值时主要不要超过表示范围</strong>，否则将出现编译错误参考基本数据类型范围</p>
<p><strong>char类型</strong>使用’’引用单个字符赋值；<strong>也可以使用非负整数进行赋值</strong>；</p>
<h3 id="数据之间的转换"><a href="#数据之间的转换" class="headerlink" title="数据之间的转换"></a>数据之间的转换</h3><p>不同的基本数据类型之间可以进行转换；</p>
<p><strong>从表示范围小</strong>的类型转换为<strong>表示范围大</strong>的类型，可以<strong>直接转换</strong>，称为<strong>隐式转换</strong>；</p>
<p><strong>从表示范围大</strong>的类型转换为<strong>表示范围小</strong>的类型，需要<strong>强制转换</strong>，称为<strong>显式转换</strong>；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i=20;</span><br><span class="line">byte b=(byte)i;</span><br></pre></td></tr></table></figure>

<p>虽然类型之间可以进行强制的隐式转换，但是也需要有一定的前提；</p>
<p><strong>数值类型和boolean类型之间就不能转换；强制也不可以</strong>；<br><strong>小数默认是double类型</strong>；</p>
<p>使用f/F后缀显式表示float类型；使用d/D后缀显式使用double类型；<br>float f=20.5F;<br>double d=20.5d;<br>boolean型的只有true和false两个值</p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul>
<li>==：是否相等</li>
<li>！=：是否不等于</li>
<li><blockquote>
<p>：大于</p>
</blockquote>
</li>
<li>&lt;：小于</li>
<li><blockquote>
<p>=：大于等于</p>
</blockquote>
</li>
<li>&lt;=：小于等于<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Java 转换成二进制进行计算</span><br><span class="line"></span><br><span class="line">double d1=1.0d;</span><br><span class="line">float d2=1.0f;</span><br><span class="line">System.out.println(&quot;d1==d2 &quot;+(d1==d2));</span><br><span class="line">System.out.println(&quot;d1!=d2 &quot;+(d1!=d2));</span><br><span class="line">System.out.println(&quot;d1&gt;d2 &quot;+(d1&gt;d2));</span><br><span class="line">System.out.println(&quot;d1&lt;d2 &quot;+(d1&lt;d2));</span><br><span class="line"></span><br><span class="line">tfff</span><br><span class="line"></span><br><span class="line">double d3=0.3d;</span><br><span class="line">float d4=0.3f;</span><br><span class="line">System.out.println(&quot;d3==d4 &quot;+(d3==d4));</span><br><span class="line">System.out.println(&quot;d3!=d4 &quot;+(d3!=d4));</span><br><span class="line">System.out.println(&quot;d3&gt;d4 &quot;+(d3&gt;d4));</span><br><span class="line">System.out.println(&quot;d3&lt;d4 &quot;+(d3&lt;d4));</span><br><span class="line"></span><br><span class="line">ftft</span><br></pre></td></tr></table></figure>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3></li>
</ul>
<ol>
<li>单行注释    //注释内容</li>
<li>多行注释  /* 注释内容    */</li>
<li>文档注释    /**    文档注释内容        */<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3>在Java语言中,除了8种基本数据类型,其他类型都是引用类型；<br><img src="/2020/03/02/java/8.png" alt><br>引用类型使用=赋值；<br>除了String、包装器类（共8个）外，都需要使用new 关键字；</li>
</ol>
<p><strong>引用类型可以使用==、！=进行比较，比较的是引用类型的地址，不是内容</strong>;引用类型不能使用&gt;、&gt;=、&lt;=、&lt;进行比较；<br>当只声明了一个引用类型变量，却没有为其赋值，则此时该变量为null；引用类型的默认值是null 表示空 什么都没有指向</p>
<h5 id="一个字符串是null，与一个字符串是””是否一样，有什么区别？"><a href="#一个字符串是null，与一个字符串是””是否一样，有什么区别？" class="headerlink" title="一个字符串是null，与一个字符串是””是否一样，有什么区别？"></a>一个字符串是null，与一个字符串是””是否一样，有什么区别？</h5><p>完全不同。Null指的是根本没有分配堆内存，””是分配了堆内存，存储了一个””字符串，不过这个字符串是空的。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>在JDK1.5之后，Java中多了一个新的类型-枚举；枚举也是一种引用类型<br><img src="/2020/03/02/java/9.png" alt><br>枚举编译后也生成.class文件，也是一种引用类型</p>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>在JDK1.5之后，Java中增加了注解（Annotation）；<br>注解也称为元数据，是和类、接口、枚举，并列的一种引用类型；<br><img src="/2020/03/02/java/10.png" alt><br>除了直接使用API中的注解外，还可以自定义注解类型；</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算符用来对操作数进行数学运算；+比较特殊，除了能做加运算外，还能对两个字符串进行连接；<br><img src="/2020/03/02/java/11.png" alt></p>
<p><strong>a++与++a的意思都是让a自增一个;a–与–a的意思都是让a自减一个</strong><br>a++与++a的区别是,a++先参与其他运算,再进行自加运算,可以把a++作为一个整体来看;++a的值和a的值是相同的</p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p><img src="/2020/03/02/java/12.png" alt></p>
<p>==以及！=也可以对引用类型进行运算，比较是否是同一个对象；</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p><img src="/2020/03/02/java/13.png" alt><br>1：真  0：假</p>
<p>&amp;：1111与0110 —-》0110 全真为真 有一个假结果就是假</p>
<p>|：1111与0110 —-》1111      全假为假，只要有一个真 结果就是真</p>
<p>异或-^：1111与0110 —-》1001两个操作数不同返回true，两个操作数相同返回false；</p>
<p>~求反：0110—-》   高位为1 表示是一个负数 转化成32位 原码+1 高位进行补位  </p>
<p>非-！：true变false，false变true</p>
<p>&lt;&lt;:   2&lt;&lt;2    0010—-&gt;数向左移动两位  1000     8    2&lt;&lt;3  0001 0000  16</p>
<p>右移位&gt;&gt;:   8&gt;&gt;2    1000—-》0010        2       </p>
<p>无符号右移位&gt;&gt;&gt;:  -8&gt;&gt;&gt;2  正数与&gt;&gt;一样    </p>
<p>负数：0010 0000 00 0000000000000000  0000 10<br>面试题：<br>1、如何快速的求2*8  2&lt;&lt;3<br>2、Int a=9 ;int b=6;如何不使用第三个变量，让这两个数进行交换<br>(1)a=a+b;  b=a-b; a=a-b;<br>(2)a=a^b; b=a^b;  a=a^b;  二进制运算 优于  直接+-</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><img src="/2020/03/02/java/14.png" alt></p>
<p><strong>上图有误</strong> 异或-^：两个操作数不同返回true，两个操作数相同返回false；</p>
<h4 id="短路问题"><a href="#短路问题" class="headerlink" title="短路问题"></a>短路问题</h4><blockquote>
<p>&amp;和|称为非短路逻辑运算；&amp;&amp;和||称为短路逻辑运算；<br>&amp;&amp;（短路与）与&amp;（非短路与)</p>
</blockquote>
<p>区别:如果运算符前面的条件为真，没有区别。如果运算符前面的条件为假，&amp;&amp;(短路与)，不去判断第二个条件，直接输出结果了假。</p>
<p>||（短路或） |（非短路或</p>
<p>区别：如果运算符前面的条件为假，没有区别。如果运算符前面的条件为真，&amp;&amp;(短路与)，不去判断第二个条件，直接输出结果了真</p>
<p>如果存在T1&amp;T2，当T1为false时，返回值已经确定为false，但是依然还会运算T2表达式；所以称为非短路；</p>
<p>如果存在T1&amp;&amp;T2，当T1为false时，返回值已经确定为false，就不会运算T2表达式；所以称为短路；</p>
<p>|与||也存在类似逻辑，当第一个表达式为true时，因为已经确定了返回值肯定是true ,所以||就不再运算第二个表达式；</p>
<h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><blockquote>
<p><strong>表达式1?表达式2:表达式3</strong></p>
</blockquote>
<h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><p><img src="/2020/03/02/java/15.png" alt></p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><blockquote>
<p>表达式是由操作数和运算符按一定的语法形式组成的符号序列;一个常量或一个变量名字是最简单的表达式，其值即该常量或变量的值;表达式的值还可以用作其他运算的操作数，形成更复杂的表达式。</p>
</blockquote>
<ul>
<li>num1+num2</li>
<li>a*(b+c)+d</li>
<li>3.14    </li>
<li>x&lt;=(y+z)  </li>
<li>x&amp;&amp;y||z<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><blockquote>
<p>一个由分号（;）结尾的单一命令是一条语句（Statement），一条语句一般是一行代码，但也可以占多行代码。</p>
</blockquote>
<h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><blockquote>
<p>用大括号（{…… }）围起来的多条语句构成一个代码段（Codeblock）；同时代码段也包括大括号前的一些修饰性描述</p>
</blockquote>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3></li>
</ul>
<p><strong>程序员对程序中的各个元素加以命名时使用的命名记号称为标识符（identifier）包括：类名、变量名、常量名、方法名、…。</strong><br>Java语言中，标识符是以<strong>字母，下划线（_）,美元符($)开始</strong>的一个字符序列，<strong>后面可以跟字母，下划线，美元符，数字。</strong></p>
<ul>
<li><p>合法的标识符：<br>identifier        userName    User_Name       _sys_value  $change </p>
</li>
<li><p>非法的标识符：<br>2mail      room#        class</p>
</li>
<li><p>类名：使用驼峰命名法<br>一个单词首字母大写   Student Person Animal 多个单词每个单词首字母都大写    StudentManager    UserName</p>
</li>
<li><p>变量(方法)：<br>一个单词直接小写     account 多个单词，首个单词字母小写，其他单词字母大写 userName    </p>
</li>
<li><p>常量：一般单词字母都是大写</p>
</li>
<li><p>包名：全都是小写</p>
<h3 id="保留字-都是小写"><a href="#保留字-都是小写" class="headerlink" title="保留字(都是小写)"></a>保留字(都是小写)</h3><blockquote>
<p>具有专门的意义和用途，不能当作一般的标识符使用，这些标识符称为保留字(reserved word)：</p>
</blockquote>
</li>
</ul>
<p>abstract    break   byte    boolean  catch   case   class   char   continue  default   double   do  else   extends  false   final   float  for   finally    if   import   implements   int   interface   instanceof   long  length  native  new  null  package  private  protected  public  final  return  switch  synchronized  short  static  super  try  true  this  throw  throws  transient   void  while</p>
<h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><ul>
<li>全局变量（Global variables）：变量可以在整个类中被访问；</li>
<li>局部变量（ Local variables ）：变量只能在定义其的代码段中被访问。<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><blockquote>
<p>常量就是特殊的变量，不能修改值的变量<br>常量只能在定义时赋值</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final double PI=3.14159</span><br></pre></td></tr></table></figure>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式) &#123;//**注意(switch的条件是一个表达式,那就意味着有很多可发挥空间)**表达式结果是一个常量</span><br><span class="line">          case 常量表达式1：</span><br><span class="line">         语句1;break;</span><br><span class="line">         case常量表达式2：</span><br><span class="line">          语句2;break;</span><br><span class="line">          ......</span><br><span class="line">         case常量表达式n ：</span><br><span class="line">         语句n;break;</span><br><span class="line">        default：    </span><br><span class="line">        语句n+1;break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>switch/case中的表达式只能使用规定的基本数据类型</p>
<ul>
<li><p>JDK1.5前可以使用：<br>基本数据类型byte<br>基本数据类型short<br>基本数据类型int<br>字符型char</p>
</li>
<li><p>JDK5之后，switch表达式类型新增加支持：枚举（enum）</p>
</li>
<li><p>JDK7之后，switch表达式类型新增加支持：String</p>
</li>
<li><p>不能使用：基本数据类型float、double、long、boolean</p>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>Java语言中的有三种循环语句，分别是for、while、do while;</p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><blockquote>
<p>for(;;){}是可编译的死循环</p>
</blockquote>
</li>
</ul>
<h3 id="类访问控制符"><a href="#类访问控制符" class="headerlink" title="类访问控制符"></a>类访问控制符</h3><ul>
<li>默认的（不提供访问控制符）：仅可被同包的其他代码访问</li>
<li>public： 可以被任何代码访问<h3 id="成员的访问控制"><a href="#成员的访问控制" class="headerlink" title="成员的访问控制"></a>成员的访问控制</h3></li>
<li>private    私有的</li>
<li>default(不使用default关键字，和类的default类似，不提供修饰符即为默认权限)</li>
<li>protected        受保护的</li>
<li>public       公开的</li>
</ul>
<p><img src="/2020/03/02/java/30.png" alt></p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>Object类是Java语言中所有类的根，所有的类都直接或间接的继承了Object类；<strong>数组也继承了Object类</strong>；Object类中定义了,Object类中定义了<strong>11个方法</strong>。</p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p>Object类中的equals方法的作用，与==相同，都是比较两个对象的虚地址；</p>
<p><img src="/2020/03/02/java/31.png" alt></p>
<h4 id="Hashcode"><a href="#Hashcode" class="headerlink" title="Hashcode"></a>Hashcode</h4><p>用来返回对象的哈希码；hashCode方法主要为了配合基于哈希的集合类一起工作，例如HashSet、HashMap等</p>
<p>当两个引用的虚地址相同时，hashCode返回相同的值，否则返回不同的值；</p>
<h4 id="Finalize"><a href="#Finalize" class="headerlink" title="Finalize"></a>Finalize</h4><p>Object中包含了一个叫做finalize()的方法，提供在对象被回收时调用以释放资源，默认情况下其不执行任何动作。</p>
<p><strong>每个对象只能被GC自动调用finalize( )方法一次。</strong>如果在finalize( )方法执行时产生异（exception），则该对象仍可以被垃圾收集器收集。</p>
<p>Java语言允许程序员为任何方法添加finalize( )方法，该方法会在垃圾收集器交换回收对象之前被调用。但不要过分依赖该方法对系统资源进行回收和再利用，因为<strong>该方法调用后的执行结果是不可预知的</strong>当finalize( )方法尚未被调用时，System. runFinalization( )方法可以用来调用finalize( )方法，并实现相同的效果，对无用对象进行垃圾收集</p>
<p>如果必须要重写finalize()方法，请记住使用super.finalize()调用父类的清除方法，否则对象清理的过程可能不完整</p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>默认的：类的全名(包名+类名)+@+哈希码转换成十六进制,在打印引用类型变量的时候，默认调用toString</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>Abstract 可以修饰类也可以修饰方法</p>
<p>public  abstract  class 类名{            //抽象类</p>
<p>}</p>
<p>访问控制符  修饰符 返回值类型 方法名(){}</p>
<p>抽象方法只有方法声明，没有方法实现没有{}</p>
<p>public abstract void method()；</p>
<ol>
<li>如果某个类中包含有抽象方法，那么该类就必须定义成抽象类</li>
<li>抽象类中也可以包含有非抽象的方法甚至抽象类中可以没有抽象方法</li>
<li>抽象类不可以直接实例化</li>
<li>如果抽象类的派生子类没有实现其中的所有抽象方法，那么该派生子类仍然是抽象类，只能用于继承，而不能实例化，但可以有构造函数<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2>面向接口编程和面向对象编程并不是平级的，而是附属于面向对象思想体系，属于其一部分。</li>
</ol>
<p>面向接口编程的意思是指<strong>在面向对象的系统中所有的类或者模块之间的交互是由接口完成的</strong></p>
<p><img src="/2020/03/02/java/32.png" alt></p>
<h4 id="Java接口继承接口的原则："><a href="#Java接口继承接口的原则：" class="headerlink" title="Java接口继承接口的原则："></a>Java接口继承接口的原则：</h4><p>Java接口可以继承多个接口,接口继承接口依然使用关键字extends，不要错用成implements</p>
<p>因此，在声明接口之间的继承关系时，extends关键字后面可以是一个列表</p>
<p>Java接口继承接口的形式</p>
<p>Interface3 extends Interface0, Interface1, interface……｛</p>
<p>｝</p>
<h4 id="类实现接口"><a href="#类实现接口" class="headerlink" title="类实现接口"></a>类实现接口</h4><p>一个类可以同时继承自一个父类并实现若干接口,类实现接口的一般语法如下：</p>
<p>[修饰符] class &lt;类名&gt; [extends 父类名] [implements 接口列表]{</p>
<p>}</p>
<h4 id="接口的优点-弱耦合"><a href="#接口的优点-弱耦合" class="headerlink" title="接口的优点 弱耦合"></a>接口的优点 弱耦合</h4><p>只需要架构师先设计好接口C的功能,再由A去调用接口,B去实现接口的功能,就可以避免A等待B实现接口的时间的浪费</p>
<p><img src="/2020/03/02/java/33.png" alt></p>
<h4 id="接口的回调"><a href="#接口的回调" class="headerlink" title="接口的回调"></a>接口的回调</h4><p>以前是我们调用系统中已经定义好的类中的方法进行结果实现,有了接口之后，让系统中已经存在的类，调用我们写的功能进行实现<br><img src="/2020/03/02/java/34.png" alt></p>
<p>举个例子:Java中已经定义好的类型Arrays.调用了sort方法，这个方法是用来进行排序，那么现在我们用它进行对象student排序，但是，现在我们没有说明如何进行排序，所以报错，如果你要进行排序规则的设定，那么必须要实现Comparable比较器这个接口，遵循接口中的比较方法继续说明。</p>
<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>默认方法理论上抹杀了Java接口与抽象类的本质区别-前者是行为契约的集合，后者是接口与实现的结合体。当然,语法上两者的差别和以前一样。</p>
<p><a href="https://www.cnblogs.com/sum-41/p/10878807.html" target="_blank" rel="noopener">https://www.cnblogs.com/sum-41/p/10878807.html</a></p>
<h2 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h2><ul>
<li><p>如果将某个变量修饰为final，那么该变量就成为常量,常量在声明时必须初始化，声明之后不能对其进行二次赋值，其后任何试图对常量进行赋值的语句都将报错,成员final属性，可以用过构造方法进行初始化。</p>
</li>
<li><p>如果将某个成员方法修饰为final，则意味着该方法不能被子类覆盖，这就和抽象方法必须由子类实现的规定互相矛盾，因此，final和abstract不能同时修饰一个方法。</p>
</li>
</ul>
<ul>
<li>如果将某个类修饰为final，则说明该类无法被继承，一般语法：[访问权限] final class 类名 {成员列表}</li>
</ul>
<h2 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h2><ul>
<li><p>如果将某个变量修饰为final，那么该变量就成为常量,常量在声明时必须初始化，声明之后不能对其进行二次赋值，其后任何试图对常量进行赋值的语句都将报错,成员final属性，可以用过构造方法进行初始化。</p>
</li>
<li><p>如果将某个成员方法修饰为final，则意味着该方法不能被子类覆盖，这就和抽象方法必须由子类实现的规定互相矛盾，因此，final和abstract不能同时修饰一个方法。</p>
</li>
</ul>
<ul>
<li>如果将某个类修饰为final，则说明该类无法被继承，一般语法：[访问权限] final class 类名 {成员列表}</li>
</ul>
<p>如果将某个变量修饰为final，那么该变量就成为常量,常量在声明时必须初始化，声明之后不能对其进行二次赋值，其后任何试图对常量进行赋值的语句都将报错,成员final属性，可以用过构造方法进行初始化。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jinyeeeee.github.io/2020/03/02/java/" data-id="ck7rdt5o400012wv064zo7dei"
         class="article-share-link">分享</a>
      
    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2020/03/02/js%E8%B0%83%E4%BC%98/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            js调优
          
        </div>
      </a>
    
    
      <a href="/2020/03/01/metasploit/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">metasploit</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
    </div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/technology.js"></script>

  </div>
</body>
</html>