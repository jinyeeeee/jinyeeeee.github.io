<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    java |
    
    yuchen</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/technology.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <section class="outer">
  <article id="post-java" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java
    </h1>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2020/03/02/java/" class="article-date">
  <time datetime="2020-03-02T00:41:54.000Z" itemprop="datePublished">2020-03-02</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h1 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h1><h2 id="Java历史"><a href="#Java历史" class="headerlink" title="Java历史"></a>Java历史</h2><ul>
<li><strong>1991年</strong>，<strong>SUN</strong>MicroSystem公司的<strong>JameGosling</strong>、BillJoe等人为在电视、控制烤箱等家用消费类电子产品上进行交互式操作而开发了一个名为Oak的软件。</li>
<li>Oak—&gt;Java：互联网给Java带来新的生机</li>
<li><strong>1995年Sun向公众推出Java</strong>并引起业界的轰动。</li>
<li>发展：面向网络应用，类库不断丰富，性能不断提高，应用领域不断拓展。（1995年以来）</li>
<li><strong>2009年Oracle公司宣布正式以74亿美元的价格收购Sun公司</strong>，Java商标从此正式归Oracle所有； </li>
<li>Java不仅仅是一门编程语言，<strong>同时也是一个技术平台</strong>；</li>
<li>Java是当今最流行的软件开发语言之一，企业版本使Java具有更广泛的用途，适用于各种应用开发，尤其是<strong>网络应用，网络服务，嵌入式系统</strong>等。<h2 id="Java版本"><a href="#Java版本" class="headerlink" title="Java版本"></a>Java版本</h2></li>
</ul>
<p><strong>里程碑版本，被称为Java2平台</strong>。开始拆分为<strong>JavaSE、JavaEE、JavaME</strong>三个技术方向。</p>
<ul>
<li><strong>JavaSE</strong>：java基础阶段–标准版本</li>
<li><strong>JavaME</strong>：移动应用（不怎么使用） 安卓、苹果系统</li>
<li><strong>JavaEE</strong>：企业级应用<h2 id="Java优点"><a href="#Java优点" class="headerlink" title="Java优点"></a>Java优点</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a><strong>面向对象</strong></h3></li>
<li>Java是一门面向对象的语言；面向对象（Object Oriented）简称OO；</li>
<li>面向对象与面向过程是两种有代表性的编程思想；</li>
<li>面向对象思想有三大特征：封装、继承、多态<h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a><strong>健壮性</strong></h3><blockquote>
<p>健壮性又称鲁棒性（robustness）；</p>
</blockquote>
</li>
<li>Java的强类型机制保证任何数据必须有明确的数据类型；</li>
<li>Java提供异常处理机制，能够统一处理异常事件；</li>
<li>Java不再使用指针，实现垃圾自动回收，程序员不需要手动回收内存；<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a><strong>分布式</strong></h3></li>
<li>提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、 ServerSocket等；</li>
<li>Java的RMI(远程方法调用)机制是开发分布式应用的重要手段；<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a><strong>多线程</strong></h3></li>
<li>Java语言支持多线程编程；</li>
<li>提供多线程机制允许程序中有多个任务并发执行；</li>
<li>提供的同步机制允许共享数据；</li>
</ul>
<h3 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a><strong>动态性</strong></h3><ul>
<li>允许程序动态地装人运行过程中所需要的类；也可以通过网络来载入所需要的类；</li>
<li>Java中能进行运行时的类型检查<h2 id="java环境和开发工具搭建"><a href="#java环境和开发工具搭建" class="headerlink" title="java环境和开发工具搭建"></a>java环境和开发工具搭建</h2><h3 id="JDK下载"><a href="#JDK下载" class="headerlink" title="JDK下载"></a>JDK下载</h3>登录官网：<a href="https://www.oracle.com/cn/java/technologies/javase-jdk8-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/cn/java/technologies/javase-jdk8-downloads.html</a><h3 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h3>1、在d盘创建一个文件夹管理安装软件 dev<br>2、在dev里面创建了两个文件夹  用于存储安装的JDK以及JRE名称叫jdk、jre<br>3、点击jdk安装文件 第一次装到jdk  第二次安装到jre<br>4、其他内容都是”下一步”<h3 id="Java环境配置"><a href="#Java环境配置" class="headerlink" title="Java环境配置"></a>Java环境配置</h3>1、鼠标右键点击“此电脑” “我的电脑””我的计算机”<br>2、鼠标点击属性，然后弹出了一个窗口<br>3、找到高级系统设置点击<br>4、点击“环境变量”弹出了环境变量的窗口<br>5、下面窗口添加系统变量<br>6、点击“新建”变量名：<strong>CLASSPATH</strong> 变量值：  .<br>7、找到系统变量”path” 双击<br>8、Win7:“c:\programxxxx\xxx” 在原有的变量值基础上添加一个;(英文分号)与前面分开,添加jdk安装目录下的bin路径”D:\dev\jdk\bin”<br>9、Win10点开path,弹出一个窗口,点击新建,将jdk安装目录下的bin路径”D:\dev\jdk\bin”添加进去就可以了。<h3 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h3><blockquote>
<p>***注意1、安装软件不要有中文目录.2、Path 配置也不要有中文符号“;”千千万万不能中文<br>1、Win按键+R：打开运行<br>2、输入cmd 回车打开黑窗口<br>3、输入 java -version :查看java版本<br>4、输入javac 查看path是否配置成功<br>(1)弹出提示表示成功<br>(2)如果出现”javac不是内部指令”表示配置失败</p>
</blockquote>
<h3 id="开发工具介绍"><a href="#开发工具介绍" class="headerlink" title="开发工具介绍"></a>开发工具介绍</h3><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4></li>
</ul>
<p><strong>JDK</strong>是<strong>Java开发工具包（Java  Development Kit）</strong>的简称，是一个软件；<br>如果要用Java语言编写程序，就必须在计算机上安装JDK；</p>
<h4 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h4><p><strong>JRE</strong>是<strong>Java运行环境（Java  Runtime Environment）</strong>的简称<br>如果要在机器上运行Java程序，就必须要有JRE；</p>
<p>根据不同的操作系统，下载不同版本JDK软件安装即可<br>只要计算机上有JDK，就有JRE（因为做完java程序之后，测试一下，运行java程序，所以需要JRE）。如果不需要开发，只运行Java程序，也可以单独安装JRE。</p>
<p><strong>JVM（Java Virtual Machine）称为Java虚拟机</strong>，<strong>在Java平台中有着举足轻重的地位</strong>；<br>JVM可以理解为Java编译器和操作系统间的虚拟处理器；<br>编译器编译出的字节码只要JVM认识即可；<br>JVM再将字节码解释成操作系统认识的机器码；<br>只要需要运行Java程序的设备，都需要安装JVM；</p>
<p><strong>JDK=JRE+开发工具</strong><br><strong>JRE=JVM+java类库</strong></p>
<h3 id="JDK工具"><a href="#JDK工具" class="headerlink" title="JDK工具"></a>JDK工具</h3><p>JDK是开发工具包，提供了一系列的工具，都存在bin目录下，是一系列的.exe文件，可以直接在DOS窗口调用使用；<br>javac – 编译器，将源程序转成字节码；<br>java – 运行编译后的java程序（.class后缀的）；<br>jar – 打包工具，将相关的类文件打包成一个文件；<br>javadoc – 文档生成器，从源码注释中提取文档；<br>jdb – debugger，查错工具；<br>appletviewer：小程序浏览器，执行HTML文件上的Java小程序的Java浏览器；<br>javah：产生可以调用Java过程的C过程，或建立能被Java程序调用的C过程的头文件；<br>javap：Java反汇编器，显示编译类文件中的可访问功能和数据，同时显示字节代码含义；<br>jconsole: Java进行系统调试和监控的工具；</p>
<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>人说话——自然语言<br>机器——–机器语言<br>二进制系统：01100110</p>
<p>普遍编程语言转换方式<br><strong>编译</strong>：会生成一个新的文件，运行效率快                    不能跨平台<br><strong>解释</strong>：不会生成新的文件，逐行翻译，逐行运行，运行效率低     可以跨平台<br>Java运行方式：<br><strong>先编译，后解释运行</strong></p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>Java虚拟机是一个想象中的机器,在实际的计算机上通过软件模拟来实现。Java虚拟机有自己想象中的硬件,如处理器、堆栈、寄存器等,还具有相应的指令系统。不同的操作系统有不同的虚拟机。</p>
<p>Java程序的运行一般经过五个步骤：<strong>编写源代码，编译源代码，装载，校验，运行</strong>。</p>
<p>1、创建一个文件(java叫做”源文件”),以”.java”为后缀，编写代码<br>2、由编译器对源文件进行编译，生成一个新的文件以”.class”为后缀(java叫做”字节码文件”)<br>3、字节码载入器，进行装载<br>4、检查代码是否有错(字节码校验器)<br>5、解释器进行解释运行到系统操作平台上</p>
<h3 id="编写第一java程序"><a href="#编写第一java程序" class="headerlink" title="编写第一java程序"></a>编写第一java程序</h3><ol>
<li>在f盘新建一个记事本文件</li>
</ol>
<ol start="2">
<li>修改文件名称，修改成”Test.java”</li>
</ol>
<ul>
<li>修改后缀为.java</li>
<li>Win10 文件夹上方有一个查看  文件扩展名挑勾</li>
<li>Win7 “文件夹”上方 点击“组织”—-”文件夹XXX选项”  弹出菜单”查看”   滚动滚动条，下方有一个”文件夹后缀”  取消隐藏文件扩展名  不挑勾</li>
</ul>
<ol start="3">
<li>编写代码，保存代码</li>
<li>Win+R 弹出运行 输入cmd</li>
<li>打开F盘</li>
<li>利用编译器进行编译  javac+空格+文件名.后缀  回车  生成.class文件</li>
<li>解释运行字节码文件   java +空格+字节码文件的名称(类名，不包含后缀名)   回车</li>
<li>生成结果<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong><strong>注意事项</strong></strong></h4></li>
</ol>
<ul>
<li><p>类前面常常使用public修饰，成为公共类，具体含义暂时不用理解，后续将学习；然而，用public修饰的类所在源文件命名就有要求：.java文件的名字必须与源文件中的class名字完全一致，大小写也需要一致；Test.java:1: 错误: 类Hello是公共的, 应在名为 Hello.java 的文件中声明</p>
</li>
<li><p>在一个.java文件中可以有多个Java类；最多只能有一个public类；也可以没有public类；实际编程中，尽量不要在一个文件中存在多个类，可读性比较差；</p>
</li>
<li><p>main方法是Java类运行的入口；也就是说，一个Java类如果没有main方法，就不能运行；没有main报错如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误: 在类 One 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   public static void main(String[] args)</span><br><span class="line">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span><br></pre></td></tr></table></figure>
<p>main方法的声明如下所示：<br>public static void main(String[] args)  {</p>
<p>}</p>
</li>
</ul>
<p><strong>其中public  static void main 都不能修改，参数类型也必须是String[]<br>方法格式如下：<br>访问修饰符+返回值类型+方法名称+(参数列表)+抛出的异常{<br>代码块—方法体</strong><br>}<br>参数名称args可以修改;</p>
<h3 id="CLASSPATH：为什么要去配置"><a href="#CLASSPATH：为什么要去配置" class="headerlink" title="CLASSPATH：为什么要去配置 ."></a>CLASSPATH：为什么要去配置 .</h3><p>Java +类名运行java代码的时候，JVM去哪里找字节码文件(即.class文件)<br>查看当前classpath（类的路径是哪里）:set classpath<br>.：表示的是当前目录<br>如果classpath配置出现问题，就会出现一下错误：<br>错误: 找不到或无法加载主类 Hello</p>
<h3 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h3><ol>
<li><p>安装<br>(1)直接解压就可以使用<br>(2)安装版，可能需要选择版本 next 选择目录 一直next就可以</p>
</li>
<li><p>如果打开之后出现以下问题：表示jdk版本与eclipse版本是不匹配<br>(1)Jdk 64位<br>(2)Eclipse是32位<br><img src="/2020/03/02/java/eclipse01.png" alt="error"><br>(3)</p>
</li>
<li><p>设置eclipse 的编码方式，以后创建项目都是同一个编码方式<br>(1)找到Window选项卡—-Preferences首选项<br>(2)搜索encoding<br>(3)找到workspace<br>(4)左下角 编码  改成other ：UTF-8</p>
</li>
<li><p>打开eclipse 的时候会有一个操作<br><img src="/2020/03/02/java/eclipse02.png" alt="workspace"><br>(1)选择工作空间，今后创建项目的位置<br>(2)再f盘 创建了一个javaseworkspace作为今后javase阶段代码存储的目录（工作空间）<br>(3)让eclipse workspace指向当前的文件夹就可以了<br>(4)是否一直以当前的目录作为工作空间打开，挑勾</p>
</li>
<li><p>创建项目<br>(1)File–new–project（java project 直接点击就行）—java project—点击nect出现以下界面<br>(2)<br>(3)创建项目名称   sutdent manager score    sms     不要纯数字和中文名称<br>(4)点击next<br>(5)点击完成</p>
</li>
<li><p>创建类<br>(1)鼠标右键点击src  —–new——class<br>(2)类名，首字母要大写<br>(3)点击完成</p>
</li>
<li><p>调整文字大小<br>(1)找到Window选项卡—-Preferences首选项<br>(2)搜索font<br>(3)找到colors and fonts<br>(4)找到Basic 点开<br>(5)选择展开后的 Text font 鼠标点击打开<br>(6)选择字号 点击完成</p>
</li>
<li><p>提示键Alt+？(/)</p>
</li>
<li><p>主函数  输入main 点击Alt+/</p>
</li>
<li><p>打印语句 syso 点击 Alt+/</p>
</li>
<li><p>运行<br>(1)鼠标在当前代码点击鼠标右键<br>(2)Run As<br>(3)Java Appliction<br>(4)也可以点击下图标</p>
</li>
<li><p>如果在eclipse中出现错误代码，一般在代码左边都会有一个红色的小叉，鼠标移到小叉上面，点击F2这个按键，弹出提示信息</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量：程序中的基本存储单元，其定义包括变量名、变量类型和作用域几个部分存储数据的容器.计算机中的数据 ：二进制数</p>
<h3 id="为什么进行数据类型划分"><a href="#为什么进行数据类型划分" class="headerlink" title="为什么进行数据类型划分"></a>为什么进行数据类型划分</h3></li>
</ol>
<p><strong>不同的变量有不同的用途</strong>，例如，可以用变量来表示年龄，或者用变量来表示成绩。而年龄只能是整数，而成绩却可能出现小数；<br><strong>如果不把数据划分为不同的类型，那么就没有办法区分出数据之间的差别</strong>;<br>计算机可以根据不同的数据类型，把数据“合理”地存放到内存中；<br>计算机从内存中读取数据时，也可以根据其数据类型就能确认取到的数据的特征，从而正确地去处理;</p>
<h3 id="数据类型树"><a href="#数据类型树" class="headerlink" title="数据类型树"></a>数据类型树</h3><p>Java语言是强类型语言，任何一个变量或常量在Java中必须有确定的数据类型；<br>Java语言的数据类型有两种，即<strong>基本数据类型</strong>和<strong>引用类型</strong><br><img src="/2020/03/02/java/eclipse03.png" alt="数据类型树"></p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Java语言中的基本数据类型可以分为数值型、字符型、布尔型三大类，具体包含8个类型；<br><img src="/2020/03/02/java/5.png" alt="基本数据类型"></p>
<ul>
<li>byte：字节型</li>
<li>short：短整型</li>
<li>int:整型</li>
<li>long：长整型</li>
<li>float:单精度浮点型</li>
<li>double:双精度浮点型</li>
<li>char：字符型</li>
<li>boolean：布尔型true false<br>每种数据类型在内存中占有不同的长度；<br>计算机存储设备的<strong>最小信息单元叫“位（bit）”</strong>，又称之为“比特位”；</li>
</ul>
<p><strong>连续的8个位成为1个“字节（byte）</strong>”；<br>操作系统分配内存最少1个字节，即8 个位，而不是1个位；<br>长度越长，所表示的范围就越大；<br><img src="/2020/03/02/java/6.png" alt></p>
<h3 id="基本数据类型默认值"><a href="#基本数据类型默认值" class="headerlink" title="基本数据类型默认值"></a>基本数据类型默认值</h3><p>每种具体类型都有不同的默认值；<br>当没有为一个属性变量赋值时，会根据类型为其赋值为默认值；<br>注意：char的默认值是<strong>\u0000</strong>，等同于一个空字符；boolean的默认值是<strong>false</strong><br><img src="/2020/03/02/java/7.png" alt></p>
<h3 id="内存简单介绍"><a href="#内存简单介绍" class="headerlink" title="内存简单介绍"></a>内存简单介绍</h3><p><strong>数据都是存放在内存中</strong>，了解Java内存的基本结构有助于深入理解数据类型；<br>Java内存大体可以分为<strong>堆、栈、常量池、方法区</strong><br><img src="/2020/03/02/java/4.png" alt><br>先“粗略”了解基本区别：<strong>基本数据类型存储在栈中；引用类型存储在堆中；</strong><br>以上的“基本区别”可以稍加细化：<br><strong>在函数（方法）中定义的基本数据类型变量存储在栈中；<br>引用类型实例的引用（reference）也是存储在栈中；<br>引用类型实例的成员变量，存储在堆中；</strong></p>
<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>用“=”可以为任何一种基本数据类型的变量赋值；<br><strong>赋值时主要不要超过表示范围</strong>，否则将出现编译错误参考基本数据类型范围</p>
<p><strong>char类型</strong>使用’’引用单个字符赋值；<strong>也可以使用非负整数进行赋值</strong>；</p>
<h3 id="数据之间的转换"><a href="#数据之间的转换" class="headerlink" title="数据之间的转换"></a>数据之间的转换</h3><p>不同的基本数据类型之间可以进行转换；</p>
<p><strong>从表示范围小</strong>的类型转换为<strong>表示范围大</strong>的类型，可以<strong>直接转换</strong>，称为<strong>隐式转换</strong>；</p>
<p><strong>从表示范围大</strong>的类型转换为<strong>表示范围小</strong>的类型，需要<strong>强制转换</strong>，称为<strong>显式转换</strong>；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i=20;</span><br><span class="line">byte b=(byte)i;</span><br></pre></td></tr></table></figure>

<p>虽然类型之间可以进行强制的隐式转换，但是也需要有一定的前提；</p>
<p><strong>数值类型和boolean类型之间就不能转换；强制也不可以</strong>；<br><strong>小数默认是double类型</strong>；</p>
<p>使用f/F后缀显式表示float类型；使用d/D后缀显式使用double类型；<br>float f=20.5F;<br>double d=20.5d;<br>boolean型的只有true和false两个值</p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul>
<li>==：是否相等</li>
<li>！=：是否不等于</li>
<li><blockquote>
<p>：大于</p>
</blockquote>
</li>
<li>&lt;：小于</li>
<li><blockquote>
<p>=：大于等于</p>
</blockquote>
</li>
<li>&lt;=：小于等于<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Java 转换成二进制进行计算</span><br><span class="line"></span><br><span class="line">double d1=1.0d;</span><br><span class="line">float d2=1.0f;</span><br><span class="line">System.out.println(&quot;d1==d2 &quot;+(d1==d2));</span><br><span class="line">System.out.println(&quot;d1!=d2 &quot;+(d1!=d2));</span><br><span class="line">System.out.println(&quot;d1&gt;d2 &quot;+(d1&gt;d2));</span><br><span class="line">System.out.println(&quot;d1&lt;d2 &quot;+(d1&lt;d2));</span><br><span class="line"></span><br><span class="line">tfff</span><br><span class="line"></span><br><span class="line">double d3=0.3d;</span><br><span class="line">float d4=0.3f;</span><br><span class="line">System.out.println(&quot;d3==d4 &quot;+(d3==d4));</span><br><span class="line">System.out.println(&quot;d3!=d4 &quot;+(d3!=d4));</span><br><span class="line">System.out.println(&quot;d3&gt;d4 &quot;+(d3&gt;d4));</span><br><span class="line">System.out.println(&quot;d3&lt;d4 &quot;+(d3&lt;d4));</span><br><span class="line"></span><br><span class="line">ftft</span><br></pre></td></tr></table></figure>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3></li>
</ul>
<ol>
<li>单行注释    //注释内容</li>
<li>多行注释  /* 注释内容    */</li>
<li>文档注释    /**    文档注释内容        */<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3>在Java语言中,除了8种基本数据类型,其他类型都是引用类型；<br><img src="/2020/03/02/java/8.png" alt><br>引用类型使用=赋值；<br>除了String、包装器类（共8个）外，都需要使用new 关键字；</li>
</ol>
<p><strong>引用类型可以使用==、！=进行比较，比较的是引用类型的地址，不是内容</strong>;引用类型不能使用&gt;、&gt;=、&lt;=、&lt;进行比较；<br>当只声明了一个引用类型变量，却没有为其赋值，则此时该变量为null；引用类型的默认值是null 表示空 什么都没有指向</p>
<h5 id="一个字符串是null，与一个字符串是””是否一样，有什么区别？"><a href="#一个字符串是null，与一个字符串是””是否一样，有什么区别？" class="headerlink" title="一个字符串是null，与一个字符串是””是否一样，有什么区别？"></a>一个字符串是null，与一个字符串是””是否一样，有什么区别？</h5><p>完全不同。Null指的是根本没有分配堆内存，””是分配了堆内存，存储了一个””字符串，不过这个字符串是空的。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>在JDK1.5之后，Java中多了一个新的类型-枚举；枚举也是一种引用类型<br><img src="/2020/03/02/java/9.png" alt><br>枚举编译后也生成.class文件，也是一种引用类型</p>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>在JDK1.5之后，Java中增加了注解（Annotation）；<br>注解也称为元数据，是和类、接口、枚举，并列的一种引用类型；<br><img src="/2020/03/02/java/10.png" alt><br>除了直接使用API中的注解外，还可以自定义注解类型；</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算符用来对操作数进行数学运算；+比较特殊，除了能做加运算外，还能对两个字符串进行连接；<br><img src="/2020/03/02/java/11.png" alt></p>
<p><strong>a++与++a的意思都是让a自增一个;a–与–a的意思都是让a自减一个</strong><br>a++与++a的区别是,a++先参与其他运算,再进行自加运算,可以把a++作为一个整体来看;++a的值和a的值是相同的</p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p><img src="/2020/03/02/java/12.png" alt></p>
<p>==以及！=也可以对引用类型进行运算，比较是否是同一个对象；</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p><img src="/2020/03/02/java/13.png" alt><br>1：真  0：假</p>
<p>&amp;：1111与0110 —-》0110 全真为真 有一个假结果就是假</p>
<p>|：1111与0110 —-》1111      全假为假，只要有一个真 结果就是真</p>
<p>异或-^：1111与0110 —-》1001两个操作数不同返回true，两个操作数相同返回false；</p>
<p>~求反：0110—-》   高位为1 表示是一个负数 转化成32位 原码+1 高位进行补位  </p>
<p>非-！：true变false，false变true</p>
<p>&lt;&lt;:   2&lt;&lt;2    0010—-&gt;数向左移动两位  1000     8    2&lt;&lt;3  0001 0000  16</p>
<p>右移位&gt;&gt;:   8&gt;&gt;2    1000—-》0010        2       </p>
<p>无符号右移位&gt;&gt;&gt;:  -8&gt;&gt;&gt;2  正数与&gt;&gt;一样    </p>
<p>负数：0010 0000 00 0000000000000000  0000 10<br>面试题：<br>1、如何快速的求2*8  2&lt;&lt;3<br>2、Int a=9 ;int b=6;如何不使用第三个变量，让这两个数进行交换<br>(1)a=a+b;  b=a-b; a=a-b;<br>(2)a=a^b; b=a^b;  a=a^b;  二进制运算 优于  直接+-</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><img src="/2020/03/02/java/14.png" alt></p>
<p><strong>上图有误</strong> 异或-^：两个操作数不同返回true，两个操作数相同返回false；</p>
<h4 id="短路问题"><a href="#短路问题" class="headerlink" title="短路问题"></a>短路问题</h4><blockquote>
<p>&amp;和|称为非短路逻辑运算；&amp;&amp;和||称为短路逻辑运算；<br>&amp;&amp;（短路与）与&amp;（非短路与)</p>
</blockquote>
<p>区别:如果运算符前面的条件为真，没有区别。如果运算符前面的条件为假，&amp;&amp;(短路与)，不去判断第二个条件，直接输出结果了假。</p>
<p>||（短路或） |（非短路或</p>
<p>区别：如果运算符前面的条件为假，没有区别。如果运算符前面的条件为真，&amp;&amp;(短路与)，不去判断第二个条件，直接输出结果了真</p>
<p>如果存在T1&amp;T2，当T1为false时，返回值已经确定为false，但是依然还会运算T2表达式；所以称为非短路；</p>
<p>如果存在T1&amp;&amp;T2，当T1为false时，返回值已经确定为false，就不会运算T2表达式；所以称为短路；</p>
<p>|与||也存在类似逻辑，当第一个表达式为true时，因为已经确定了返回值肯定是true ,所以||就不再运算第二个表达式；</p>
<h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><blockquote>
<p><strong>表达式1?表达式2:表达式3</strong></p>
</blockquote>
<h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><p><img src="/2020/03/02/java/15.png" alt></p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><blockquote>
<p>表达式是由操作数和运算符按一定的语法形式组成的符号序列;一个常量或一个变量名字是最简单的表达式，其值即该常量或变量的值;表达式的值还可以用作其他运算的操作数，形成更复杂的表达式。</p>
</blockquote>
<ul>
<li>num1+num2</li>
<li>a*(b+c)+d</li>
<li>3.14    </li>
<li>x&lt;=(y+z)  </li>
<li>x&amp;&amp;y||z<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><blockquote>
<p>一个由分号（;）结尾的单一命令是一条语句（Statement），一条语句一般是一行代码，但也可以占多行代码。</p>
</blockquote>
<h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><blockquote>
<p>用大括号（{…… }）围起来的多条语句构成一个代码段（Codeblock）；同时代码段也包括大括号前的一些修饰性描述</p>
</blockquote>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3></li>
</ul>
<p><strong>程序员对程序中的各个元素加以命名时使用的命名记号称为标识符（identifier）包括：类名、变量名、常量名、方法名、…。</strong><br>Java语言中，标识符是以<strong>字母，下划线（_）,美元符($)开始</strong>的一个字符序列，<strong>后面可以跟字母，下划线，美元符，数字。</strong></p>
<ul>
<li><p>合法的标识符：<br>identifier        userName    User_Name       _sys_value  $change </p>
</li>
<li><p>非法的标识符：<br>2mail      room#        class</p>
</li>
<li><p>类名：使用驼峰命名法<br>一个单词首字母大写   Student Person Animal 多个单词每个单词首字母都大写    StudentManager    UserName</p>
</li>
<li><p>变量(方法)：<br>一个单词直接小写     account 多个单词，首个单词字母小写，其他单词字母大写 userName    </p>
</li>
<li><p>常量：一般单词字母都是大写</p>
</li>
<li><p>包名：全都是小写</p>
<h3 id="保留字-都是小写"><a href="#保留字-都是小写" class="headerlink" title="保留字(都是小写)"></a>保留字(都是小写)</h3><blockquote>
<p>具有专门的意义和用途，不能当作一般的标识符使用，这些标识符称为保留字(reserved word)：</p>
</blockquote>
</li>
</ul>
<p>abstract    break   byte    boolean  catch   case   class   char   continue  default   double   do  else   extends  false   final   float  for   finally    if   import   implements   int   interface   instanceof   long  length  native  new  null  package  private  protected  public  final  return  switch  synchronized  short  static  super  try  true  this  throw  throws  transient   void  while</p>
<h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><ul>
<li>全局变量（Global variables）：变量可以在整个类中被访问；</li>
<li>局部变量（ Local variables ）：变量只能在定义其的代码段中被访问。<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><blockquote>
<p>常量就是特殊的变量，不能修改值的变量<br>常量只能在定义时赋值</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final double PI=3.14159</span><br></pre></td></tr></table></figure>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式) &#123;//**注意(switch的条件是一个表达式,那就意味着有很多可发挥空间)**表达式结果是一个常量</span><br><span class="line">          case 常量表达式1：</span><br><span class="line">         语句1;break;</span><br><span class="line">         case常量表达式2：</span><br><span class="line">          语句2;break;</span><br><span class="line">          ......</span><br><span class="line">         case常量表达式n ：</span><br><span class="line">         语句n;break;</span><br><span class="line">        default：    </span><br><span class="line">        语句n+1;break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>switch/case中的表达式只能使用规定的基本数据类型</p>
<ul>
<li><p>JDK1.5前可以使用：<br>基本数据类型byte<br>基本数据类型short<br>基本数据类型int<br>字符型char</p>
</li>
<li><p>JDK5之后，switch表达式类型新增加支持：枚举（enum）</p>
</li>
<li><p>JDK7之后，switch表达式类型新增加支持：String</p>
</li>
<li><p>不能使用：基本数据类型float、double、long、boolean</p>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>Java语言中的有三种循环语句，分别是for、while、do while;</p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for(;;){}是可编译的死循环</p>
</li>
</ul>
<h3 id="For与while应用场景"><a href="#For与while应用场景" class="headerlink" title="For与while应用场景"></a>For与while应用场景</h3><p>for：当我们知道循环次数的时候<br>while：当不清楚循环次数的时候</p>
<h2 id="循环关键字"><a href="#循环关键字" class="headerlink" title="循环关键字"></a>循环关键字</h2><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>在循环控制语句的循环体中，可以使用continue语句，表示不再继续循环体后面的代码，继续下一次循环；<br>我说的：在循环中遇到了continue，循环就不会继续执行当前关键字下面的其他循环内容，继续执行下一次循环（停止当前次循环，继续下一次循环）</p>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>在循环控制语句的循环体中，可以使用break语句，表示终止当前循环，跳出循环体；<br>我说的：循环终止</p>
<h3 id="多重循环跳出"><a href="#多重循环跳出" class="headerlink" title="多重循环跳出"></a>多重循环跳出</h3><p>可以在for、while、do前用合法标识符加标号；<br>用break标号;语句终止指定的循环；<br>Break+标号形式  终止指定层次的循环<br>Continue+标号形式  跳出指定层次的循环 继续下一次循环</p>
<h3 id="While与do-while区别："><a href="#While与do-while区别：" class="headerlink" title="While与do-while区别："></a>While与do-while区别：</h3><p>如果条件都为真，两者结果没有区别<br>如果条件为假，do-while 至少会执行一次循环体，while不会执行循环体<br>Do-while：先执行循环体，再去进行判断<br>While    : 先判断，再去执行循环体</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是<strong>一组类型相同的数据的集合</strong>；<br>也就是说，数组中可以存储<strong>多个数据</strong>，但是这些数据的<strong>类型必须相同</strong>；<br>数组能够作为数据的容器使用，把多个数据集中存储；<br>存储在数组中的数据，<strong>都有相应的索引值</strong>，可以方便<strong>获取或修改</strong>；<br>当需要同时保存多个类型相同的变量并进行处理时，可以考虑用数组，例如：多个人的成绩、多个员工的薪资……<br><img src="/2020/03/02/java/16.png" alt></p>
<h2 id="数组-的特性"><a href="#数组-的特性" class="headerlink" title="数组 的特性"></a>数组 的特性</h2><p>Java的数组是<strong>引用类型</strong>；<br>数组与类、接口、枚举、注解并列，是引用类型中的一种；<br><strong>Java的数组长度一经确定不能改变</strong>；<br>例如，一个数组的长度是10，那么最多能存10个数据，如果保存第11个就会出错；<br>数组在内存中是连续分配，所以读取速度快</p>
<h2 id="数组元素"><a href="#数组元素" class="headerlink" title="数组元素"></a>数组元素</h2><p><strong>数组中存储的数据称为数组的元素</strong>（Element）；<br>数组本身是引用类型，但是数组中的<strong>元素可以是基本数据类型，也可以是引用类型</strong>；<br>也就是说，即可以有存储基本数据类型int的数组，也可以有存储引用类型String的数组，但是数组本身是引用类型<br>数组中的元素<strong>有索引值，索引值从0开始</strong><br>也就是说，如果一个数组的长度是10，那么索引值就是0-9，也就是第一个元素的索引值是0，第二个的索引值是1，以此类推，通过索引值可以方便访问元素</p>
<h2 id="数组的维数"><a href="#数组的维数" class="headerlink" title="数组的维数"></a>数组的维数</h2><p>如果一个数组中存储数据结构如下所示，元素都是单个数据，称为一维数组<br>元素是一维数组，称为二维数组；</p>
<h2 id="数组的定义方式一维数组"><a href="#数组的定义方式一维数组" class="headerlink" title="数组的定义方式一维数组"></a>数组的定义方式一维数组</h2><p>数组元素类型[ ] 变量名称;<br>或<br>数组元素类型    变量名称[ ] ;</p>
<p>例如：<br>int[] a; 或  int a[];<br>String[] s; 或  String s[]；</p>
<h2 id="一维数组初始化"><a href="#一维数组初始化" class="headerlink" title="一维数组初始化"></a>一维数组初始化</h2><p><strong>第一种：数组元素类型[ ] 变量名称=new 数组元素类型[数组长度];</strong></p>
<p><strong>第二种：数组元素类型[ ] 变量名称=new 数组元素类型[]{用逗号隔开元素的具体值};</strong></p>
<p><strong>第三种：数组元素类型[ ] 变量名称= {用逗号隔开元素的具体值};</strong></p>
<h2 id="如何获取数组中的元素内容"><a href="#如何获取数组中的元素内容" class="headerlink" title="如何获取数组中的元素内容"></a>如何获取数组中的元素内容</h2><p>数组名称[索引值]</p>
<p>数组元素的默认值<br>基本数据类型：<strong>默认值与基本数据类型默认值一致</strong><br>引用数据类型：<strong>null</strong></p>
<h2 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h2><p><strong>在创建数组的时候，一定要确定数组的长度</strong>；<br>数组的长度将在初始化数组元素的时候同时初始化到内存中；<br>使用  数组变量名.length 可以返回数组的长度；</p>
<h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>很多时候我们需要对数组中的元素一个一个取出来使用，这个过程叫遍历；<br>遍历数组需要使用到循环控制，<br>循环的次数用数组的长度控制；<br>先简单理解数组遍历的循环语句，包括传统的for循环和增强for循环两种；</p>
<h2 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h2><p>for(数据类型 变量名称:数组或者集合){<br>直接使用变量名称 就是我没需要的数组或者集合中的每一个元素<br>}</p>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>二维数组的声明创建形式如下，其他多维数组的声明创建方式类似，区别就是多增加[]；<br>如果同时确定一维和二维的长度，则表示数组的元素是<strong>等长的一维数组</strong>；<br><strong>如果数组元素不是等长的一维数组，可以不指定二维长度</strong>；</p>
<p>数组元素类型[ ][ ] 变量名称=new 数组元素类型[一维长度] [二维长度]</p>
<p>二维数组：有一个一维数组，里面的每个元素都是一个以为数组</p>
<h2 id="Arrays工具"><a href="#Arrays工具" class="headerlink" title="Arrays工具"></a>Arrays工具</h2><p>Java API中有一个类 Arrays，定义了大量的sort方法，可以对数组中元素进行排序；<br>静态类Arrays<br>此静态类专门用来操作array ，提供搜索、排序、复制等静态方法。<br>//equals：比较地址  地址不一样 false  学习面向对象之后  学习<br>equals()：比较两个array是否相等。array拥有相同元素个数，且所有对应元素两两相等。<br>sort()：用来对array进行排序。<br>binarySearch()：在排好序的array中寻找元素。<br>Arrays.asList(array):将数组array转化为List   (此种方法不正规)</p>
<h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2><p>面向过程与面向对象</p>
<p>我说的：面向过程：将一个任务进行拆分，拆分成不同的步骤，自定向下逐步求精<br>面向对象：找对象，对象之间如何配合，完成功能<br>思考：去上海旅游 ，你们怎么去？<br>面向对象编程的同学：高铁、飞机        找一个事物，能够帮助我们运输过去<br>面向过程编程的同学：自驾游、走着去  天津   —-上海<br>天津—河北—山东–江苏–上海<br>一直细化 成 出门左转几米  右转<br>我说的非主流<br>对象：一切客观存在的事物都是对象    万物皆对象<br>类：<br>是对象共性的抽象<br>是创建对象的模板</p>
<p>是否见过”狗”这个事物？<br>大多数普遍说的一些：人 男人 女人 儿童 动物  狗 猫  这些 都是一个种类统称</p>
<p>问题：描述你们自己的电脑<br>对象描述<br>1、有什么                属性（数据）<br>2、能做什么                方法(功能)</p>
<h2 id="主流官方"><a href="#主流官方" class="headerlink" title="主流官方"></a>主流官方</h2><h2 id="面向对象程序设计是"><a href="#面向对象程序设计是" class="headerlink" title="面向对象程序设计是:"></a>面向对象程序设计是:</h2><p>将数据及对数据的操作封装在一起，成为一个不可分割的整体<br>同时将具有相同特征的对象抽象成一种新的数据类型—类</p>
<p>通过对象间的消息传递使整个系统运转，通过类的继承实现代码重用。</p>
<p><img src="/2020/03/02/java/17.png" alt></p>
<p>面向对象的编程思想，<strong>使设计程序编写程序的过程清晰化。有利于将程序模块化，可以组织比较大的团队开发程序，按模块进行分工</strong>。<br>所谓面向对象的方法学，就是使我们分析、设计和实现一个系统的方法。尽可能地接近我们认识一个系统的方法。包括：<br><strong>面向对象的分析（OOA, Object-Oriented Analysis)</strong><br><strong>面向对象的设计（OOD, Object-Oriented Design）</strong><br><strong>面向对象的编程Object Oriendted Programming   以。。。为向导的编程</strong></p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p><strong>面向对象中的抽象是把系统中需要处理的数据和这些数据上的操作结合在一起，根据功能、性质、作用等因素组成成不同的数据类型。</strong><br>抽象数据类型是进一步设计、<strong>编程的基础和依据</strong>。<br>在面向对象程序设计中，抽象数据类型是用“类”来代表的。</p>
<h2 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h2><p>Java具备描述对象以及对象之间关系的能力，因此是<strong>面向对象的编程语言</strong>。<br><strong>Java语言的设计集中于对象及其接口，它提供了简单的类机制以及动态的接口模型</strong>。<br>对象中<strong>封装了状态变量以及相应的方法，实现了模块化和信息隐藏</strong>；<br>类则提供了一类对象的原型，并且<strong>通过继承机制，子类可以使用父类所提供的方法，实现了代码的复用</strong>。<br>面向对象最重要的三大特征是：<strong>封装、继承、多态</strong>。</p>
<h2 id="类和对象的说明"><a href="#类和对象的说明" class="headerlink" title="类和对象的说明"></a>类和对象的说明</h2><p>如果没有事先准备好的特征描述表，那么目击者就无法准确描述出嫌疑人的特征，而没有属性值的特征描述表是无法帮助警察找到嫌疑人的，因此可以看出：<br><strong>在Java中万事万物皆对象</strong><br>事实上，Java离完全的面向对象编程语言还有最后的一小步距离，因为Java中存在基本数据类型，而后续以Java为目标的语言如C#则真正实现了万物皆对象，Java用包装类型来应对<br><strong>对象依赖于类存在（模板-个体实例)</strong><br><strong>在程序中应该使用的是对象</strong><br><strong>分析过程先有对象后有类；开发过程先有类后有对象</strong></p>
<p>在之前的编码过程中我们已经看到：用Java编写的所有代码都位于某一个类的内部<br>标准的Java库提供了几千个类，可以用于日期、日历、网络、IO等程序设计<br>我们需要在Java程序中创建一些自己的类，以便描述应用程序中所对应的问题领域中的对象</p>
<p>面向对象的一个原则会让用户自定义类变得轻而易举：可以通过扩展一个类来建立另一个新的类<br>在扩展一个已有的类时，这个扩展后的新类具有所扩展的类的全部属性和方法，在新类中只需提供适用于这个新类的新方法和数据即可，这称为继承，后续将会专门的课程详细介绍</p>
<h2 id="类的基本构成元素"><a href="#类的基本构成元素" class="headerlink" title="类的基本构成元素"></a>类的基本构成元素</h2><p>类是描述对象的“基本原型”，它定义一种对象所能拥有的数据和能完成的操作,在面向对象的程序设计中,类是程序的基本单元，<strong>最基本的类由一组结构化的数据和在其上的一组操作构成</strong>：</p>
<p>一个更完整的类结构：</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>类是同等对象的集合与抽象。它是一块创建现实对象的模板。对象是类的实例，对象是面向对象编程的核心部分，是实际存在的具体实体，具有明确定义的状态和行为<br>在程序中发挥对象的功效，需要了解对象的三个主要特征：<br>对象的行为：可以对对象施加哪些操作，或可以对对象施加哪些方法<br>对象的状态：当施加那些方法时，对象如何响应<br>对象的标识：如何辨别具有相同行为与状态的不同对象</p>
<p>同一个类的所有对像实例，由于支持相同的行为而具有家族式的相似性。对象的行为是用可调用的方法定义的。<br>此外，每个对象都保存着描述当前特征的信息-对象的状态，<strong>对象的状态可能会随着时间而发生改变，但这种改变不会是自发的</strong>。对象状态的改变必须通过调用方法实现（<strong>如果不经过方法调用就可以改变对像状态，只能说明封装性遭到了破坏</strong>）。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是与对象有关的一个重要概念<br><strong>形式：将数据和行为组合在一起，并对对象的使用者隐藏数据的实现方式</strong><br><strong>属性由变量表示，属性名称由类的每个对象共享</strong><br>每个特定的对象都有一组特定的实例属性值，这些值的集合就是这个对象的当前状态，只要向对象发送一个消息，它的状态就有可能发生改变<br><strong>封装的特性能够让服务提供者把它服务的细节隐藏掉</strong>，你只需要提交请求与传递它需要的参数，它就会给你返回结果，而这个结果是如何产生的，经过了多少复杂运算，经过多少次数据读取，你都不用管，只要它给你结果就好了。</p>
<p><strong>封装使得对代码的修改更加安全和容易，将代码分成了一个个相对独立的单元，对代码访问控制得越严格，日后你对代码修改的自由就越大</strong><br>只要电话的外部接口（键盘，屏幕，使用方法等）不发生改变，那么不管电话内部电路，技术如何改进，用户都不需要重新学习就可以使用新一代的电话。同样，只要汽车的方向盘，刹车等外部接口不变，那么，不论如何改造它的发动机，用户也一样会驾驶这类汽车<br>明确指出了哪些属性和方法是外部可以访问的。这样当需要调整这个类的代码时，只要保证公有(public:)属性不变，公有方法的参数和返回值类型不变，那么就可以尽情的修改这个类，而不会影响到程序的其他部分，或者是使用到这个类的其他程序<br><strong>能很好的使用别人的类，而不必关心其内部逻辑是如何实现的，让软件协同开发的难度大大降低</strong>。</p>
<h2 id="对象状态"><a href="#对象状态" class="headerlink" title="对象状态"></a>对象状态</h2><p>对象的状态并不能完全描述一个对象，每个对象都有一个唯一的身份。例如，在一个订单处理系统中，任何两个订单都存在着不同之处，即使所订购的货物完全相同也是如此。需要注意，作为一个类的实例，每个对象的标识永远是不同的。<br><strong>一般情况下，对象的标识可以由内存地址确定（在非序列化等情况下），可以依据次确定对象的哈希值</strong><br>状态常常也存在着差异，对象的这些关键特性在彼此之间相互影响着。</p>
<h2 id="类的声明形式"><a href="#类的声明形式" class="headerlink" title="类的声明形式"></a>类的声明形式</h2><p>【访问权限修饰符】【修饰符】 class  类名 {<br>          成员列表<br>  }<br>1、可选的类访问权限修饰符限定本类能够被哪些其他的代码访问，包括public和default（内部类有更多选择）以后将会有专门的部分详细讲解<br>2、可选的修饰符说明当前方法的特性，包括final、abstract、native等，也会有专门的课程对重要修饰符进行详细讲解<br>3、class 声明类的关键字，注意大小写<br>4、需要符合Java标识符的结构要求<br>一个约定俗成的命名规则：类名的命名规则是首字母大写，多个单词时，每个单词首字母大写<br>5、包括成员变量和成员方法<br>6、<strong>类的名字由大写字母开头而单词中的其他字母均为小写</strong>；如果类名称由多个单词组成，则<strong>每个单词的首字母均应为大写</strong>，把这些单词连接在一起，即不要使用下划线分割单词，例如:OrderList<br>7、如果类名称中包含<strong>单词缩写</strong>，则这个所写词的<strong>每个字母均应大写</strong>，如：<strong>XMLExample</strong><br>8、由于类是设计用来代表对象的，所以<strong>在命名类时应尽量选择名词</strong>。 如上例的： Bike</p>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>成员变量是类中的特有属性变量<br>在类中声明成员变量的格式<br>【变量修饰字】 变量数据类型 变量名1,变量名2【=变量初值】…;<br>成员变量的类型可以是Java中任意的数据类型，包括基本类型，类，接口，数组等<br><strong>普通的成员属性取值在该类的不同对象中不能被共享</strong></p>
<p><strong>Java中每个类型都有固定的初始值</strong>，如int的初始值是0，具体类型的初始值可以回顾学习数据类型时的内容<br>在类中定义的成员变量可以不用显示初始化为其提供取值即可使用，这时候成员变量的值为其类型的初始值<br><strong>不管在任何地方，引用类型都需要初始化后才可使用</strong>，因为引用类型的初始值为null，代表不具备存储数据的内存空间，直接使用会造成程序运行异常</p>
<h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>对象是典型的引用数据类型，因此和数组相似，初始化时需要<strong>使用new运算符</strong>从堆中分配内存，步骤是：<br>说明新建对象所属的类名<br>说明新建对象的名字<br>用new为新建对象开辟内存空间<br>创建对象的一般语法是：<br>类名 引用名 = new 类名( )  ;<br>使用已经定义好的类，<strong>创建该类对象的过程称为“实例化”</strong></p>
<p><strong>new是“为新建对象开辟内存空间”的运算符</strong>；它以类为模板，开辟空间并实例化一个对象，返回对该对象的一个引用（即该对象所在的内存地址）</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>正如之前的课程中所说，Java中，变量作用域由花括号的位置决定<br>通过new构建的Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象时，它可以存活于作用域之外。所以编写用代码：<br>{<br>String  companyName=new String(“chinasofti”);<br>}</p>
<p>引用companyName在作用域终点就消失了，然而， companyName指向的String对象仍继续占据内存空间。在这一小段代码中，无法在这个作用域之后访问这个对象，因为对它唯一的引用已超出了作用域的范围，在后继章节中，我们将会看到在程序执行过程中，怎样传递和复制对象引用。</p>
<p>思考题:由new创建的对象，只要需要，就会一直保留下去。如果Java让对象继续存在，那么靠什么才能防止这些对象填满内存空间，进而阻塞你的程序呢？</p>
<p>Java有一个垃圾回收器，用来监视用new创建的所有对象，并辨别那些不会再被引用的对象。随后，释放这些对象的内存空间，以便供其他新的对象使用。也就是说，你根本不必担心内存回收的问题。你只需要创建对象，一旦不再需要，它们就会自行消失。这样做就消除了这类编程问题（即“内存泄漏”），这是由于程序员忘记释放内存而产生的问题。<br>需要注意的是，垃圾回收其实并不能完全防止内存泄露，后续我们将会详细介绍垃圾回收机制并说明可能会导致Java内存泄露的情况</p>
<h2 id="如何访问成员"><a href="#如何访问成员" class="headerlink" title="如何访问成员"></a>如何访问成员</h2><p>java中实例化类的对象之后，就可以访问到类中的成员<br>使用成员运算符（.）来访问成员，一般语法是：对象名.成员名<br>例如：student.age=18；</p>
<h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>成员方法是类中进行数据处理，实现相关功能的函数<br>方法决定了一个对象能够接收什么样的消息。<strong>方法的基本组成部分包括：名称、参数、返回值和方法体</strong>。下面是它的基本声明形式：<br>【访问控制】【方法修饰】 返回类型  方法名称(参数1,参数2,…) {<br>       …(statements;)    //方法体：方法的内容<br>   }<br><strong>返回类型可以是任意的Java数据类型</strong>，<strong>当一个方法不需要返回值时，返回类型为void</strong>。</p>
<p>返回类型描述的是在调用方法之后计算的结果并告知调用者的值<br>参数列表给出了要传给方法的信息的类型和名称<br><strong>方法名和参数列表（它们合起来被称为“方法签名”）唯一地标识出某个方法</strong><br><strong>Java中的方法只能作为类的一部分来创建</strong><br>方法只有通过对象才能被调用（后续介绍的static方法除外），且这个对象必须能执行这个方法调用，如果试图在某个对象上调用它并不具备的方法，那么在编译时就会得到一个错误</p>
<h2 id="方法的特点："><a href="#方法的特点：" class="headerlink" title="方法的特点："></a>方法的特点：</h2><p>定义方法可以将功能代码进行封装。<br>便于该功能进行复用。<br>方法只有被调用才会被执行。<br>方法的出现提高代码的复用性。<br>方法若没有返回值，则用关键字void表示，那么该方法中的return语句如果在最后一行可以省略不写。<br>方法中可以调用方法，不可以在方法内部定义方法。<br>定义方法时，方法的结果应返回给调用者，交由调用者来处理</p>
<h2 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h2><p>1、一个参数        方法名称(数据类型 变量名)<br>2、多个参数        方法名称(数据类型 变量名1,数据类型 变量名2 ,….)</p>
<h2 id="Return"><a href="#Return" class="headerlink" title="Return"></a>Return</h2><p>方法声明中有一个重要的关键字：return<br>return的用法包括两方面：<br>代表“已经做完，离开此方法”<br>如果此方法产生了一个值，这个值要放在return语句后面<br>可以定义方法返回任意想要的类型，如果不想返回任何值，可以指示此方法返回void（空）</p>
<p>定义在方法体中的局部变量和类的成员变量之间存在一些差异：</p>
<p><img src="/2020/03/02/java/18.png" alt></p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>成员方法也使用成员运算符(.)来调用<br>同一个类中的方法在本对象中调用其他方法直接使用方法名（static方法后续探讨）</p>
<h2 id="方法的命名"><a href="#方法的命名" class="headerlink" title="方法的命名"></a>方法的命名</h2><p>方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头，例如： sendMessge<br>参数的命名规范和方法的命名规范相同，而且为了避免阅读程序时造成迷惑，应该在尽量保证参数名称为一个单词的情况下使参数的命名尽可能明确</p>
<h2 id="可变与不可变API"><a href="#可变与不可变API" class="headerlink" title="可变与不可变API"></a>可变与不可变API</h2><p>在Java中，可供调用的API从执行后的内存状态的角度可以从逻辑上划分为两种类型：<br>可变API<br>在给定的既有内存上进行操作的API<br>不可变API<br>执行时需要新分配一段内存后再执行操作的API<br>我们看到的new运算符是一个最典型的不可变API，因为其功能就是为一个新对象分配新的内存空间<br>根据可变API和不可变API的逻辑约定，可以发现，Java中的字符串不具备任何的可变API，因为针对字符串进行的任何改变都是构建了一个新的字符串对象<br>我说的:String s=”abcd”;      s+=”e”;   s”abcde”    不是在abcd的原有内容空间上进行添加的，而是创建了一个新的内存空间  存储的”abcde”</p>
<h2 id="Java传递参数的特性"><a href="#Java传递参数的特性" class="headerlink" title="Java传递参数的特性"></a>Java传递参数的特性</h2><p>Java中的参数只有<strong>值传递</strong><br>传统印象中基本数据类型和字符串传参时是值传递，其他对象传参是是引用传递的思想是错误的</p>
<p>基本数据类型:</p>
<p><img src="/2020/03/02/java/19.png" alt></p>
<p>引用类型：</p>
<p><img src="/2020/03/02/java/20.png" alt></p>
<h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><p>形参就是一个普通的临时变量，位置特殊只是为了跳出方法体的作用域以便能够获取实参值<br>从上面一条可以看出，形参绝对不是初学者所理解的占位符<br>方法体中的代码操作的是形参变量，和实参无关，只不过由于需要借助于实参的数据值，因此在执行方法第一条语句之前，隐式按照参数的位置关系利用实参对相应位置的实参进行了赋值操作</p>
<p>由此可以得出一个重要的结论：<br><strong>当方法中的形参在没有调用不可变API之前，形参的任何改变都将影响实参的状态，而当形参执行了任何不可变API之后，形参和实参之间就断开了这种状态联系</strong><br><img src="/2020/03/02/java/21.png" alt></p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>有过C语言学习经历的同学可能对其中的标准输出函数printf()非常熟悉，这个函数有个特点，提供格式字符串后，根据格式字符串中的占位符，后面可以根据占位符的个数提供不同的数据变量以供输出，这种函数的参数称为：可变参数<br>Java1.5增加了可变参数特性，适用于参数<strong>个数不确定，类型确定</strong>的情况</p>
<p><strong>Java把可变参数当做数组处理</strong><br><strong>可变参数必须位于最后一项</strong>。当可变参数个数多余一个时，必将有一个不是最后一项，所以只支持有一个可变参数。因为参数个数不定，所以当其后边还有相同类型参数时，java无法区分传入的参数属于前一个可变参数还是后边的参数，所以只能让可变参数位于最后一项<br><strong>可变参数用…代替标识</strong>， …位于变量类型和变量名之间，前后有无空格都可以<br><strong>用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组的形式访问可变参数</strong></p>
<p><img src="/2020/03/02/java/22.png" alt></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>在程序设计中,方法直接或者间接调用其自身的方法叫做递归调用，简称递归，其设计方法被应用到很多特殊问题的解决上</p>
<p>递归要点：<br><strong>每次递归调用都要使问题简单化</strong><br><strong>当递归达到某种程度后能够的到一个已知解以结束递归调用</strong><br><img src="/2020/03/02/java/23.png" alt></p>
<h2 id="DeBug运行"><a href="#DeBug运行" class="headerlink" title="DeBug运行"></a>DeBug运行</h2><p>Debug是调试的意思，在实际编程中经常用到；<br>主要作用是尽快找到程序中的错误，使得程序运行结果与预期相符；<br><strong>步骤1</strong>：设置断点。断点指的是希望程序运行到此处暂停，以便查看程序当前运行状况；我们将打印输出1，2这两条语句设为断点；鼠标双击代码左侧灰色区域即可，再次双击即取消断点；<br><strong>步骤2</strong>：启动Debug。右键单击Test.java，选择Debug as-Java  Application，跳转到Debug视图；<br><strong>步骤3</strong>：使用调试按钮工具或者通过快捷键进行调试；<br>step into（快捷键F5）进入当前行的方法内部，一步一步执行；<br>step return （快捷键F7）返回上一步执行的方法；<br>step over（快捷键F6）执行当前行，但不进入执行细节<br>resume （快捷键F8）恢复执行，表示接着执行代码，直接跳到下一个断点；<br>terminate 停止调试；</p>
<p>类的编写  不包含封装<br>1、创建一个类，名字 见名知意   名词<br>2、属性<br>3、方法</p>
<h2 id="构造方法介绍"><a href="#构造方法介绍" class="headerlink" title="构造方法介绍"></a>构造方法介绍</h2><p>这时候我们需要一种特殊的方法，它能够在<strong>创建对象的同时，完成新建对象的初始化工作</strong>，正是由于在实例化对象的同时会自动调用构造方法，所以构造方法一般用来给数据成员分配资源或初始化数据成员<br><strong>构造方法</strong>就是这种方法，它<strong>具备以下特点</strong>：<br><strong>构造方法是与类同名的方法</strong><br><strong>没返回值，也不能写void</strong><br>主要作用是<strong>完成新建对象的初始化工作</strong><br><strong>一般不能显式地直接调用，而是用new来调用</strong>（后面会存在使用this/super调用）<br>创建一个类的新对象的同时，<strong>系统自动调用该类的构造函数，为新建对象的初始化</strong></p>
<p><img src="/2020/03/02/java/24.png" alt></p>
<h2 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h2><p>由于Java要求每个类都必须要提供构造方法来构建对象，如果程序员认为编写的类无需特殊初始化操作而没有提供任何一个构造方法的话，Java会自动为该类提供一个默认的构造方法<br>Java中的默认构造方法：<br><strong>无参</strong><br><strong>空方法体，即不执行任何的初始化操作</strong><br>Animal a=new Animal();  没有定义构造方法 系统默认添加无参构造方法</p>
<h2 id="构造方法格式"><a href="#构造方法格式" class="headerlink" title="构造方法格式"></a>构造方法格式</h2><p><strong>【访问权限修饰符】类名（参数列表）{</strong><br><strong>方法体</strong><br><strong>}</strong><br><strong>对于构造方法而言，类名即方法名，切记，构造方法没有返回值，也不能写void</strong><br>对于构造方法而言，由于调用失败会导致无法构建对象，因此一般会定义为public，即所有能访问到该类的代码均能调用，当然也可以结合其他的访问控制符配合完成特殊的设计模式要求</p>
<p>对象的声明和初始化的结构准确的说应该是：<br>类名  引用变量名  =  new  类的构造函数（构造方法参数列表）;</p>
<p><strong>一旦显式地定义了构造方法，默认构造方法自动消失，即便显式定义的构造方法不是无参的：</strong></p>
<p><strong>普通的方法也能使用类名</strong>，这样会造成困扰，一定要注意</p>
<h2 id="方法的重载：（掌握怎么进行方法重载编写以及如何构成方法的重载）"><a href="#方法的重载：（掌握怎么进行方法重载编写以及如何构成方法的重载）" class="headerlink" title="方法的重载：（掌握怎么进行方法重载编写以及如何构成方法的重载）"></a>方法的重载：（掌握怎么进行方法重载编写以及如何构成方法的重载）</h2><p><strong>Java中可以允许同一个类中存在着若干个具有不同参数列表的相同名称的方法</strong><br><strong>方法名相同(参数列表不同)：数据类型不相同、数据的个数不同、数据顺序不同 **<br>**与返回值类型无关</strong><br><strong>有了方法的重载，对于对象方法的调用者，屏蔽了底层细节</strong><br>只需要知道println()是打印，但是并不清楚，本质是调用了哪个方法，打印不同数据类型，调用的方法不是一个方法，这些细节 都被方法重载屏蔽了，使用者不需要关心</p>
<p><img src="/2020/03/02/java/25.png" alt><br>如何构成方法重载案例如下<br><img src="/2020/03/02/java/26.png" alt></p>
<p>小结：<br>在同一个类中，有多个方法名称相同，但是参数列表不同的方法，方法的重载<br>参数列表不同：数据类型、参数个数、参数顺序，与返回值类型无关</p>
<h2 id="构造方法重载"><a href="#构造方法重载" class="headerlink" title="构造方法重载"></a>构造方法重载</h2><p>构造方法是一种特殊的方法，它也能重载<br>构造函数的重载是指同一个类中存在着若干个具有不同参数列表的构造函数，和普通的方法一样，将根据new运算符（后续反射中会讲授不使用new运算符的方式）后面的参数类型列表判定使用的构造方法版本</p>
<h2 id="This"><a href="#This" class="headerlink" title="This"></a>This</h2><p>java中的this就是这样一个特殊的引用，它指向了调用该方法的对象自身<br>为了容易理解，我们可以想当然的这么想象：</p>
<p><img src="/2020/03/02/java/27.png" alt></p>
<p>那么在对象a中任意地方调用a.x指代的都是对象a自己（虽然并不能这么调用，在对象内部直接使用this作为自身的引用，而在b对象中并不能使用a.this代表a对象，因为这样做本身不具备价值，后续会学到类名.this的用法）<br>我说的：以后在构造方法钟如果初始化对象进行赋值 都要用this.属性(当前对象的属性)=属性（参数）  方式</p>
<h2 id="This使用调用其他构造方法"><a href="#This使用调用其他构造方法" class="headerlink" title="This使用调用其他构造方法"></a>This使用调用其他构造方法</h2><p>对于构造方法而言，this还有一个特殊作用：那就是在构造方法中调用本类的其他构造方法<br>如果有一个类带有几个构造函数，那么也许会想复制其中一个构造函数的某方面效果到另一个构造函数中，可以通过使用关键字this作为一个方法调用来达到这个目的<br>如果出现这种情况，在任何构造方法中this调用必须是第一个语句</p>
<p><img src="/2020/03/02/java/23.png" alt></p>
<h2 id="封装-1"><a href="#封装-1" class="headerlink" title="封装"></a>封装</h2><p>把客观事物封装成抽象的类，并且<strong>类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏</strong>。在一个对象内部，某些代码或某些数据<strong>可以是私有的</strong>，不能被外界访问。通过这种方式，现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象</p>
<p><strong>需要将属性进行私有化处理 添加访问修饰符  private</strong><br>属性通过私有化之后，没有办法直接进行访问了，如果我还是想修改属性，只能调用方法</p>
<h2 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h2><p>封装把过程和数据包围起来，对数据的访问只能通过已定义的接口。面向对象编程始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。<strong>封装是一种信息隐藏技术</strong>，在java中通过控制成员的访问权限实现封装，即使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据的程度。 <strong>适当的封装可以让代码更容易理解和维护，也加强了代码的安全性</strong>。</p>
<h2 id="封装的过程"><a href="#封装的过程" class="headerlink" title="封装的过程"></a>封装的过程</h2><p>1、创建好类<br>2、将属性进行私有化处理  <strong>private 数据类型 变量名</strong><br>3、添加构造方法（多个构造方法）  <strong>无参构造方法一定要添加</strong><br>4、<strong>添加get|set方法</strong>  get（获取）:一般来说是为了获取数据  set（设置）是用来修改数据<br>5、<strong>编写自定义方法</strong></p>
<h2 id="继承（重用、扩展）"><a href="#继承（重用、扩展）" class="headerlink" title="继承（重用、扩展）"></a>继承（重用、扩展）</h2><p>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法<br><strong>一个新类可以从现有的类中派生</strong>，这个过程称为<strong>类继承</strong>，<strong>新类继承了原始类的特性</strong>，<strong>新类称为原始类的派生类（子类），而原始类称为新类的基类（父类)</strong><br>派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要</p>
<h2 id="继承意义"><a href="#继承意义" class="headerlink" title="继承意义"></a>继承意义</h2><p>在现实生活中的继承，可以理解为儿子继承了父亲的财产，即财产重用；<br><strong>面向对象程序设计中的继承，则是代码重用;</strong><br>继承是利用现有的类创建新类的过程，<strong>现有的类称作基类（或父类），创建的新类称作派生类（子类)</strong><br>复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对加以改变是不够的，它还必须能够做更多的事情。尽可能的复用代码是程序员一直在追求的，继承就是一种复用代码的方式，也是<strong>java三大特性之一</strong><br>继承是java面向对象编程技术的一块基石，因为它允许<strong>创建分等级层次的类</strong><br>继承就是<strong>子类继承父类的特征和行为</strong>，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为<br>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以<strong>增加新的数据或新的功能，也可以用父类的功能，通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率</strong></p>
<h2 id="Java类继承定义"><a href="#Java类继承定义" class="headerlink" title="Java类继承定义"></a>Java类继承定义</h2><p>在Java中，使用<strong>extends关键字</strong>描述类与类之间的继承关系，其基本用法是：<br>【访问权限修饰符】【修饰符】子类名  extends  父类名{子类体}<br>由于Java是单亲继承体系，因此在描述类与类的继承关系时，extends关键字后面只能是一个名字，而不能是一个列表（后续接口继承的情况，extends后面可以是一个列表）</p>
<h2 id="Extends继承"><a href="#Extends继承" class="headerlink" title="Extends继承"></a>Extends继承</h2><p>继承定义了类如何相互关联，共享特性。对于若干个相同或者相识的类，我们可以抽象出他们共有的行为或者属相并将其定义成一个父类或者超类，然后用这些类继承该父类，他们不仅可以拥有父类的属性、方法还可以定义自己独有的属性或者方法。<br><strong>子类拥有父类的的属性和方法（private成员由于权限关系因此不能访问</strong>）<br><strong>子类可以拥有自己属性和方法，即子类可以对父类进行扩展</strong><br><strong>子类可以用自己的方式实现父类的方法</strong><br>综上所述，使用继承确实有许多的优点，<strong>除了将所有子类的共同属性放入父类，实现代码共享，避免重复外，还可以使得修改扩展继承而来的实现比较简单</strong>。</p>
<h2 id="构造方法与继承"><a href="#构造方法与继承" class="headerlink" title="构造方法与继承"></a>构造方法与继承</h2><p>通过前面我们知道子类可以继承父类的属性和方法<br>但是有一样是<strong>子类继承不了</strong>的<strong>：构造方法</strong><br>对于构造方法而言，它只能够被调用，而不能被继承</p>
<p><strong>当构建子类对象时会优先隐式自动调用父类的无参构造方法</strong>，而且这个构建调用过程是从父类“向外”递归扩散的，也就是从父类开始向子类一级一级地完成构建，<strong>即如果C继承自B，而B继承自A，那么构建C的对象时，会先调用A的构造方法，然后调用B的构造方法，最后调用C的构造方法</strong>，以此类推</p>
<p>父类使用private修饰构造方法，子类就会报错，子类无法构建父类</p>
<p>根据上述示例，<strong>对于继承来说，子类会默认调用父类的无参构造方法</strong>，也就是说子类必须能够访问父类的一个构造方法，并且一定会调用</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>java.lang.NullPointerException:表示空指针异常，使用对象调用方法，但是对象是null</p>
<p>那么，如果父类不具备无参的构造方法怎么办呢？<br>Java 语言中，要求子类有责任保证它所继承的父类尽快进入到一个稳定、完整的状态中。如果没有这个约束，那么子类的某个继承自父类的方法可能会使用到父类中的一些变量，而这些变量并没有进行初始化，从而产生一些难以预料的后果<br><strong>如果没有无参的父类构造方法，子类必须要显示的调用父类的构造方法，而且必须是在子类构造器中做的第一件事</strong><br><strong>通过super关键字可以在子类构造方法中显式调用父类的构造方法，该调用必须位于子类构造方法的第一行</strong><br>Super调用其他的方法<br>super                                    this<br>表示父类引用                        表示当前对象引用<br>Super可以调用父类构造                调用当前对象构造方法<br>不能当成参数返回值使用 引用不能传递        当成参数或者返回值使用，可以传递<br><img src="/2020/03/02/java/28.png" alt></p>
<h2 id="继承小结"><a href="#继承小结" class="headerlink" title="继承小结"></a>继承小结</h2><p>类的继承由关键字extends确定，<strong>Java语言为单亲继承</strong>，及<strong>一个子类只能有一个父类，而一个父类可以有多个子类</strong><br>子类可以重写父类中某一个方法，称为方法覆盖，也称方法重写，是继承中非常重要的知识点。<strong>如果子类需要修改从父类继承到的方法的方法体，就可以使用方法覆盖</strong><br><strong>方法的重写</strong>                            <strong>方法的重载</strong><br><strong>在子类继承父类</strong>                        <strong>在同一个类中</strong><br><strong>方法名称、参数列表一致    **            **方法名相同参数列表不同</strong><br><strong>返回值也要一致</strong>                        <strong>与返回值类型无关</strong></p>
<h2 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h2><p>当构建子类对象时会优先隐式自动调用父类的无参构造方法，而且这个构建调用过程是从父类“向外”递归扩散的，也就是从父类开始向子类一级一级地完成构建，即如果C继承自B，而B继承自A，那么构建C的对象时，会先调用A的构造方法，然后调用B的构造方法，最后调用C的构造方法，以此类推<br>如果没有无参的父类构造方法，子类必须要使用super显示的调用父类的构造方法，而且必须是在子类构造器中做的第一件事<br>this引用对象自身、调用自己的构造方法，而super调用父类定义的成员变量、方法或构造方法，<strong>super不能当作引用传递给其他的调用者而this可以</strong></p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态性是指允许不同类的对象对同一消息作出响应<br>多态性语言具有灵活、抽象、行为共享、代码共享的优势</p>
<p><strong>Java中多态性指允许不同类的对象对同一消息做出响应</strong>。即同一消息可以根据发送对象的不同而采用多种不同的行为方式<br>发送消息就是方法调用<br>现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在IE界面下弹出的浏览器的帮助文档；如果当前在 Word 下弹出的就是 office帮助；在 Windows 下弹出的就是 Windows 帮助和支持<br>可见，同一个事件发生在不同的对象上会产生不同的结果，因此，多态的主要作用适用于<strong>消除类型之间的耦合关系</strong></p>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>方法重载：同一个类中，方法名相同、参数列表不同（类型、个数、顺序）、返回类型可以相同或不同、访问权限可以相同或不同的方法</p>
<h2 id="方法重写："><a href="#方法重写：" class="headerlink" title="方法重写："></a>方法重写：</h2><p>继承的作用就是复用，即子类直接使用父类的属性和方法<br>然而，有些时候，子类希望修改父类的方法的方法体，可以怎么做呢？<br>第一种做法是子类创建一个不同名字的新方法，实现新的逻辑，然而，这种做法会导致子类依然包含父类中的那个方法，却不应该使用，破坏封装性<br>我们希望子类中的方法依然和父类方法的声明形式一样，但是具体方法体却不同，这种做法就叫做方法覆盖/方法重写</p>
<h2 id="对比方法重写与重载"><a href="#对比方法重写与重载" class="headerlink" title="对比方法重写与重载"></a>对比方法重写与重载</h2><p>发生方法覆盖的两个方法的方法名、参数列表必须完全一致(子类重写父类的方法) ，方法返回值如果是基本数据类型，则返回值应该保持一致，<strong>如果返回值是类，则子类覆盖方法的返回值必须是父类方法返回值或其的子类（协变返回类型)</strong><br>子类抛出的异常不能超过父类相应方法抛出的异常(子类异常不能大于父类异常) （异常处理章节详细介绍）<br>子类方法的访问级别不能低于父类相应方法的访问级别(子类访问级别不能低于父类访问级别)</p>
<h2 id="我的多态："><a href="#我的多态：" class="headerlink" title="我的多态："></a>我的多态：</h2><p>Animal a;    //定义了一个引用类型a<br>a=new Animal();  //   实例化一个Animal对象给引用a<br>引用类型  与实例化类型  一致</p>
<p>指着老虎说 这是什么动物， 将老虎当成了动物<br>Animal a=new Tiger();</p>
<p>我的总结：<br>1、子类引用可以存放到父类引用中<br>2、把子类对象当成父类对象看待        把老虎  当成动物<br>3、对象的数据类型不变<br>(1) java.lang.ClassCastException：类型转换异常<br>(2)变量名  instanceof  类名 :判断变量(引用) 是否是属于  后面类型 属于 true 不属于  false</p>
<p>4、子类引用存放到父类引用中，引用只能调用其引用类型声明的方法，并且调用的方法是子类覆盖父类的方法</p>
<h2 id="对象向上造型"><a href="#对象向上造型" class="headerlink" title="对象向上造型"></a>对象向上造型</h2><p>白马是马，马非白马的问题：<br>在继承关系中，<strong>继承者完全可以替换被继承者，反之则不可以</strong><br>例如：人类是父类，男人女人是子类，一个人是男人，一定也是人，所以向上转型不需要强制，但是一个人是人，但不一定是男人，所以需要强制转<br>从上例来看:<br>”人 person = new 男人（）”是合理的<br>“男人 person = new 人()”则不合理<br><strong>所谓的向上造型就是父类的引用（栈中）指向子类的对象（堆中）</strong><br><img src="/2020/03/02/java/29.png" alt><br><strong>父类引用指向子类对象</strong><br><strong>子类引用不能指向父类对象</strong></p>
<h2 id="编译期与运行期"><a href="#编译期与运行期" class="headerlink" title="编译期与运行期"></a>编译期与运行期</h2><p>在进行对象造型时，用来声明引用的父类类型我们称为编译期类型，而实际用于构建对象的子类类型我们称为运行期类型</p>
<p><img src="/2020/03/02/java/image1.png" alt></p>
<p>那么这个时候直接使用bird对象调用成员变量和成员方法究竟应该调用编译器类型中声明的还是调用运行期类型中重写的呢？<br><strong>引用变量在编译阶段只能调用其编译时类型所具有的方法，但运行时则执行它运行时类型所具有的方法</strong><br>因此，编写Java代码时，引用只能调用编译器类型里包含的成员<br>例如，通过Object p =new Persion()代码定义一个变量p，则这个p只能调用Object类的方法，而不能调用Persion类里定义的方法</p>
<h2 id="向下造型"><a href="#向下造型" class="headerlink" title="向下造型"></a>向下造型</h2><p>对象在满足条件的情况下也能进行向下造型，即显式的将父类引用指向的对象转换为子类类型向下造型的要求是：<strong>进行向下造型的对象的运行期类型必须是子类或以子类为根的继承树中的其他类型</strong>（Ostrich extends Bird）<br><img src="/2020/03/02/java/image2.png" alt></p>
<h2 id="多态环境下对属性和方法的调用特点"><a href="#多态环境下对属性和方法的调用特点" class="headerlink" title="多态环境下对属性和方法的调用特点"></a>多态环境下对属性和方法的调用特点</h2><p>Java代码中的数据和行为（变量和方法）在进行绑定（即通过对象调用成员变量或方法时究竟调用哪个版本，如覆盖后的方法）的时候划分为两种类型：<br><strong>静态定绑</strong><br><strong>动态绑定</strong><br>静态绑定发生在编译时期，动态绑定发生在运行时<br>类的成员变量（属性）都是<strong>静态绑定的（编译时)</strong>，也就是说，<strong>类中声明的成员变量不能被子类中的同名属性覆盖，通过该类的引用调用成员，始终调用该类自身中声明的属性（即始终调用编译期类型中的属性）</strong><br><img src="/2020/03/02/java/image3.png" alt><br><img src="/2020/03/02/java/image4.png" alt><br><img src="/2020/03/02/java/image5.png" alt><br>对于Java中的方法而言，<strong>除了final（后续详细介绍），static（后续详细介绍），private和构造方法是静态绑定外</strong>，其他的方法全部为动态绑定，这就意味着方法调用将动态使用运行期类型版本）—昨天得第三条</p>
<h2 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h2><p>由上述特点可以看出：<br><strong>重载方法中具体调用哪个版本是通过静态绑定在编译期就决定了的</strong><br><strong>重写覆盖的方法调用哪个版本是通过动态绑定在运行期决定的</strong></p>
<h2 id="我的多态应用"><a href="#我的多态应用" class="headerlink" title="我的多态应用"></a>我的多态应用</h2><p>将多态作为方法参数、返回值进行应用<br><strong>方法参数</strong>案例一、动物园管理员  喂食动物——（参数是一个父类   只要是子类 都可以传递进来）<br><img src="/2020/03/02/java/image6.png" alt><br><img src="/2020/03/02/java/image7.png" alt><br><img src="/2020/03/02/java/image8.png" alt><br><img src="/2020/03/02/java/image9.png" alt><br>方法返回值案例二、动物管理员，有一个小女儿，想养一只小动物，养什么动物  根据你有多少钱—（返回值类型是父类类型  子类得任何对象都可以作为返回值进行返回）<br><img src="/2020/03/02/java/image10.png" alt><br>多态得可变参数<br><img src="/2020/03/02/java/image11.png" alt></p>
<h2 id="多态参数得使用"><a href="#多态参数得使用" class="headerlink" title="多态参数得使用"></a>多态参数得使用</h2><p>如果将方法的<strong>形参参数声明为父类类型</strong>，结合前序章节介绍的方法参数的功能（即调用方法代码前会隐式执行形参和实参之间的赋值操作），由于<strong>子类的对象赋值给父类的引用</strong>是合法的，那么在调用方法时，实参就可以是以形参类型为根的继承树中的任意类型<br>此时形参对应的<strong>运行期类型和传进来的实参运行期类型保持一致</strong></p>
<h2 id="Instanceof"><a href="#Instanceof" class="headerlink" title="Instanceof"></a>Instanceof</h2><p>实参可能是形参的任意子孙类，某些时候需要在方法中明确究竟参数的运行期类型是什么，那么instanceof运算符提供了一种解决方法<br>运算符instanceof用来判断对象是否属于某个类的实例，具体语法如下：<br><strong>对象 instanceof 类</strong><br>该表达式为一个boolean表达式，如果对象的类型是后面提供的类或其子类，则返回true，反之返回false</p>
<h2 id="多态得总结"><a href="#多态得总结" class="headerlink" title="多态得总结"></a>多态得总结</h2><p>多态在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法<br>多态存在的三个必要条件<br>继承<br>重写覆盖<br>对象向上造型-父类引用指向子类对象</p>
<h2 id="多态的好处："><a href="#多态的好处：" class="headerlink" title="多态的好处："></a>多态的好处：</h2><p>可替换性（substitutability）<br>多态对已存在代码具有可替换性<br>可扩充性（extensibility）<br>多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能<br>接口性（interface-ability）<br>多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的<br>灵活性（flexibility）<br>它在应用中体现了灵活多样的操作，提高了使用效率<br>简化性（simplicity）<br>多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要</p>
<p>JieMu类<br><img src="/2020/03/02/java/image12.png" alt><br><img src="/2020/03/02/java/image13.png" alt><br><img src="/2020/03/02/java/image14.png" alt><br>不区分大小写<br>封装TestOne<br><img src="/2020/03/02/java/image15.png" alt><br><img src="/2020/03/02/java/image16.png" alt></p>
<h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><p>关联是一种<strong>结构关系</strong>，说明<strong>一个事物的对象与另一个事物的对象相联</strong>系。给定有关联的两个类，可以从一个类的对象得到一个类的对象。关联有两元关系和多元关系。两元关系是指一种一对一的关系，多元关系是一对多或多对一的关系<br><strong>关联就是某个对象会长期的持有另一个对象的引用</strong>，而二者的关联往往也是相互的。关联的两个对象彼此间没有任何强制性的约束，只要二者同意，可以随时解除关系或是进行关联，它们在生命期问题上没有任何约定。被关联的对象还可以再被别的对象关联，所以<strong>关联是可以共享的</strong>。<br>两个类之间的简单关联<strong>表示了两个同等地位类之间的结构关系</strong>。当你想要表示结构化关系时使用关联<br>关联表示<strong>has-a关系</strong>，如学生拥有一个课程，往往表现为B作为A的属性存在（A关联B）</p>
<h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><p>最典型的一对一关系莫过于人和证件之间的关联，例如：一个人只能有一个驾照，而一个驾照只能归属与一个人：<br><img src="/2020/03/02/java/image17.png" alt></p>
<h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><p>人还可以跟其他事物构建一对多的关联关系，比如将驾照换为荣誉证书，那么一个人可以有多个荣誉证书，我们可以使用数组或集合来描述这个关系<br><img src="/2020/03/02/java/image18.png" alt></p>
<h2 id="关联关系还可以细分为聚合和组合两种"><a href="#关联关系还可以细分为聚合和组合两种" class="headerlink" title="关联关系还可以细分为聚合和组合两种"></a>关联关系还可以细分为聚合和组合两种</h2><p><strong>聚合是一种特殊的关联</strong>，表示整体对象拥有部分对象。 关联关系和聚合关系来语法上是没办法区分的，从语义上才能更好的区分两者的区别。聚合是较强的关联关系，强调的是整体与部分之间的关系。聚合的整体和部分之间在生命周期上没有什么必然的联系，部分对象可以在整体对象创建之前创建，也可以在整体对象销毁之后销毁。</p>
<p>人和自行车:人有一个自行车<br>人{<br>自行车<br>}<br>聚合是强版本的关联。它暗含着一种所属关系以及生命期关系。被聚合的对象还可以再被别的对象关联，所以被聚合对象是可以共享的。虽然是共享的，聚合代表的是一种更亲密的关系。典型的例子很多，比如：</p>
<p><img src="/2020/03/02/java/image19.png" alt><br>我的家和我之间具有着一种强烈的所属关系，我的家是可以分享的，而这里的分享又可以有两种。其一是聚合间的分享，这正如你和你媳妇儿都对这个家有着同样的强烈关联；其二是聚合与关联的分享，如果你的朋友来家里吃个便饭，估计你不会给他配一把钥匙</p>
<p><strong>组合是聚合的一种形式</strong>，<strong>它具有更强的拥有关系，强调整体与部分的生命周期是一致的</strong>，整体负责部分的生命周期的管理。生命周期一致指的是部分必须在组合创建的同时或者之后创建，在组合销毁之前或者同时销毁，部分的生命周期不会超出组合的生命周期。例如Windows的窗口和窗口上的菜单就是组合关系。如果整体被销毁，部分也必须跟着一起被销毁，如果所有者被复制，部分也必须一起被复制。<br>人{  人有心脏 有手<br>心脏<br>手<br>}<br>组合是关系当中的最强版本，它直接要求包含对象对被包含对象的拥有以及包含对象与被包含对象生命期的关系<br><img src="/2020/03/02/java/image20.png" alt></p>
<p>组合关系就是整体与部分的关系，部分属于整体，整体不存在，部分一定不存在</p>
<h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>依赖关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的事物，反之不成立<br>此关系最为简单，也最好理解，<strong>所谓依赖就是某个对象的功能依赖于另外的某个对象，而被依赖的对象只是作为一种工具在使用，而并不持有对它的引用</strong><br><strong>依赖体现了“ use a”关系</strong><br>依赖关系一般使用<strong>方法的参数体系</strong></p>
<h2 id="类之间关系"><a href="#类之间关系" class="headerlink" title="类之间关系"></a>类之间关系</h2><p><strong>类与类之间的横向关系较为微妙，大体上可以分为四种：依赖 、关联、聚合、组合。</strong><br><strong>依赖体现了use a关系，通常使用方法的参数描述</strong><br><strong>关联体现了has a关系，通常使用类的成员属性描述</strong><br><strong>几种关系的强弱如下：依赖 &lt; 关联 &lt; 聚合 &lt; 组合</strong></p>
<p><img src="/2020/03/02/java/image21.png" alt></p>
<h2 id="包的概念以及意义"><a href="#包的概念以及意义" class="headerlink" title="包的概念以及意义"></a>包的概念以及意义</h2><p>为了<strong>更好地组织类</strong>，Java 提供了包机制，用于<strong>区别类名的命名空间</strong><br>包的作用：<br>把功能相似或相关的类或接口组织在同一个包中，方便类的<strong>查找和使用</strong><br>如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，<strong>包可以避免名字冲突。</strong><br>包也提供了<strong>限定了访问权限的一个控制范围</strong>，拥有包访问权限的类才能访问某个包中的类</p>
<p>Java <strong>使用包这种机制是为了防止命名冲突，访问控制，提供搜索和定位类、接口、枚举和注解等，它把不同的 java 程序分类保存，更方便的被其他 java 程序调用</strong><br>以下是一些JDK中的包：<br>java.lang：打包基础的类<br>java.io：包含输入输出功能的函数<br>java.util：包含一些重要的工具<br>…<br>开发者可以自己把一组类等组合定义自己的包。而且在实际开发中这样做是值得提倡的，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注解等是相关的<br>由于包创建了新的命名空间，所以不会跟其他包中的任何名字产生命名冲突。<strong>使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单</strong></p>
<h2 id="Package-import"><a href="#Package-import" class="headerlink" title="Package import"></a>Package import</h2><p>Java中用package语句来将一个Java源文件中的类打成一个包<br>package语句必须作为Java源文件的第一条语句，指明该文件中定义的类所在的包。(若忽略该语句，则指定为无名包)。它的格式为：<br>   <strong>package pkg1[.pkg2[.pkg3…]];</strong><br>   Java编译器把包对应于文件系统的目录管理<br>package语句中，<strong>用“ .” 来指明目录的层次</strong><br><strong>包名 域名倒置进行设置</strong><br><a href="http://www.chinasofti.com---------&gt;com.chinasofti.xxx" target="_blank" rel="noopener">www.chinasofti.com---------&gt;com.chinasofti.xxx</a></p>
<p>Com.chinasofti.项目名称.包得功能名称</p>
<p>包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它</p>
<p>Import<br>为了能够使用其他包的成员，需要在 Java 程序中明确导入该包<br>使用 “import” 语句可完成此功能<br>在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为：<br><strong>import package1[.package2…].(classname|*);</strong><br>如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略<br>import语句中类名部分可以使用通配符“<em>”<br><strong>符号*表示直接导入包中所有的类</strong><br>如：com.chinasofti.</em>;表示导入com.chinasofti包中所有的类<br>注意：包和子包之间不存在继承关系，只要两个类不直接在同一个文件中即认为位于不同的包，因此<em>号只能包含本包中的类而不能包含子包中的类，即：<br>*</em>java.lang.<em>包中包含了Java语言中的核心工具(lang=&gt;language),因此Java将其作为缺省加载的包存在，即使用该包中的类时无需import*</em><br>类目录的绝对路径叫做 class path，设置在系统变量 CLASSPATH中<br>编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径<br>root\classes 是 class path，package 名字是 com.chinasofti,而编译器和 JVM 会在 root\classes\com\chinasofti 中找 .class 文件<br>一个 class path 可能会包含好几个路径，多路径应该用分隔符分开<br>默认情况下，<strong>编译器和 JVM 查找当前目录</strong><br>包得命名规则<br>创建包的时候，你需要为这个包取一个合适的名字，根据Java包的约定，名字内的<strong>所有字母都应小写</strong>，之后，如果非同包的其他的一个源文件使用了这个包提供的类、接口、枚举或者注释类型的时候，都必须在这个源文件的开头说明所引用的包名<br>通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 chinasofti.com，所有的包名都以 com.chinasofti 开头 </p>
<h3 id="类访问控制符"><a href="#类访问控制符" class="headerlink" title="类访问控制符"></a>类访问控制符</h3><ul>
<li>默认的（不提供访问控制符）：仅可被同包的其他代码访问</li>
<li>public： 可以被任何代码访问<h3 id="成员的访问控制"><a href="#成员的访问控制" class="headerlink" title="成员的访问控制"></a>成员的访问控制</h3></li>
<li>private    私有的</li>
<li>default(不使用default关键字，和类的default类似，不提供修饰符即为默认权限)</li>
<li>protected        受保护的</li>
<li>public       公开的</li>
</ul>
<p><img src="/2020/03/02/java/30.png" alt></p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>Object类是Java语言中所有类的根，所有的类都直接或间接的继承了Object类；<strong>数组也继承了Object类</strong>；Object类中定义了,Object类中定义了<strong>11个方法</strong>。</p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p>Object类中的equals方法的作用，与==相同，都是比较两个对象的虚地址；</p>
<p><img src="/2020/03/02/java/31.png" alt></p>
<h4 id="Hashcode"><a href="#Hashcode" class="headerlink" title="Hashcode"></a>Hashcode</h4><p>用来返回对象的哈希码；hashCode方法主要为了配合基于哈希的集合类一起工作，例如HashSet、HashMap等</p>
<p>当两个引用的虚地址相同时，hashCode返回相同的值，否则返回不同的值；</p>
<h4 id="Finalize"><a href="#Finalize" class="headerlink" title="Finalize"></a>Finalize</h4><p>Object中包含了一个叫做finalize()的方法，提供在对象被回收时调用以释放资源，默认情况下其不执行任何动作。</p>
<p><strong>每个对象只能被GC自动调用finalize( )方法一次。</strong>如果在finalize( )方法执行时产生异（exception），则该对象仍可以被垃圾收集器收集。</p>
<p>Java语言允许程序员为任何方法添加finalize( )方法，该方法会在垃圾收集器交换回收对象之前被调用。但不要过分依赖该方法对系统资源进行回收和再利用，因为<strong>该方法调用后的执行结果是不可预知的</strong>当finalize( )方法尚未被调用时，System. runFinalization( )方法可以用来调用finalize( )方法，并实现相同的效果，对无用对象进行垃圾收集</p>
<p>如果必须要重写finalize()方法，请记住使用super.finalize()调用父类的清除方法，否则对象清理的过程可能不完整</p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>默认的：类的全名(包名+类名)+@+哈希码转换成十六进制,在打印引用类型变量的时候，默认调用toString</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>Abstract 可以修饰类也可以修饰方法</p>
<p>public  abstract  class 类名{            //抽象类</p>
<p>}</p>
<p>访问控制符  修饰符 返回值类型 方法名(){}</p>
<p>抽象方法只有方法声明，没有方法实现没有{}</p>
<p>public abstract void method()；</p>
<ol>
<li>如果某个类中包含有抽象方法，那么该类就必须定义成抽象类</li>
<li>抽象类中也可以包含有非抽象的方法甚至抽象类中可以没有抽象方法</li>
<li>抽象类不可以直接实例化</li>
<li>如果抽象类的派生子类没有实现其中的所有抽象方法，那么该派生子类仍然是抽象类，只能用于继承，而不能实例化，但可以有构造函数<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2>面向接口编程和面向对象编程并不是平级的，而是附属于面向对象思想体系，属于其一部分。</li>
</ol>
<p>面向接口编程的意思是指<strong>在面向对象的系统中所有的类或者模块之间的交互是由接口完成的</strong></p>
<p><img src="/2020/03/02/java/32.png" alt></p>
<h4 id="Java接口继承接口的原则："><a href="#Java接口继承接口的原则：" class="headerlink" title="Java接口继承接口的原则："></a>Java接口继承接口的原则：</h4><p>Java接口可以继承多个接口,接口继承接口依然使用关键字extends，不要错用成implements</p>
<p>因此，在声明接口之间的继承关系时，extends关键字后面可以是一个列表</p>
<p>Java接口继承接口的形式</p>
<p>Interface3 extends Interface0, Interface1, interface……｛</p>
<p>｝</p>
<h4 id="类实现接口"><a href="#类实现接口" class="headerlink" title="类实现接口"></a>类实现接口</h4><p>一个类可以同时继承自一个父类并实现若干接口,类实现接口的一般语法如下：</p>
<p>[修饰符] class &lt;类名&gt; [extends 父类名] [implements 接口列表]{</p>
<p>}</p>
<h4 id="接口的优点-弱耦合"><a href="#接口的优点-弱耦合" class="headerlink" title="接口的优点 弱耦合"></a>接口的优点 弱耦合</h4><p>只需要架构师先设计好接口C的功能,再由A去调用接口,B去实现接口的功能,就可以避免A等待B实现接口的时间的浪费</p>
<p><img src="/2020/03/02/java/33.png" alt></p>
<h4 id="接口的回调"><a href="#接口的回调" class="headerlink" title="接口的回调"></a>接口的回调</h4><p>以前是我们调用系统中已经定义好的类中的方法进行结果实现,有了接口之后，让系统中已经存在的类，调用我们写的功能进行实现<br><img src="/2020/03/02/java/34.png" alt></p>
<p>举个例子:Java中已经定义好的类型Arrays.调用了sort方法，这个方法是用来进行排序，那么现在我们用它进行对象student排序，但是，现在我们没有说明如何进行排序，所以报错，如果你要进行排序规则的设定，那么必须要实现Comparable比较器这个接口，遵循接口中的比较方法继续说明。</p>
<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>默认方法理论上抹杀了Java接口与抽象类的本质区别-前者是行为契约的集合，后者是接口与实现的结合体。当然,语法上两者的差别和以前一样。</p>
<p><a href="https://www.cnblogs.com/sum-41/p/10878807.html" target="_blank" rel="noopener">https://www.cnblogs.com/sum-41/p/10878807.html</a></p>
<h2 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h2><ul>
<li><p>如果将某个变量修饰为final，那么该变量就成为常量,常量在声明时必须初始化，声明之后不能对其进行二次赋值，其后任何试图对常量进行赋值的语句都将报错,成员final属性，可以用过构造方法进行初始化。</p>
</li>
<li><p>如果将某个成员方法修饰为final，则意味着该方法不能被子类覆盖，这就和抽象方法必须由子类实现的规定互相矛盾，因此，final和abstract不能同时修饰一个方法。</p>
</li>
</ul>
<ul>
<li>如果将某个类修饰为final，则说明该类无法被继承，一般语法：[访问权限] final class 类名 {成员列表}</li>
</ul>
<h2 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h2><p>针对一个类<strong>所有对象的共有属性</strong>，Java采用static成员完成统一调用</p>
<p><strong>static 在变量或方法之前</strong>，表明它们是属于类的，称为类方法<strong>（静态方法）或类变量（静态变量）</strong>。若无static修饰，则是实例方法和实例变量</p>
<p>和类的其他成员属性不同，static成员并不存放在对象对应的堆空间中，通过对JVM的分析发现，其会将static成员<strong>存放在方法区中</strong>，每个对象的相应static共享同一段内存</p>
<p><img src="/2020/03/02/java/36.png" alt></p>
<h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><p>不论有多少个对象，静态成员变量只有一份内存拷贝，即所有对象共享该成员变量.</p>
<p>静态成员变量的作用域只在类内部，但其生命周期却贯穿整个程序</p>
<p>在没有实例化对象时，可以通过类名访问静态成员变量,也可以通过对象访问静态成员变量，但不论使用的是哪个对象，访问到的都是同一个变量</p>
<h4 id="static和final联合起来使用"><a href="#static和final联合起来使用" class="headerlink" title="static和final联合起来使用"></a>static和final联合起来使用</h4><p>当一个变量被static和final共同修饰时，其和仅用static修饰的变量的差异在于声明时必须初始化，而且在整个程序生命周期内<strong>不能</strong>再对这个变量<strong>进行二次赋值</strong>,static final常量通常用于保存整个应用程序<strong>共享的常量值</strong>。</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul>
<li>实例方法中可以直接调用static方法</li>
<li>实例方法中可以直接访问static成员变量而static方法中不能直接访问非static的成员变量</li>
<li>static方法中无法直接调用本类中声明的其他实例方法，如果需要调用，只能在方法体中构建本类的对象，然后利用该对象调用实例方法</li>
<li>static方法可以直接调用本类中声明的其他static方法</li>
<li>静态成员方法<strong>没有this引用</strong><h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h3>import static java.lang.Math.*表示导入Math类中所有的静态成员<br>使用import static语句，可以导入一个类里的一切被static修饰的东西，包括变量、常量、方法和内类</li>
</ul>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>Static 静态代码块 是在类加载的时候调用，而且 只调用一次。类加载：JVM第一次加载.class文件的时候</p>
<p>{代码块}  c创建对象时，会执行，创建几个对象 执行几次</p>
<ol>
<li>静态代码块先执行</li>
<li>执行代码块</li>
<li>执行构造方法</li>
</ol>
<h4 id="两个语句导入同名的静态成员的情况"><a href="#两个语句导入同名的静态成员的情况" class="headerlink" title="两个语句导入同名的静态成员的情况"></a>两个语句导入同名的静态成员的情况</h4><ul>
<li>如果两个语句<strong>都是精确导入</strong>的形式，或者都是按需导入的形式，那么会造成<strong>编译错误</strong>。</li>
<li>如果一个语句采用精确导入的形式，一个采用通配符*按需导入的形式，那么采用精确导入的形式的一个有效。</li>
<li>如果两个同名的静态成员一个是属性，而另一个是方法，那么因为使用时的写法有差异，不会造成任何的冲突</li>
</ul>
<h4 id="静态方法中不能使用this引用的原因"><a href="#静态方法中不能使用this引用的原因" class="headerlink" title="静态方法中不能使用this引用的原因"></a>静态方法中不能使用this引用的原因</h4><ul>
<li>之所以在非静态方法中可以使用this，是因为非静态方法参数传递时，有一个隐式参数this，这个this就是调用该方法的对象本身比如：Object o=new Object();o.toString(); 实际上是有参数传递的toString(Object this),且o==this这样在非静态方法中就可以通过this来得到调用对象的其他成员和方法，私有成员的也行.</li>
<li>静态方法是属于类而并不属于某个对象。其在加载类时就已经被虚拟机初始化，此时不存在任何对象的概念，所以没有办法传递隐式参数this，自然也就不能通过this调用对象本身了，    但这并不意味这不能调用非静态域。我们可以通过显示参数传递来做到这一点.<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2>Java语言中有8个基本数据类型，对应有8个类，这8个类统称包装器类型（Wrapper类）；使用这8个包装器类，能够把某一种基本数据类型的变量转换成引用类型，从而使用类中的方法，进行更多的操作；</li>
</ul>
<p><img src="/2020/03/02/java/37.png" alt></p>
<h3 id="拆箱和装箱"><a href="#拆箱和装箱" class="headerlink" title="拆箱和装箱"></a>拆箱和装箱</h3><ul>
<li>装箱：基本数据类型转换为包装器类型，称为装箱（boxing）；例如，int型转换为Integer类型；</li>
<li>拆箱：包装器类型转换为基本数据类型，称为拆箱（unboxing）；例如Integer类型转换为int类型；</li>
</ul>
<p>在自动装箱拆箱过程中，Java使用到了常量池；<br>如前面所学习，常量池就是方法区的一部分，是内存的逻辑分区；<br>如下代码所示,i1、i2使用到了自动装箱，io1和io2则没有使用：<br>i1 i2使用到常量池，io1、io2没有使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i1=10;</span><br><span class="line">Integer i2=10;</span><br><span class="line">Integer io1=new Integer(10);</span><br><span class="line">Integer io2=new Integer(10);</span><br><span class="line">System.out.println(&quot;i1==i2&quot;+(i1==i2));</span><br><span class="line">System.out.println(&quot;io1==io2&quot;+(io1==io2));</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/02/java/38.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i3=1000;</span><br><span class="line">Integer i4=1000;</span><br><span class="line">Integer io3=new Integer(1000);</span><br><span class="line">Integer io4=new Integer(1000);</span><br><span class="line">System.out.println(&quot;i3==i4&quot;+(i3==i4));</span><br><span class="line">System.out.println(&quot;io3==io4&quot;+(io3==io4));</span><br></pre></td></tr></table></figure>
<p>居然输出都为false！为什么与值为10的时候不一样？<br>原因：<strong>在自动装箱拆箱过程中，只有数值是byte范围内(-127~127)的时候，才使用到常量池，否则都是分配新的内存空间</strong>；<br>1000早就超出了byte的范围，所以i3/i4是两个空间；</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类是Java独有的一种语法结构，即<strong>在一个类的内部定义另一个类</strong>，此时，<strong>内部类就成为外部类中的成员，访问权限遵循类成员的访问权限机制</strong>，可以是public、protected、缺省和private,<strong>内部类可以很方便地访问外部类中的其它成员</strong>。</p>
<p>根据内部类的定义，我们发现它能帮我实现一些特殊的需要：</p>
<ul>
<li><strong>完善多重继承</strong></li>
<li><strong>形成闭包</strong><h3 id="完善多重继承"><a href="#完善多重继承" class="headerlink" title="完善多重继承"></a>完善多重继承</h3>之前提到过，继承耦合度太高。比如你是一个人，你想会飞，于是就继承了鸟这个类，然后你顺便拥有了一对翅膀和厚厚的羽毛，可这些玩意你并不需要。所以Java发明了接口，以行为契约的方式向你提供功能。想想看，你的程序里成员变量会比方法多吗？况且多重继承会遇到死亡菱形问题，就是两个父类有同样名字的函数，你继承谁的呢？所以Java只支持单重继承，想扩展功能，去实现接口吧<br>很快Java的设计者就发现了他们犯了矫枉过正的错误，多重继承还是有一定用处的。比如每一个人都是同时继承父亲和母亲两个类，要不然你的身体里怎么能留着父母的血呢？Java内部类应运而生，使用内部类最吸引人的原因是：<strong>每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响</strong><h3 id="形成闭包"><a href="#形成闭包" class="headerlink" title="形成闭包"></a>形成闭包</h3>内部类是面向对象的闭包，因为它不仅包含创建内部类的作用域的信息，还自动<strong>拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员</strong>。</li>
</ul>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>把以前类中定义成员的位置定义一个类，这个就是成员内部类</p>
<p><strong>成员内部类</strong>是最普通的内部类，它是外围类的一个成员，所以他是<strong>可以无限制的访问外围类的所有成员属性和方法</strong>，即便是private的，但是<strong>外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问</strong>。</p>
<p>成员内部类如何创建对象</p>
<ol>
<li>首先构建外部类对象</li>
<li>以外部内.内部类的形式进行声明</li>
<li>以外部内对象.new 内部类构造方法()的方式构建对象</li>
</ol>
<p><img src="/2020/03/02/java/39.png" alt></p>
<p>内部类是个编译时的概念，<strong>一旦编译成功后，它就与外围类属于两个完全不同的类</strong>（当然他们之间还是有联系的）<br>对于一个名为OuterClass的外围类和一个名为InnerClass的内部类，在编译成功后，会出现这样两个class文件,OuterClass.class和OuterClass$InnerClass.class</p>
<p>在成员内部类中要注意两点：</p>
<ul>
<li>第一：<strong>成员内部类中不能存在任何static的变量和方法（成员内部类可以访问外部类的静态属性和方法，但是内部类中不能定义静态的变量和方法）</strong></li>
<li>第二：<strong>成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类</strong>。</li>
</ul>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>关键字static可以修饰成员变量、方法、代码块，其实它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类或嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外部类，但是静态内部类却没有。没有这个引用就意味着：</p>
<p>静态内部类的特点:</p>
<ul>
<li><strong>它的创建是不需要依赖于外部类的</strong></li>
<li><strong>它不能使用任何外部类的非static成员变量和方法</strong></li>
<li><strong>和成员内部类不同，static内部类能够声明static的成员</strong></li>
</ul>
<p><img src="/2020/03/02/java/40.png" alt></p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>还有一种内部类，它嵌套在方法和作用域内的，对于这个类的使用主要是应用与解决比较复杂的问题，想<strong>创建一个类来辅助我们的解决方案，又不希望这个类是公共可用的，所以就产生了局部内部类</strong>，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和作用域中被使用，出了该方法和作用域就会失效</p>
<p><img src="/2020/03/02/java/41.png" alt></p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>如果一类内部类仅需要构建一个单一的对象，那么这个类其实并不需要额外取一个特有的名字，对于不存在名字的内部类，我们称为匿名内部类。</p>
<p><strong>匿名内部类必须继承一个父类或实现一个接口</strong><br>匿名内部类的声明使用方法如下：<br>[访问权限] [修饰符]父类名/接口名 引用名 = new 父类名/接口名（[父类构造方法参数列表]）｛<br>匿名内部类成员；<br>｝ </p>
<ul>
<li><strong>匿名内部类没有构造方法（匿名内部类没有显式类名）</strong></li>
<li><strong>匿名内部类要想完成一些初始化工作可以交由类初始化或实例初始化代码块来完成</strong></li>
<li><strong>匿名内部类对类成员、方法临时变量的访问规则和具备名字的内部类保持一致</strong></li>
</ul>
<p><img src="/2020/03/02/java/42.png" alt></p>
<h3 id="This引用问题"><a href="#This引用问题" class="headerlink" title="This引用问题"></a>This引用问题</h3><p>之前提到非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外部类,但是和以前类中直接使用this引用当前对象的情况相比要复杂一些<br>由于内部类本质上是一个独立的类，<strong>因此在内部类中直接使用this，其指代的是内部类自身的引用，如果要想引用外部内的对象，则应该使用外部类类名.this的方式</strong></p>
<p><img src="/2020/03/02/java/43.png" alt></p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>在很长的一段时间里，Java编写GUI应用程序由于要注册大量的各类事件监听，导致代码中存在各种匿名内部类，大把大把拖沓的代码，程序毫无美感可言<br>在JDK8中Java终于引入了动态语言或函数式语言中的lambda表达式<br>Lambda表达式主要是<strong>替换了原有匿名内部类的写法，也就是简化了匿名内部类的写法。</strong>lambda语法结构如下：</p>
<p>(parameters) -&gt; expression或(parameters) -&gt;{ statements; }</p>
<h3 id="Lambda表达式语法示例："><a href="#Lambda表达式语法示例：" class="headerlink" title="Lambda表达式语法示例："></a>Lambda表达式语法示例：</h3><ul>
<li>不需要参数,返回值为 5  :() -&gt; 5    </li>
<li>接收一个参数(数字类型),返回其2倍的值：  x -&gt; 2 * x  </li>
<li>接受2个参数(数字),并返回他们的差值：  (x, y) -&gt; x – y  </li>
<li>接收2个int型整数,返回他们的和：  (int x, int y) -&gt; x + y  </li>
<li>接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void):  (String s) -&gt; System.out.print(s) </li>
</ul>
<p><img src="/2020/03/02/java/44.png" alt></p>
<h3 id="Lambda表达式对返回的实例类型有比较严格的要求："><a href="#Lambda表达式对返回的实例类型有比较严格的要求：" class="headerlink" title="Lambda表达式对返回的实例类型有比较严格的要求："></a>Lambda表达式对返回的实例类型有比较严格的要求：</h3><ul>
<li><strong>必须是接口</strong></li>
<li><strong>接口中只有一个需要实现的抽象方法，因此如果接口中有超过1个抽象方法需要实现的情况并不适用于lambda表达式</strong></li>
</ul>
<p>每一个lambda表达式都对应一个接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。<strong>因为默认方法不算抽象方法，所以也可以给函数式接口添加默认方法</strong></p>
<h3 id="自定义函数式接口满足Lambda表达式"><a href="#自定义函数式接口满足Lambda表达式" class="headerlink" title="自定义函数式接口满足Lambda表达式"></a>自定义函数式接口满足Lambda表达式</h3><p>可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的：<br>是否为接口添加@FunctionalInterface注解并不影响lambda表达式的功能，大家已经看到了，在最开始的示例中，我们并没有在接口上标注它，代码仍然运行良好，因此@FunctionalInterface注解只是为了在代码开发阶段由编译器帮助开发人员判定接口是否符合函数式接口的定义（是否适用于lambd表达式）</p>
<p><img src="/2020/03/02/java/45.png" alt></p>
<p>在lambda表达式中访问外层作用域和老版本的匿名内部类中的方式很相似,可以直接访问标记了final的外层局部变量，或者实例的成员变量以及静态变量,和匿名内部类不同的是，局部变量可以不用声明为final，代码同样能够正确执行，但变量必须不可表达式的代码修改（即隐性的具有final的语义）</p>
<p>有一个和接口的默认方法相关的要点需要特别留意：<br><strong>Lambda表达式中是无法访问到默认方法的</strong>  不是表示引用无法访问，引用可以访问（） -&gt;{ 这里面 无法访问到默认方法 ，这里面只是那一个抽象的方法，不是默认方法  }</p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符(::)"></a>操作符(::)</h3><p>::操作符主要用作静态方法、成员方法或构造方法的绑定</p>
<p><img src="/2020/03/02/java/46.png" alt></p>
<h2 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h2><h3 id="枚举的特点"><a href="#枚举的特点" class="headerlink" title="枚举的特点"></a>枚举的特点</h3><ul>
<li><strong>所有的枚举都继承自java.lang.Enum类。由于Java 不支持多继承，所以枚举对象不能再继承其他类,</strong></li>
<li><strong>枚举可以实现接口</strong></li>
<li>不能有public的构造函数，这样做可以保证客户代码没有办法新建一个enum的实例。 </li>
<li>所有枚举值都是public , static , final的。注意这一点只是针对于枚举值，我们可以和在普通类里面定义 变量一样定义其它任何类型的非枚举变量，这些变量可以用任何你想用的修饰符。 </li>
</ul>
<h3 id="枚举的优点"><a href="#枚举的优点" class="headerlink" title="枚举的优点"></a>枚举的优点</h3><p>在枚举出现之前，如果想要表示一组特定的离散值，往往使用一些常量。例如：</p>
<p><img src="/2020/03/02/java/47.png" alt></p>
<p>定义常规的静态常量后使用存在的一些小问题：</p>
<ul>
<li><strong>类型不安全，无法保证，输入或者验证的数据是当前例子中已经存在，如果要判断存在不存在，编写方法进行验证</strong></li>
<li><strong>耦合性高，扩展性差。</strong></li>
</ul>
<p>枚举就是为了这样的问题而诞生的。它们给出了将一个任意项同另一个项相比较的能力，并且可以在一个已定义项列表中进行迭代</p>
<p>枚举（在Jave中简称为Enum）是一个特定类型的类。所有枚举都是Java中的新类<strong>java.lang.Enum的隐式子类</strong>。此类不能手工进行子类定义</p>
<h3 id="枚举的声明"><a href="#枚举的声明" class="headerlink" title="枚举的声明"></a>枚举的声明</h3><p>枚举的基本声明格式如下：</p>
<p>[访问权限] enum 枚举名｛<br>枚举值列表<br>｝</p>
<p><img src="/2020/03/02/java/48.png" alt><br><img src="/2020/03/02/java/49.png" alt></p>
<h3 id="枚举类提供的方法"><a href="#枚举类提供的方法" class="headerlink" title="枚举类提供的方法"></a>枚举类提供的方法</h3><ul>
<li>Enum默认实现了java.lang.Comparable接口。 </li>
<li>Enum覆载了了toString方法</li>
<li>Enum提供了一个valueOf方法，这个方法和toString方法是相对应的</li>
<li>Enum还提供了values方法，这个方法使你能够方便的遍历所有的枚举值</li>
<li>Enum还有一个oridinal的方法，这个方法返回枚举值在枚举类种的顺序，这个顺序根据枚举值声明的顺序而定</li>
</ul>
<p><img src="/2020/03/02/java/50.png" alt></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li>异常（Exception）：<strong>异常指的是程序运行时发生的不正常事件；异常能够被程序处理，保证程序继续运行下去；</strong>例如除数为0、文件没有找到、输入的数字格式不对……</li>
<li>错误（Error）:<strong>错误程序没法处理，例如内存泄漏。</strong>发生错误后，一般虚拟机会选择终止程序运行，程序员需要修改代码才能解决相关错误；</li>
</ul>
<p><img src="/2020/03/02/java/51.png" alt></p>
<h3 id="API树状结构"><a href="#API树状结构" class="headerlink" title="API树状结构"></a>API树状结构</h3><p>API中标准异常的顶级父类是<strong>Throwable类</strong>；</p>
<p>Throwable类有两个子类：<strong>Exception和Error</strong>；所有异常都是Exception类的直接或间接子类；所有错误都是Error的直接或间接子类；</p>
<h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><p>Exception有很多子类；这些子类又可以分为两大类；即<strong>运行时异常和非运行时异常</strong>;RuntimeException的子类都是运行时异常，其他的都是非运行时异常；</p>
<ul>
<li>运行时异常：也称为<strong>非检测异常</strong>（unchecked Exception）， 这些异常在编译期不检测，程序中<strong>可以选择处理，也可以不处理</strong>。如果不处理运行时会中断，但是编译没问题；</li>
<li>非运行时异常：也称为<strong>检测异常</strong>（checked Exception）, 是<strong>必须进行处理的异常，如果不处理，将发生编译期错误</strong>；</li>
</ul>
<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><h4 id="NullPointerException-空指针异常"><a href="#NullPointerException-空指针异常" class="headerlink" title="NullPointerException-空指针异常"></a>NullPointerException-空指针异常</h4><p>发生前提：当对一个空对象，即没有初始化，依然为null的对象调用属性或方法时；</p>
<p><img src="/2020/03/02/java/52.png" alt></p>
<p>如果String s=””;调用s.length()会发生空指针异常吗？</p>
<p>s=””  s已经实例化 指向的资源内没有什么数据   长度为0</p>
<h4 id="ArithmeticException-数学异常"><a href="#ArithmeticException-数学异常" class="headerlink" title="ArithmeticException-数学异常"></a>ArithmeticException-数学异常</h4><p>发生前提：整数除以0时发生    浮点数除以0   0  无限接近0 </p>
<p><img src="/2020/03/02/java/53.png" alt></p>
<h4 id="IndexOutOfBoundsException：索引越界异常"><a href="#IndexOutOfBoundsException：索引越界异常" class="headerlink" title="IndexOutOfBoundsException：索引越界异常"></a>IndexOutOfBoundsException：索引越界异常</h4><p>包括字符串索引StringIndexOutOfBoundsException和数组索引ArrayIndexOutOfBoundsException两种；</p>
<p>发生前提：当访问字符串中的字符或者数组中的元素，超过了其长度时；</p>
<p><img src="/2020/03/02/java/54.png" alt><br><img src="/2020/03/02/java/55.png" alt><br><img src="/2020/03/02/java/56.png" alt></p>
<h4 id="NumberFormatException-数字格式异常"><a href="#NumberFormatException-数字格式异常" class="headerlink" title="NumberFormatException-数字格式异常"></a>NumberFormatException-数字格式异常</h4><p>发生前提：当把一个字符串转换成数字时，字符串内容不是数字时发生；</p>
<p><img src="/2020/03/02/java/57.png" alt></p>
<h4 id="ClassCastException-类型转换异常"><a href="#ClassCastException-类型转换异常" class="headerlink" title="ClassCastException-类型转换异常"></a>ClassCastException-类型转换异常</h4><p>发生前提：把父类对象转换成不相关的子类类型时；</p>
<p><img src="/2020/03/02/java/58.png" alt></p>
<h3 id="非运行时异常"><a href="#非运行时异常" class="headerlink" title="非运行时异常"></a>非运行时异常</h3><h4 id="FileNotFoundException文件不存在异常"><a href="#FileNotFoundException文件不存在异常" class="headerlink" title="FileNotFoundException文件不存在异常"></a>FileNotFoundException文件不存在异常</h4><p><img src="/2020/03/02/java/59.png" alt></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>Java语言中异常处理主要使用到try/catch/finally三种语句</p>
<p><img src="/2020/03/02/java/60.png" alt><br>把所有<strong>可能抛出异常的，或者肯定抛出异常的代码</strong>都写到try代码块中；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">      可能抛出异常的代码块;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch语句紧随try语句后，用来捕获异常并进行处理；</span><br><span class="line">try&#123;</span><br><span class="line">      可能抛出异常的代码块;</span><br><span class="line">&#125;catch(异常类型  变量名)&#123;</span><br><span class="line">       处理异常的代码;</span><br><span class="line">&#125;</span><br><span class="line">会发生三种情况：</span><br><span class="line">1、发生异常被捕获处理；</span><br><span class="line">2、发生异常没有被捕获处理；</span><br><span class="line">3、没发生异常</span><br></pre></td></tr></table></figure>

<p>当try块中中代码抛出了异常对象后，异常处理机制就<strong>将这个对象的类型与try后的catch语句中的异常类型进行匹配</strong>，如果<strong>类型相同</strong>，<strong>或者抛出的是捕获的子类</strong>，就称为匹配成功，那么异常就被捕获，就运行catch块中的语句；否则，称为异常没有被捕获，程序将中断；</p>
<p><img src="/2020/03/02/java/61.png" alt><br>catch语句里都写什么代码？<br>可以写任意需要对异常进行处理的代码；<br>可以调用异常对象的方法，例如printStackTrace，查看异常发生的栈轨迹</p>
<p><img src="/2020/03/02/java/62.png" alt><br>如果try块中有多行代码，有可能抛出多种类型异常，那么可以<strong>使用多个catch语句</strong>；</p>
<p>注意：catch语句的异常类型必须从子类到父类的顺序，否则编译错误；<br><strong>从上到下 子类到父类</strong>   父类不能放在第一个catch里面</p>
<h3 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h3><ol>
<li>抛出异常并被处理后，finally块被执行；</li>
<li>抛出异常未被处理，finally块被执行</li>
<li>没有抛出异常，finally块被执行；</li>
<li>如果语句中有return，先执行finally里面的代码之后，再去return 返回结束方法</li>
<li>System.exit()  直接关闭程序  无法执行</li>
</ol>
<h3 id="组合情况"><a href="#组合情况" class="headerlink" title="组合情况"></a>组合情况</h3><p>必须有try，catch可以有1个或多个，finally最多1个，可以没有，不能有多个；<br>还有另外一种组合：只有try和finally，没有catch</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">&#125;finally&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Throw"><a href="#Throw" class="headerlink" title="Throw"></a>Throw</h3><p>我们一直说：抛出异常，抛出异常，到底异常怎么抛出的呢？<br>抛出异常其实就是创建了一个异常对象，然后用throw关键字交给异常处理机制去处理；<br>throw关键字在方法体中使用，用法如下：<br>throw 异常对象；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">throw new Exception();</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">catch(Exception e)&#123;</span><br><span class="line">    throw e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行时异常是JVM自动抛出，非运行时异常需要程序员用throw关键字抛出；<br>如下所示：<br>上述代码发生编译错误：由于抛出了Exception，是非运行时异常，所以编译期检测，要求必须处理，处理的方式有两种：<br>使用try/catch/finally进行处理；<br>不处理，用throws声明异常<br><strong>当用throw抛出异常时，基本都使用throws进行声明</strong>！</p>
<p><img src="/2020/03/02/java/63.png" alt><br><img src="/2020/03/02/java/64.png" alt><br>throws用在方法声明处，声明该方法可能发生的异常类型；<br>一个方法如果使用了throws，那么调用该方法时，编译期会提醒必须处理这些异常，否则编译错误；<br><strong>throws后可以声明多种类型，用逗号隔开</strong>即可；<br><strong>抽象方法也可以</strong>使用throws<strong>声明</strong>该方法可能抛出的<strong>异常</strong>类型；</p>
<p>一个方法如果使用了throws，那么调用该方法时，编译期会提醒必须处理这些异常，否则编译错误；<br><img src="/2020/03/02/java/65.png" alt><br>依然可以用两种方法处理，可以try/catch，可以继续throws，一般选择try/catch；<br><img src="/2020/03/02/java/66.png" alt></p>
<p>如果希望对异常先统一处理，可以处理后再抛出；<br><img src="/2020/03/02/java/67.png" alt><br>调用的时候可以继续处理；<br><img src="/2020/03/02/java/68.png" alt><br>如果希望不管有没有异常都做统一处理，有异常声明抛出，可以使用try/finally<br><img src="/2020/03/02/java/69.png" alt><br>调用的时候可以继续处理；<br><img src="/2020/03/02/java/70.png" alt></p>
<h3 id="throw和throws的关系"><a href="#throw和throws的关系" class="headerlink" title="throw和throws的关系"></a>throw和throws的关系</h3><p><img src="/2020/03/02/java/71.png" alt></p>
<h3 id="Finally与return"><a href="#Finally与return" class="headerlink" title="Finally与return"></a>Finally与return</h3><p>finally块前有return语句，finally依然被执行；<br>finally块前有System.exit(0)语句，finally不被执行；</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>为了能够标记项目中的异常事件，需要使用throw抛出异常；<br>如果抛出的是API中的标准异常，那么很可能与API中方法抛出的异常混淆，因此需要自定义异常；<br>项目组根据业务需求定义业务异常，对团队协作开发非常有意义；<br>自定义异常类非常简单，只要继承API中任意一个标准异常类即可；<br>多数情况下，继承Exception类；也可以选择继承其他类型异常；<br>一般自定义异常类中不写其他方法，只重载必要的构造方法；<br>使用自定义异常与使用API中标准异常一样；<br>可以用throw抛出自定义异常对象，使用throws声明自定义异常类型；<br>可以使用try/catch/finally处理异常；<br><img src="/2020/03/02/java/72.png" alt><br><img src="/2020/03/02/java/73.png" alt></p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>JDK1.4版本开始，增加了断言机制；<br>断言用来进行调试，不在生产环境中使用；<br>换言之，断言是为了帮助程序员在编程的过程中，尽快发现错误并进行修改，使得程序在生产环境中正常运行；<br>断言使用关键字assert表示，语法非常简单，有两种形式：<br>assert &lt;布尔表达式&gt;<br>assert &lt;布尔表达式&gt; : &lt;错误信息&gt;<br>当布尔表达式的值是true时，忽略assert；<br>当布尔表达式的值是false时，发生AssertionError错误，程序中断；如果用第二种形式，同时显示错误信息；</p>
<h3 id="Eclipse：开启断言"><a href="#Eclipse：开启断言" class="headerlink" title="Eclipse：开启断言"></a>Eclipse：开启断言</h3><p>Window—&gt;Preferences—&gt;搜索JRES—双击你的jre—-&gt;在JVM添加参数-enableassertions—点击应用ok</p>
<p><img src="/2020/03/02/java/74.png" alt><br><img src="/2020/03/02/java/75.png" alt></p>
<h1 id="计算机发展史"><a href="#计算机发展史" class="headerlink" title="计算机发展史"></a>计算机发展史</h1><p>在发展的初期，计算机还没有操作系统或只拥有<strong>单任务操作系统；它们自始至终执行一个程序</strong>，这个程序直接访问机器的所有资源。这样一个程序运行在无保护的电子器件上，不仅写起来困难，而且每次只运行一个程序，不能很好地利用昂贵且稀缺的计算机资源<br><strong>操作系统的发展使得多个程序能够同时运行</strong>，程序在各自的进程中运行：相互分离，各自独立执行，由操作系统来分配资源，比如内存、文件句柄、安全证书。如果需要的话，进程会通过一些原始的机制相互通信：Socket、信号处理、共享内存、信号量和文件等<br>有一些因素推动促进了操作系统支持多程序同时执行的发展：<br>资源利用：<br>程序有时候需要等待外部的操作，比如输入和输出，并且在等待的时候不可能进行有价值的工作。在等待的时候，让其他的程序运行会提高效率<br>公平：<br>多个用户或程序可能对系统资源有平等的优先级别。让他们通过更好的<strong>时间片方式来共享计算机</strong>，这要比结束一个程序后才开始下一个程序更可取<br>方便：<br>写一些程序，让它们各自执行一个单独任务并进行必要的相互协调，这要比编写一个程序来执行所有的任务更容易，更让人满意<br>在了解了操作系统的<strong>并发</strong>发展趋势之后，我们需要明确几个科学定义： </p>
<ul>
<li><p><strong>程序</strong>：<br>是<strong>计算机指令的集合</strong>.程序是<strong>一组静态的指令集</strong>，不占用系统运行资源,不能被系统调度，也不能作为独立运行的单位,它以文件的形式存储在磁盘上</p>
</li>
<li><p><strong>进程</strong>：<br>是<strong>一个程序在其自身的地址空间中的一次执行活动</strong>。比如，打开一个记事本，就是调用了一个进程。进程是资源申请、调度和独立运行的单位，因此，它使用系统中的运行资源；而程序不能申请系统资源，一个程序可以对应多个进程，例如著名的QQ多开<br>在早期的分时共享系统中，每一个进程都是一个虚拟的冯诺依曼机：<br>它拥有一个内存空间，储存着指令和数据，根据机器语言的语义来顺序地执行指令，并且通过操作系统的I/O原语集来实现与外部世界的交互<br>对于每条指令的执行，都有一个对“下条指令”的明确定义，并根据程序中的指令集来进行流程的控制，现在几乎所有广泛使用的编程语言都遵循这个顺序的编程模型，其中语言规范明确定义了在一个给定动作完成后，下一个动作是什么</p>
</li>
</ul>
<p>顺序编程模型是自然的、常规的，就像是遵守着人类的工作方式：一次做一件事情，顺序进行。通常如此：<br>在编程语言中，真实世界中的每一个动作，都会抽象成一个规则的动作序列</p>
<p><img src="/2020/03/02/java/76.jpg" alt></p>
<p>上例的最后一步：等待水沸腾引入了异步这个要点<br>当水在加热的时候，你可以选择做什么-等待，或者开始准备吐丝面包（另一个异步任务），还可以取一份报纸看，同时仍然要记得煮开水的壶马上就会需要你的关注<br>开水和吐丝面包的生产者知道他们的产品通常在异步的情况下使用，所以在任务结束的时候，它们会提高信号的音量。找到顺序和异步之间最好的平衡，通常是那些高效率人士的一个特点，对于程序来说也是如此</p>
<p>•相同的关注点（资源利用，公平和方便）不仅促进了进程的发展，也促进了线程的发展。线程允许程序控制流的多重分支同时存在于一个进程：<br>•线程共享进程范围内的资源，比如内存和文件句柄，但是每一个线程有其自己的程序计数器、栈和本地变量<br>•线程也为多处理器系统中并行地使用硬件提供了一个自然而然的分解；同一程序内的多个线程可以在多CPU的情况下同时调度<br>•线程有些时候被称为轻量进程，并且大多数现代操作系统把线程作为时序调度的基本单元，而不是进程，在没有明确协调的情况下，线程相互间同时或异步地执行。因为线程共享其所属进程的内存地址空间，因此所有同一进程中的线程访问相同的变量，并从同一个堆中分配对象，这相对于进程间通信机制来说实现了良好的数据共享。但是如果没有明确的同步来管理共享数据，一个线程可能会修改其他线程正在使用的数据，产生意外的结果<br><img src="/2020/03/02/java/77.png" alt></p>
<h2 id="为什么要进行多线程编程"><a href="#为什么要进行多线程编程" class="headerlink" title="为什么要进行多线程编程"></a>为什么要进行多线程编程</h2><p>•多线程优点：<br>•可以更好的实现并行<br>•恰当地使用线程时，可以降低开发和维护的开销，并且能够提高复杂应用的性能。<br>•CPU在线程之间开关时的开销远比进程要少得多。因开关线程都在同一地址空间内，只需要修改线程控制表或队列，不涉及地址空间和其他工作。<br>•创建和撤销线程的开销较之进程要少。<br>•如果没有多线程的支持，是否对之前我们讲授过的一些Java特性产生影响？<br>•对于Java的垃圾回收机制而言，没有多线程的支持，就会导致一场悲剧，垃圾回收过程将会使所有的业务操作挂起：<br>•Java在语言级提供了对多线程程序设计的支持<br>•多线程操作会增加程序的执行效率。各线程之间切换执行，时间比较短，看似是多线程同时运行，但对于执行者CPU来说，某一个时刻只有一个线程在运行<br>（CPU分时间片  宏观并行，微观串行）<br><img src="/2020/03/02/java/78.png" alt></p>
<h2 id="实现线程模型"><a href="#实现线程模型" class="headerlink" title="实现线程模型"></a>实现线程模型</h2><p>•在JVM规范里没有规定的线程实现模型，具体的JVM实现用1:1（内核线程）、N:1（用户态线程）、M:N（混合）模型的任何一种都是允许的。Java并不暴露出不同线程模型的区别，上层应用是感知不到差异的，只是性能特性会不太一样<br>•Java SE最常用的JVM是Oracle/Sun研发的HotSpot VM。在这个JVM的较新版本所支持的除了Solaris之外的平台上，它都是使用1:1线程模型的，而在Solaris上，HotSpot VM使用的是M:N和1：1两种模型，1：1是默认值<br>•语言级别支持N：1线程模型为能够为Java带来一个好处：能够在受限的单线程系统中支持多线程的Java应用，但是也会带来一些隐患：<br>•只要一个应用线程产生了一次系统调用，比如I/O中断，那同一进程内的其他线程都会停止<br>•不能利用多核，无法发挥多线程处理器优势<br>•一部分JVM采取了折中的处理办法：<br>•用于Java ME CLDC的CLDC HotSpot Implementation（CLDC-HI）支持两种线程模型，默认使用N:1线程模型，所有Java线程都映射到一个内核线程上，是典型的用户态线程模型；它也可以使用一种特殊的混合模型，Java线程仍然全部映射到一个内核线程上，但当Java线程要执行一个阻塞调用时，CLDC-HI会为该调用单独启动一个内核线程，并且调度执行其它Java线程，等到那个阻塞调用完成之后再重新调度之前的Java线程继续执行<br>•Java对线程内置语言级别的支持是一把双刃剑。它通过提供语言和类库，以及一个规范的跨平台存储模型（这个规范的存储模型使得在Java中开发“一次开发随处运行”的并发程序成为可能），简化了并发应用的开发。这样做同时也提高了开发人员的门槛。<br>•更多的程序需要使用多线程协作，曾几何时，当线程还十分深奥的时候，并发还是一个“高级”的话题，而现在，主流的开发人员都必须知道线程安全性的问题</p>
<h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>Java中线程存在以下几种状态（后续将详细讲解对应代码）： </p>
<ul>
<li><p>新线程：<br>•当利用new关键字创建线程对象实例后，它仅仅作为一个对象实例存在， JVM没有为其分配CPU时间片和其他线程运行资源</p>
</li>
<li><p>就绪状态：<br>•在处于创建状态的线程中调用start方法将线程的状态转换为就绪状态。这时，线程已经得到除CPU时间之外的其它系统资源，只等JVM的线程调度器按照线程的优先级对该线程进行调度，从而使该线程拥有能够获得CPU时间片的机会</p>
</li>
<li><p>运行状态:<br>•就绪态的线程获得cpu就进入运行态</p>
</li>
<li><p>等待/阻塞：<br>•线程运行过程中被剥夺资源或者，等待某些事件就进入等待/阻塞状态， suspend()方法被调用 ， sleep()方法被调用，线程使用wait()来等待条件变量;线程处于I/O等待等，调用suspend方法将线程的状态转换为挂起状态。这时，线程将释放占用的所有资源，但是并不释放锁，所以容易引发死锁，直至应用程序调用resume方法恢复线程运行。等待事件结束或者得到足够的资源就进入就绪态</p>
</li>
<li><p>死亡状态：<br>•当线程体运行结束或者调用线程对象的stop方法后线程将终止运行，由JVM收回线程占用的资源<br>•<br><img src="/2020/03/02/java/79.png" alt></p>
<h2 id="小结（清楚程序、进程、线程、生命周期）"><a href="#小结（清楚程序、进程、线程、生命周期）" class="headerlink" title="小结（清楚程序、进程、线程、生命周期）"></a>小结（清楚程序、进程、线程、生命周期）</h2></li>
<li><p><strong>进程是一个程序在其自身的地址空间中的一次执行活动。比如，打开一个记事本，就是调用了一个进程。进程是资源申请、调度和独立运行的单位，因此，它使用系统中的运行资源；而程序不能申请系统资源，一个程序可以对应多个进程，线程允许程序控制流的多重分支同时存在于一个进程</strong></p>
</li>
<li><p><strong>多线程优点：可以更好的实现并行，恰当地使用线程时，可以降低开发和维护的开销，并且能够提高复杂应用的性能。CPU在线程之间开关时的开销远比进程要少得多。因开关线程都在同一地址空间内，只需要修改线程控制表或队列，不涉及地址空间和其他工作。创建和撤销线程的开销较之进程要少</strong></p>
</li>
<li><p><strong>Java中线程存在以下几种状态：新建状态，就绪状态，运行状态，等待/阻塞状态，死亡状态</strong> </p>
</li>
</ul>
<h2 id="创建线程的步骤"><a href="#创建线程的步骤" class="headerlink" title="创建线程的步骤"></a>创建线程的步骤</h2><pre><code>1、创建线程
2、实例化线程对象
3、启动线程
4、终止线程</code></pre><h2 id="实现线程的方法"><a href="#实现线程的方法" class="headerlink" title="实现线程的方法"></a>实现线程的方法</h2><ul>
<li>对于Java而言，每一个独立的线程都是java.lang.Thread类的一个对象，而线程中独立于其他线程所执行的指令代码由Thread类的run方法提供 </li>
<li>因此，要想在Java中实现多线程协作运行，就需要创建多个独立的Thread类对象 </li>
<li>而线程与线程之间所执行的指令代码会存在差异，由此可见，Java中实现独立执行不同指令代码的多线程引用程序最简单直接的方法就是：继承Thread类重写run方法并构建其对象 </li>
</ul>
<h2 id="线程中需要执行的指令代码"><a href="#线程中需要执行的指令代码" class="headerlink" title="线程中需要执行的指令代码"></a>线程中需要执行的指令代码</h2><p><strong>注意</strong>：</p>
<ul>
<li><strong>需要注意run()方法的签名</strong></li>
<li><strong>run()方法中的代码和其他方法中的代码区别在于它可以和其他线程的run()方法代码并行执行</strong> </li>
<li><strong>初学者经常会有的一个误区是将线程和循环混淆，线程不具备任何循环特性，一旦run()方法代码执行结束，线程的生命周期即会自动结束，因此如果需要在线程中循环执行某些代码需要自行声明循环控制</strong></li>
</ul>
<p><img src="/2020/03/02/java/80.png" alt></p>
<p><img src="/2020/03/02/java/81.jpg" alt></p>
<h2 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h2><ul>
<li>直接继承Thread类实现线程的方法存在局限性：由于<strong>Java是典型的单亲继承体系</strong>，因此<strong>一旦类继承Thread之后就不能再继承其他父类</strong>，对于一些必须通过继承关系来传播的特性这种方式显然会造成困扰 </li>
<li>在上述情况下，可以通过实现java.lang.Runnable接口的方式来实现线程： </li>
<li><strong>Runnable中只有一个签名和Thread中一致的run()方法</strong>，满足函数式接口的要求，<strong>可以使用Lambda表达式</strong></li>
<li>Runnable接口的子类并不是线程类，我们只是通过这种形式向线程类提供run()方法指令代码，最后还需借助Thread类和Runnable接口的依赖关系和Thread类的<strong>Thread（Runnable runnable）构造方法构建线程对象</strong> <h2 id="线程启动与停止"><a href="#线程启动与停止" class="headerlink" title="线程启动与停止"></a>线程启动与停止</h2>•任何一个Java程序启动时，一个线程立刻运行，它执行main方法，这个线程称为程序的主线程；也就是说，任何Java程序都至少有一个线程，即<strong>主线程</strong><br>•主线程的特殊之处在于：<br>•它是产生其它线程子线程的线程；<br>•通常它必须最后结束，因为它要执行其它子线程的关闭工作。<br>•在主线程中启动其他线程，不能直接调用线程对象的run()方法（线程对象的run()方法可以显式调用，但在代码中显式调用run()方法不能产生并发调用的作用），而应该使用线程对象的<strong>start()方法</strong><br>•针对同一个线程对象，<strong>不能多次执行start()方法</strong>，否则会引发程序异常近况发生<br>•<strong>注意</strong>：<strong>start()方法的调用后并不是立即执行多线程代码，而是使该线程变为就绪状态，什么时候运行是由操作系统调度决定的</strong></li>
</ul>
<p>•线程的停止远比线程的启动情况复杂<br>•在Thread线程类中提供了<strong>stop()方法</strong>用于停止一个已经启动的线程，但是它<strong>已经被废弃，不建议使用，因为它本质上就是不安全的</strong>，它会解锁线程所有已经锁定的监视程序，在这个过程中会出现不确定性，导致这些监视程序监视的对象出现不一致的情况，或者引发死锁<br>•事实上在Java的多线程编程中，Thread类型包含了start(), stop(), stop(Throwable) and suspend(), destroy() and resume()等方法可以对线程进行操作，但是这些方法中，<strong>只有start()方法得到了保留</strong> </p>
<p>•那么应该如何安全的停止一个正在运行的线程呢？<br>•之前提到过，线程对象的run()方法所有代码执行完成后，线程会自然消亡，因此如果需要在运行过程提前停止线程，可以通过改变共享变量值的方法让run()方法执行结束<br><img src="/2020/03/02/java/82.png" alt></p>
<ul>
<li>如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？ </li>
<li>这种情况经常会发生，比如当一个线程由于需要等候资源、数据而调用Thread.sleep()方法、Object类的wait()方法等，都有可能导致线程阻塞，使线程处于处于不可运行状态时，即使主程序中将该线程的共享变量设置为false，但该线程此时根本无法检查循环标志，当然也就无法立即中断 </li>
<li>这里我们给出的建议是，使用Thread提供的interrupt()方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态，退出堵塞代码</li>
</ul>
<p><img src="/2020/03/02/java/83.png" alt></p>
<p>•在Thread类中有两个方法可以判断线程是否通过interrupt方法被终止。<br>•一个是静态的方法interrupted()<br>•一个是非静态的方法isInterrupted()<br>•这两个方法的区别是interrupted用来判断当前线程是否被中断，而isInterrupted可以用来判断其他线程是否被中断<br>•这里还存在几个问题需要大家注意：<br>•首先，需要区分捕获到的InterruptedException是否是由我们主动调用interrupt()方法所引起的，因为还有其他因素可能会导致此异常，而在某些时候即便是产生了此异常也应该能够让线程继续执行，这时候我们就需要编写代码来进行区分<br>•另一个不太好的消息是， <strong>interrupt()方法并不能阻断I/O阻塞或线程同步引起的线程阻塞</strong>，也就是说如果有一个线程在等待键盘输入或是等待网络连接等I/O资源，之前的停止方法就会失效<br>•那么我们应该如何处理由I/O资源引起的线程阻塞时的线程中断问题呢？<br>•答案是<strong>关闭底层I/O通道，人为引发异常</strong>从而进行共享变量重新赋值而跳出线程的run()方法<br>•一个好消息是由于nio支持非阻塞式的事件驱动读取操作，在这种模式下，不需要关闭底层资源即可通过interrupt()方法直接中断其等待操作<br>•具体内容将在介绍nio对应章节进行介绍</p>
<p><img src="/2020/03/02/java/84.png" alt></p>
<h2 id="状态切换图"><a href="#状态切换图" class="headerlink" title="状态切换图"></a>状态切换图</h2><p><img src="/2020/03/02/java/85.png" alt></p>
<h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>•Java中将线程划分为了两类： </p>
<ul>
<li>用户线程 (User Thread)</li>
<li>守护线程 (Daemon Thread)<br>所谓守护线程，是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因 此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止</li>
</ul>
<p>用户线程和守护线程两者几乎没有区别，唯一的不同之处就在于虚拟机的退出：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了<br><img src="/2020/03/02/java/86.png" alt><br>非守护线程时：虽然main线程结束，但还有其他非守护线程在运行，因此程序并没有被结束<br>守护线程时；所有的非守护线程结束，程序结束</p>
<h2 id="线程方法介绍"><a href="#线程方法介绍" class="headerlink" title="线程方法介绍"></a>线程方法介绍</h2><p>•每个线程可以存在一个给定的名字，线程名字除了Thread类的构造方法可以提供以外，也可以通过<strong>setName(String name)</strong>方法给定<br>•<strong>getName()</strong>方法可以获取特定线程的名字<br>•如果没有为线程显式提供名字，Java将按照thread-0，thread-1…thread-n的方式为线程提供默认的名字（由main方法启动的主线程名字为：main）<br><img src="/2020/03/02/java/87.png" alt><br>•Java线程可以有优先级的设定，高优先级的线程比低优先级的线程有更高的几率得到执行（注意是更高的几率，而不是优先级高的一定有优势，但是优先级在某一些线程调度方法中有特定的作用）<br>•Java线程的优先级是一个整数，其取值范围是1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）<br>•除了Thread.MIN_PRIORITY和Thread.MAX_PRIORITY外，Thread还提供了另一个常量Thread.NORM_PRIORITY（5），但是需要注意的是，通过对Thread类源码的解析，会发现事实上<strong>Java线程在没有明确指定的情况下，其优先级并不一定是NORM_PRIORITY，而是和父线程（创建本线程的线程）的优先级保持一致，main线程的优先级是NORM_PRIORITY</strong><br><img src="/2020/03/02/java/88.png" alt><br>•可以通过Thread类的setPriority()方法（该方法被final修饰，不能被子类重载）更改优先级。<br>•优先级<strong>不能超出1-10</strong>的取值范围，否则抛出IllegalArgumentException，建议使用Thread提供的三个<strong>优先级常量</strong>来确定线程优先级的高、常规和低取值<br>•另外如果该线程已经属于一个线程组（ThreadGroup），<strong>该线程的优先级不能超过该线程组的优先级</strong><br>•线程组是Java提供的一个线程统一管理工具，构建一个线程组对象后可以通过Thread类的对应版本构造方法将线程加入线程组，线程组提供了一些比较有用的方法，例如interrupt()方法可以中断线程组中的所有线程<br>•我们可以设定线程组的最大优先级，当创建属于该线程组的线程时该线程的优先级不能超过这个数，线程组最大优先级设定的注意事项：<br>•系统线程组的最大优先级默认为Thread.MAX_PRIORITY<br>•创建线程组的时候其最大优先级默认为父线程组（如果未指定父线程组，则其父线程组默认为当前线程所属线程组）的最大优先级<br>•可以通过setMaxPriority更改最大优先级，但无法超过父线程组的最大优先级<br>•setMaxPriority的问题：<br>•该方法只能更改本线程组及其子线程组（递归）的最大优先级<br>•但不能影响已经创建的直接或间接属于该线程组的线程的优先级，也就是说，即使目前有一个子线程的优先级比新设定的线程组优先级大，也不会更改该子线程的优先级。只有当试图改变子线程的优先级或者创建新的子线程的时候，线程组的最大优先级才起作用<br>•对于线程优先级，需要注意：<br>•<strong>Thread.setPriority()可能根本不做任何事情</strong>，操作系统和虚拟机版本有关<br>•线程优先级对于不同的线程调度器可能有不同的含义，例如优先级并不一定是指CPU的分享。在UNIX系统，优先级或多或少可以认为是CPU的分配，但Windows不是这样<br>•线程的优先级通常是全局的和局部的优先级设定的组合。Java的setPriority()方法只应用于局部的优先级。这通常是一种保护的方式，任何用户都不希望鼠标指针的线程或者处理音频数据的线程被其它随机的用户线程所抢占<br>•不同的系统有不同的线程优先级的取值范围，但是Java定义了10个级别（1-10）。这样就有可能出现几个线程在一个操作系统里有不同的优先级，在另外一个操作系统里却有相同的优先级，并因此可能有意想不到的不同行为<br><img src="/2020/03/02/java/89.png" alt><br>•线程可以通过调用特殊方法来<strong>放弃自己占据的部分资源</strong>，Thread类中的两个<strong>静态方法</strong>提供了这个功能： </p>
<ul>
<li>sleep()</li>
<li>yield()<br><img src="/2020/03/02/java/90.png" alt></li>
</ul>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h2><p>•使当前线程进入阻塞状态，所以执行sleep()的线程在指定的时间内肯定不会执行, 同时sleep方法不会释放锁资源（即如果正在运行的线程占有某个资源的同步锁，它<strong>不会释放掉这个同步锁</strong>，其他线程仍然不能访问该资源，详情参加下一节的线程同步）<br>•<strong>sleep()可使优先级低的线程得到执行的机会</strong>，当然也可以让同优先级和高优先级的线程有执行的机会<br>•sleep(）方法有两个版本：sleep(long millis)和sleep(long millis,int nanos)，第一个版本需要提供以毫秒为单位的阻塞时间，第二个版本在毫秒的基础上可以附加0-999999的纳秒值<br>•<strong>Java并不保证线程在阻塞给定的时间后能够马上执行</strong>（事实上这几乎是不可能的事情），在阻塞时间到了之后，线程进入就绪状态，继续执行的时机取决于Java虚拟机的线程调度机制，唯一能够确定的是，线程中断执行的时间是大于等于给定的阻塞时长的，<strong>因此不要将sleep用作精确度要求非常高的定时任务调度</strong><br><img src="/2020/03/02/java/91.png" alt></p>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><p>•yield() 方法只是<strong>使当前线程重新回到就绪可执行状态</strong>，所以执行yield()线程有可能在进入到就绪状态后马上又被执行，只能<strong>使相同或更高优先级的线程有执行的机会</strong><br>•同样, <strong>yield()也不会释放锁资源</strong><br>•sleep和yield的区别在于, sleep需要提供阻塞时长，可以使优先级低的线程得到执行的机会,  而yield由于使线程直接进入就绪状态，没有阻塞时长，而且只能使相同或更高优先级的线程有执行的机会，甚至于某些时候JVM认为不符合最优资源调度的情况下会忽略该方法的调用（类似于System.gc()）<br><img src="/2020/03/02/java/92.png" alt></p>
<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>•Thread类的join()方法用于等待其它线程结束，当前运行的线程可以调用另一线程的join方法，当前运行线程将转到阻塞状态，直至另一线程执行结束，它才会恢复运行，也就是说，t.join()方法阻塞调用此方法的线程(calling thread)，直到线程t完成，此线程再继续<br>•通常用于在main()主线程内，等待其它线程完成再结束main()主线程<br>•通过对源代码的解析发现join方法实现是通过wait。 当main线程调用t.join时候，main线程会获得线程对象t的锁,调用该对象的wait()，直到该对象唤醒main线程 ，比如退出后。这就意味着main 线程调用t.join时，必须能够拿到线程t对象的锁（下一节详细介绍同步锁）<br><img src="/2020/03/02/java/93.png" alt></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>•Java中希望创建线程可以使用两种方法：直接继承Thread类、实现Runnable接口，这两种方式都需要实现run()方法以提供线程中的指令代码。构建线程对象后使用start(）方法即可启动一个线程<br>•不能在同一个线程对象上多次调用start()方法<br>•run()方法执行结束后，线程会自然消亡，不建议使用线程类的stop等方法终止线程的执行，可以使用设置共享变量和调用interrupt()方法引发异常的方式终止线程<br>•sleep和yield的区别在于, sleep需要提供阻塞时长，可以使优先级低的线程得到执行的机会,  而yield由于使线程直接进入就绪状态，没有阻塞时长，而且只能使相同或更高优先级的线程有执行的机会，甚至于某些时候JVM认为不符合最优资源调度的情况下会忽略该方法的调用（类似于System.gc()）， Thread类的join()方法用于等待其它线程结束，当前运行的线程可以调用另一线程的join方法，当前运行线程将转到阻塞状态，直至另一线程执行结束，它才会恢复运行</p>
<h2 id="不线程同步产生的问题"><a href="#不线程同步产生的问题" class="headerlink" title="不线程同步产生的问题"></a>不线程同步产生的问题</h2><p>•同现实生活中的案例一样，程序中的线程安全的问题是微妙且出乎意料的，因为在没有进行充分同步（创建令牌锁定）的情况下，多线程中的各个操作的顺序是不可预测的，有时甚至令人惊讶。例如我们试图生成一个唯一整数值的序列的代码。如果在单一线程的环境中，它能够正确运行，但是在多线程环境中却不一定行：<br>•上述代码中的问题是，在一特殊的时序情况下，两个线程可以调用getNext并得到相同的返回值。<br>•自增操作value++可能看起来是一个单一的操作，但是事实上它分为3个独立的操作：</p>
<ul>
<li>读取这个值 </li>
<li>使之加1</li>
<li>再写入新值。 </li>
</ul>
<p>•因为这些操作发生在多个线程中，这些线程可能交替占有运行时,所以两个线程很可能同时读取这个值，两个线程都得到相同的值，并都使之增加了10结果就是不同的线程返回了相同的序列数<br><img src="/2020/03/02/java/94.png" alt><br>•上图描述了不同线程之间的交替操作，在这个图中，时间由左至右发展，每一行表现一个不同线程的活动。它用来描述最坏的情况，表现特定顺序下线程产生错误的僭越带来的危险</p>
<h2 id="出入栈不同步问题"><a href="#出入栈不同步问题" class="headerlink" title="出入栈不同步问题"></a>出入栈不同步问题</h2><p><img src="/2020/03/02/java/95.png" alt></p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>•如果需要将多条代码视作一个整体调度单元，希望这个调度单元在多线程环境中的调度顺序不影响任何结果，除了<strong>保证可见性、防止重排序改变语义</strong>之外，还要将该代码段进行<strong>原子保护</strong>，这种保护我们称为<strong>线程同步</strong>，其主要的作用是<strong>实现线程安全的类</strong><br>•Java中使用<strong>synchronized</strong>关键字来对操作进行同步处理<br>•在使用synchronized关键字之前，需要理解JVM中的几个规范：<br>• 在JVM中，每个对象和类在逻辑上都是和一个<strong>监视器</strong>相关联的，为了实现监视器的排他性监视能力（即保证资源只能同时被一个线程访问），JVM为每一个对象和类都关联一个<strong>锁</strong>，锁住了一个对象，就是获得对象相关联的监视器<br>•监视器即类似本节初提出的令牌概念，只有获取了令牌的线程才能操作资源，操作完成后将令牌释放，下一个线程才有重新获取令牌并进行资源操作的机会<br>•监视器就像一座建筑,它有一个很特别的房间,房间里有一些数据,而且在同一时间只能被一个线程占据,进入这个建筑叫做”进入监视器”,进入建筑中的那个特别的房间叫做”获得监视器”,占据房间叫做”持有监视器”,离开房间叫做”释放监视器”,离开建筑叫做”退出监视器”<br>•而一个锁就像一种任何时候只允许一个线程拥有的特权<br>•一个线程可以允许多次对同一对象上锁，对于每一个对象来说,Java虚拟机维护一个计数器,记录对象被加了多少次锁,没被锁的对象的计数器是0,线程每加锁一次,计数器就加1,每释放一次,计数器就减1.当计数器跳到0的时候,锁就被完全释放了<br>•java虚拟机中的一个线程在它到达监视区域开始处的时候请求一个锁，JAVA程序中每一个监视区域都和一个对象引用相关联<br>•Java中<strong>synchronized关键字获得对象锁，实现线程同步</strong><br>•synchronized会降低程序的性能<br>•实现同步有两种方法:</p>
<ul>
<li><strong>同步方法</strong> </li>
<li><strong>同步代码块</strong></li>
</ul>
<p><img src="/2020/03/02/java/96.png" alt></p>
<p>•临界区同步块：<br>•有时,你只是希望防止多个线程同时访问方法内部的部分代码而不是整个方法<br>•通过这种方式分离出来的代码被称为 “临界区” (critical section),它也使用synchronized关键字建立。<br>•这里, synchronized被用来指定某个对象,此对象的锁被用来对花括号内的代码进行同步控制<br>•临界区同步块可以适当降低同步整个方法带来的性能消耗<br>•<strong>synchronized（锁对象）{  同步方法内容 代码}</strong></p>
<p><img src="/2020/03/02/java/97.png" alt></p>
<p><strong>同步块使用同一个对象的监视器（this），因此当一个线程获取监视器锁定对象后，其他线程即便访问的是其他的同步方法，也需要排队等候锁</strong></p>
<p><img src="/2020/03/02/java/98.png" alt></p>
<p><strong>同步块使用不同对象的监视器，因此不同的线程调用不同方法时完全并发</strong></p>
<p><img src="/2020/03/02/java/99.png" alt></p>
<h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><p>•因为线程可以阻塞,并且对象可以具有同步控制方法,用以防止别的线程在锁还没有释放的时候就访问这个对象.所以就可能出现这种情况:<br>•<strong>某个线程在等待另一个线程</strong>,而<strong>后者又等待别的线程</strong>,这样一直下去,直到这个链条上的线程<strong>又在等待第一个线程释放锁</strong>.你将得到一个线程之间相互等待的连续循环,没有哪个线程能继续。这被称之为 “死锁”(deadlock)</p>
<pre><code>方法一
sychronized(o1){
    sychronized(o2){

    }
}
方法二
sychronized(o2){
    sychronized(o1){

    }
}</code></pre><p>方法一获取o1的锁标记，方法二获取了o2的锁标记<br>方法一等待方法二释放o2的锁标记<br>方法二等待方法一释放o1的锁标记<br>•死锁的形成是<strong>潜在的,不易发现的</strong><br>•如果你运行一个程序,而它马上就死锁了,你当时就能知道出了问题,并且可以跟踪下去，真正的问题在于,你的程序可能看起来工作良好,但是具有潜在的死锁危险。这时,死锁也可能发生,而事先却没有任何征兆,所以它会潜伏在你的程序里,直到客户发现它出乎意料的发生(并且你可能很难重现这个问题)。因此,在编写并发程序的时候,进行仔细的程序设计以防止死锁是一个关键部分 </p>
<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>•线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程也能够等待其他线程的信号<br>•例如，线程B可以等待线程A的一个信号，这个信号会通知线程B数据已经准备好了，一个比较典型的案例就是：</p>
<p><img src="/2020/03/02/java/100.png" alt></p>
<p>•线程human和hen必须获得指向同一个hasEggs共享实例的引用，以便进行通信。如果它们持有的引用指向不同的实例，那么彼此将不能检测到对方的信号。需要处理的数据可以存放在一个共享缓存区里<br>•上例这种循环轮询方式被称为<strong>忙等待</strong><br>•<strong>忙等待没有对运行等待线程的CPU进行有效的利用</strong>，除非平均等待时间非常短。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号</p>
<p>•Java有一个内建的等待机制来允许线程在等待信号的时候变为非运行状态。java.lang.Object 类定义了三个方法，wait()、notify()和notifyAll()来实现这个等待机制（由于Object类是Java继承树的根节点，因此所有的Java类都具备这三个方法，这三个方法都是final的）<br>•<strong>一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态，直到另一个线程调用了同一个对象的notify()/notifyAll()方法</strong><br>•为了调用wait()或者notify()，线程必须先获得那个对象的锁。也就是说，<strong>线程必须在同步块里调用wait()或者notify()</strong>，JVM是这么实现的，当你调用wait时候它首先要检查下当前线程是否是锁的拥有者，不是则抛出IllegalMonitorStateException </p>
<p><img src="/2020/03/02/java/101.png" alt></p>
<p>•当一个线程调用一个对象的notify()方法，<strong>正在等待该对象的所有线程中将有一个线程被唤醒并允许执行（这个将被唤醒的线程是随机的，不可以指定唤醒哪个线程）</strong>。同时也提供了一个<strong>notifyAll()</strong>方法来<strong>唤醒正在等待一个给定对象的所有线程</strong><br>•一旦线程调用了<strong>wait()</strong>方法，它就<strong>释放了所持有的监视器对象上的锁</strong>。这将允许其他线程也可以调用wait()或者notify()（这是wait方法和Thread类sleep方法的主要区别）<br>•wait()方法也具备有时间参数的重载版本，超时时间到了之后即使没有其他线程调用notify方法，线程也将唤醒（如果超时时间设置为0，则和无参版本wait方法功能保持一致）<br>•notify()和notifyAll()方法不会保存调用它们的方法，因为当这两个方法被调用时，有可能没有线程处于等待状态。通知信号过后便丢弃了。因此，如果一个线程先于被通知线程调用wait()前调用了notify()，等待的线程将错过这个信号<br>•这可能是也可能不是个问题。不过，在某些情况下，这可能使等待线程永远在等待，不再醒来，因为线程错过了唤醒信号。<br>•</p>
<h2 id="管道流-（知道，后面讲io说明）"><a href="#管道流-（知道，后面讲io说明）" class="headerlink" title="管道流  （知道，后面讲io说明）"></a>管道流  （知道，后面讲io说明）</h2><p>•Java中的Pipe管道输入流与Pipe管道输出流实现了类似管道的功能，用于不同线程之间的相互通信：<br>•Java在它的jdk文档中提到不要在一个线程中同时使用管道输入流和管道输出流，这可能会造成死锁</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>•sleep方法由Thread类提供，它不会释放线程锁，wait方法由Object类提供，这就意味着所有的Java类都具备wait方法，wait方法调用后会释放线程具备的锁，同一个对象的notify和notifyAll方法能够唤醒线程，wait方法和notify方法需要在同步块中调用 </p>
<h2 id="线程池的概念和作用"><a href="#线程池的概念和作用" class="headerlink" title="线程池的概念和作用"></a>线程池的概念和作用</h2><p>•在java中，如果每个请求到达就创建一个新线程，<strong>开销是相当大</strong>的<br>•在实际使用中，服务器在<strong>创建和销毁线程上花费的时间和消耗的系统资源都相当大</strong>，甚至可能要比在处理实际的用户请求的时间和资源要多的多。除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。如果在一个JVM里创建太多的线程，可能会使系统由于<strong>过度消耗内存或“切换过度”而导致系统资源不足</strong>。为了防止资源不足，服务器应用程序需要采取一些办法来限制任何给定时刻处理的请求数目，尽可能减少创建和销毁线程的次数，特别是一些资源耗费比较大的线程的创建和销毁，尽量利用已有对象来进行服务，这就是“池化资源”技术产生的原因<br>•<strong>线程池主要用来解决线程生命周期开销问题和资源不足问题</strong>。通过对多个任务重复使用线程，线程创建的开销就被分摊到了多个任务上了，而且由于在请求到达时线程已经存在，所以消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使用应用程序响应更快<br>•通过适当的调整线程中的<strong>线程数目可以防止出现资源不足的情况</strong><br>•当一个服务器接受到大量短小线程的请求时，使用线程池技术是非常合适的，它可以<strong>大大减少线程的创建和销毁次数，提高服务器的工作效率</strong></p>
<p>•一个比较简单的线程池至少应包含： </p>
<ul>
<li>线程池管理器<br>•创建、销毁并管理线程池，将工作线程放入线程池中 </li>
<li>工作线程<br>•一个可以循环执行任务的线程，在没有任务是进行等待 </li>
<li>任务列队<br>•提供一种缓冲机制，将没有处理的任务放在任务列队中 </li>
<li>任务接口<br>•每个任务必须实现的接口，主要用来规定任务的入口、任务执行完后的收尾工作、任务的执行状态等，工作线程通过该接口调度任务的执行 </li>
</ul>
<p><img src="/2020/03/02/java/102.png" alt><br><img src="/2020/03/02/java/103.png" alt><br><img src="/2020/03/02/java/104.png" alt></p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>现实生活中存在很多进行资源协调调度的工具<br>红绿灯可以方便的对资源（路口）的使用情况进行调度，确定哪些资源的使用者在某一特定时刻可以对资源进行消费，从而保障多线程共享资源的可用性<br>•<strong>信号量</strong>，有时被称为<strong>信号灯</strong>，是在<strong>多线程环境下使用的一种设施</strong>, 它负责<strong>协调各个线程</strong>, 以保证它们能够正确、合理的<strong>使用公共资源</strong><br>•一个计数信号量。从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个资源申请请求，然后再获取该许可。信号量提供一个方法添加一个许可，从而可能释放一个正在阻塞的获取者<br>•信号量对可用许可进行计数，并采取相应的行动。拿到信号量许可的线程可以进入代码，否则就等待。通过申请和释放方法获取和释放访问许可<br>•还有一个生活中的常见案例能够更好的诠释信号量的作用：<br>•厕所有5个坑，假如有10个人要上厕所，那么同时只能有多少个人去上厕所呢？同时只能有5个人能够占用，当5个人中 的任何一个人让开后，其中等待的另外5个人中又有一个人可以占用了。另外等待的5个人中可以是随机获得优先机会，也可以是按照先来后到的顺序获得机会</p>
<h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><p>•Java实现生产者消费者模型问题是研究多线程程序时绕不开的经典问题之一：<br>•它描述一块缓冲区作为仓库，生产者可以将产品放入仓库，消费者则可以从仓库中取走产品</p>
<p><img src="/2020/03/02/java/105.png" alt></p>
<p>•实际上，生产者消费者模式准确说应该是“生产者-消费者-仓储”模式，离开了仓储，生产者消费者模型就显得没有说服力了,对于此模型，应该明确一下几点：</p>
<ul>
<li>生产者仅仅在仓储未满时候生产，仓满则停止生产</li>
<li>消费者仅仅在仓储有产品时候才能消费，仓空则等待</li>
<li>当消费者发现仓储没产品可消费时候会通知生产者生产</li>
<li>生产者在生产出可消费产品时候，应该通知等待的消费者去消费</li>
</ul>
<p><img src="/2020/03/02/java/106.png" alt><br><img src="/2020/03/02/java/107.png" alt><br><img src="/2020/03/02/java/108.png" alt><br><img src="/2020/03/02/java/109.png" alt></p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>线程池主要用来解决线程生命周期开销问题和资源不足问题。通过对多个任务重复使用线程，线程创建的开销就被分摊到了多个任务上了，而且由于在请求到达时线程已经存在，所以消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使用应用程序响应更快 </li>
<li>信号量，有时被称为信号灯，是在多线程环境下使用的一种设施, 它负责协调各个线程, 以保证它们能够正确、合理的使用公共资源，一个计数信号量。从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个资源申请请求，然后再获取该许可。信号量提供一个方法添加一个许可，从而可能释放一个正在阻塞的获取者 </li>
<li>生产者-消费者模式描述一块缓冲区作为仓库，生产者可以将产品放入仓库，消费者则可以从仓库中取走产品</li>
</ul>
<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>•JDK5的异步框架基于Executor接口将任务提交和任务执行进行解耦，无需开发人员关注各类任务线程的实现，而是将后台异步执行的内容抽象为单个任务，ExecutorService和其各种功能强大的实现类提供了非常简便方式来提交任务并获取任务执行结果，封装了任务执行的全部过程</p>
<p><img src="/2020/03/02/java/110.png" alt><br>•引入的Executor框架的最大优点是把任务的提交和执行解耦，要执行任务的人只需把Task描述清楚，然后提交即可。这个Task是怎么被执行的，被谁执行的，什么时候执行的，提交的人就不用关心了。具体点讲，提交一个Callable对象给ExecutorService（如最常用的线程池ThreadPoolExecutor），将得到一个Future对象，调用Future对象的get方法等待执行结果就好了<br>•经过这样的封装，对于使用者来说，提交任务获取结果的过程大大简化，调用者直接从提交的地方就可以等待获取执行结果。而封装最大的效果是使得真正执行任务的线程们变得不为人知。<br>•有没有觉得这个场景似曾相识？我们工作中当老大的老大（且称作LD2）把一个任务交给我们老大（LD）的时候，到底是LD自己干，还是转过身来拉来一帮苦逼的兄弟加班加点干，那LD2是不管的。LD2只用把人描述清楚提及给LD，然后喝着咖啡等着收LD的report即可。等LD一封邮件非常优雅地报告LD2report结果时，实际操作中是码农A和码农B干了一个月，还是码农ABCDE加班干了一个礼拜，大多是不用体现的。这套机制的优点就是LD2找个合适的LD出来提交任务即可，接口友好有效，不用为具体怎么干费神费力<br><img src="/2020/03/02/java/111.png" alt><br>•Executor是一个<strong>可以提交可执行任务的工具</strong>，这个接口解耦了<strong>任务提交和执行细节</strong>（线程使用、调度等），Executor主要用来替代显示的创建和运行线程<br>•ExecutorService提供了异步的管理一个或多个线程终止、执行过程(Future)的方法<br>•Executors类提供了<strong>一系列工厂方法用于创建任务执行器</strong>，返回的任务执行器都实现了ExecutorService接口（绝大部分执行器完成了池化操作）<br>内置的常见工厂方法及生成的任务调度器特征</p>
<p><img src="/2020/03/02/java/112.png" alt><br><img src="/2020/03/02/java/113.png" alt></p>
<ul>
<li><strong>submit(Callable)</strong><br>•和方法submit(Runnable)比较类似，但是区别在于它们接收不同的参数类型。Callable的实例与Runnable的实例很类似，但是Callable的call()方法可以返回一个结果而方法Runnable.run()则不能返回结果<br>•Callable的返回值可以从方法submit(Callable)返回的Future对象中获取</li>
<li><strong>inVokeAny()</strong><br>•接收一个包含Callable对象的集合作为参数。调用该方法不会返回Future对象，而是返回集合中某个Callable对象的结果，而且无法保证调用之后返回的结果是集合中的哪个Callable结果，只知道它是这些Callable中的一个<br>•如果一个任务运行完毕或者抛出异常，方法会取消其它的Callable的执行<br><img src="/2020/03/02/java/114.png" alt><br><img src="/2020/03/02/java/115.png" alt><br><img src="/2020/03/02/java/116.png" alt><br><img src="/2020/03/02/java/117.png" alt></li>
<li><strong>invokeAll()</strong><br>•会调用存在于参数集合中的所有 Callable 对象，并且返回一个包含Future对象的集合，可以通过这个返回的集合来管理每个Callable的执行结果<br>•需要注意的是，任务有可能因为异常而导致运行结束，所以它可能并不是真的成功运行了。但是我们没有办法通过 Future 对象来了解到这个差异</li>
</ul>
<p>•当使用 ExecutorService 完毕之后，我们应该关闭它，这样才能保证线程不会继续保持运行状态<br>•举例来说，如果你的程序通过main() 方法启动，并且主线程退出了你的程序，如果你还有一个活动的 ExecutorService存在于程序中，那么程序将会继续保持运行状态。存在于ExecutorService中的活动线程会阻止Java虚拟机关闭<br>•为了关闭在 ExecutorService 中的线程，需要调用 shutdown() 方法。ExecutorService 并不会马上关闭，而是不再接收新的任务，一旦所有的线程结束执行当前任务，ExecutorServie才会真的关闭。所有在调用shutdown()方法之前提交到ExecutorService的任务都会执行<br>•如果希望立即关闭ExecutorService，可以调用shutdownNow()方法。它会尝试马上关闭所有正在执行的任务，并且跳过所有已经提交但是还没有运行的任务。但是对于正在执行的任务，是否能够成功关闭它是无法保证的，有可能他们真的被关闭掉了，也有可能它会壹直执行到任务结束<br><img src="/2020/03/02/java/118.png" alt></p>
<h2 id="Runnable与Callable"><a href="#Runnable与Callable" class="headerlink" title="Runnable与Callable"></a>Runnable与Callable</h2><p>•正如前面所说，JDK1.5的任务调度框架将需要异步指定的代码抽象成一个独立的任务，而这些任务就由Runnable与Callable两个接口来确定<br>•Runnable与Callable两个接口的区别在于：<br>•Runnable提供的任务方法为run，它不能返回任何的结果<br>•Callable接口提供的任务方法为call，它可以返回任务执行后的结果<br>•两个接口都符合函数式接口的标准</p>
<h2 id="lock锁"><a href="#lock锁" class="headerlink" title="lock锁"></a>lock锁</h2><p>•虽然我们现在已经可以理解同步代码块和同步方法的锁对象问题，但是我们并不能直接看到在哪里加了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5中提供了一个新的锁对象Lock（接口），提供了更为清晰的语义<br>•JDK5中有一个Lock的默认实现：ReentrantLock：<br>•可重入的独占锁。该对象与synchronized关键字有着相同的表现和更清晰的语义，而且还具有一些扩展的功能。可重入锁被最近的一个成功lock的线程占有（unlock后释放）。该类有一个重要特性体现在构造器上，构造器接受一个可选参数，是否是公平锁，默认是非公平锁<br>•公平锁：<br>•先来一定先排队，一定先获取锁<br>•非公平锁：<br>•不保证上述条件。非公平锁的吞吐量更高<br><img src="/2020/03/02/java/119.png" alt></p>
<p>•思考如果对每个方法提供不同Lock对象进行锁定会有什么结果？<br><img src="/2020/03/02/java/120.png" alt></p>
<p>锁不住 不是同一个对象</p>
<h2 id="ThreadLoal"><a href="#ThreadLoal" class="headerlink" title="ThreadLoal"></a>ThreadLoal</h2><p>•ThreadLocal的作用：<br>•ThreadLocal用来解决多线程程序的并发问题<br>•ThreadLocal并不是一个Thread,而是Thread的局部变量,当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,所以每个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本<br>•从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思 </p>
<p>•ThreadLocal类中的方法:<br>•void set(T value)<br>•将此线程局部变量的当前线程副本中的值设置为指定值<br>•void remove()<br>•移除此线程局部变量当前线程的值<br>•protected T initialValue()<br>•返回此线程局部变量的当前线程的“初始值”<br>•T get()<br>•返回此线程局部变量的当前线程副本中的值<br><img src="/2020/03/02/java/121.png" alt><br>•JDK5之后也给我们提供了信号量的默认实现：<br>•这个工具的用法和我们自己实现的信号量完全一致，大家可以将原来自己实现的信号量代码替换为JDK提供的默认实现</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Executor是一个可以提交可执行任务的工具，这个接口解耦了任务提交和执行细节（线程使用、调度等），Executor主要用来替代显示的创建和运行线程。Runnable和Callable都可以抽象任务供Executor框架执行，不同的是Runnable没有返回结果，Callable能够返回任务执行的结果<br>ThreadLocal用来解决多线程程序的并发问题，ThreadLocal并不是一个Thread,而是Thread的局部变量,当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,所以每个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本</p>
<h2 id="任务调度的类型"><a href="#任务调度的类型" class="headerlink" title="任务调度的类型"></a>任务调度的类型</h2><p><strong>最常见的任务调度类型<br>定时启动<br>循环执行</strong><br>•什么叫定时任务调度？<br>        规定一个时间<br>•    重复任务是在项目运行过程中通过控制时间间隔完成反复执行的任务（如自动化数据备份），重复任务调度需要注意的要点：任务间隔延迟时间起点有区别<br>•</p>
<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p>•Timer是Java最早提供的一个任务调度器，它可以支持定时任务和重复任务的调度<br>•Timer通过一个独立的线程通过wait/notify机制对所有的任务进行调度，但是用户无需关心内部的线程实现细节，仅需通过Timer类的相关调度方法即可实现任务的调度</p>
<p><img src="/2020/03/02/java/122.png" alt></p>
<p>•如果希望借助于Timer进行任务调度，必须要满足Timer对任务本身的抽象规定，从刚才的Timer调度方法列表中可以看出，所有的方法第一个共同的参数均为TimerTask的对象，用于声明需要调度的任务中需要执行的指令代码<br>TimerTask是一个抽象类，和Runnable接口一样，通过一个run()抽象方法来定义任务执行的内容（事实上run方法来源于Runnable接口，因为TimerTask是Runnable的子类），它还对Runnable接口做出了扩展，声明了两个典型的行为：</p>
<p><img src="/2020/03/02/java/123.png" alt></p>
<p><strong>由于每个Timer调度器对应单一的一个线程，因此一旦任何一个任务抛出了异常，调度器线程即会结束，其他任务无法继续执行</strong><br><img src="/2020/03/02/java/124.png" alt></p>
<p>•注意：由于Java的天性，并且在开发JDK的过程中要考虑到不同平台，而不同平台的线程调度机制是不同的，因此各种平台下JVM 的线程调度机制也是不一致的。从而<strong>Timer不能保证任务在所指定的时间内执行</strong>。另外由于TimerTask是实现Runnable接口的，在TimerTask被放进线程队列睡眠一段时间（wait）之后，当到了指定的该唤起该TimerTask时，由于执行的确切时机取决于JVM的调度策略和当前还有多少线程在等待CPU处理。因此就<strong>不能保证任务在所指定的时间内执行</strong>。通常在如下两种情况下导致任务延迟执行：<br>•有大量线程在等待执行<br>•GC机制的影响导致延迟</p>
<p>•JDK5之后在Executor任务调度框架中提供了并行化（池化）的任务调度执行机制来代替Timer和TimerTask的组合，由于实现了池化的并发处理，因此就<strong>不存在某个任务抛出异常后导致所有人物均不能执行的问题</strong> </p>
<p>替代工具是：<img src="/2020/03/02/java/125.png" alt></p>
<p>•由于它是一个ExecutorService的实现，因此它可以调度由Runnable或Callable抽象的两种任务 </p>
<p>Quartz任务调度<br>•Quartz是一个完全由java编写的开源任务调度框架。尽管Quartz框架整合了许多额外功能， 但就其简易形式看，它非常易用。简单地创建一个实现org.quartz.Job接口的java类。Job接口包含唯一的方法：<br><strong>public void execute(JobExecutionContext context) throws JobExecutionException;</strong><br>•在Job接口实现类里面，添加一些业务代码到execute()方法。一旦配置好Job实现类并设定好调度时间表，Quartz将密切注意剩余时间。当调度程序确定该是通知执行任务的时候，Quartz框架将调用Job实现类上的execute()方法并允许做它该做的事情。无需报告任何东西给调度器或调用任何特定的东西。仅仅执行任务和结束任务即可。如果配置你的作业在随后再次被调用，Quartz框架将在恰当的时间再次调用它<br>•而这个过程和Timer/TimerTask的搭配十分类似<br>•Quartz框架的核心是调度器。调度器负责管理Quartz应用运行时环境。调度器不是靠自己做所有的工作，而是依赖框架内一些非常重要的部件。Quartz不仅仅是线程和线程管理。为确保可伸缩性，Quartz采用了基于多线程的架构。启动时，框架初始化一套worker线程，这套线程被调度器用来执行预定的作业。这就是Quartz怎样能并发运行多个作业的原理。Quartz依赖一套松耦合的线程池管理部件来管理线程环境</p>
<h2 id="jar包导入"><a href="#jar包导入" class="headerlink" title="jar包导入"></a>jar包导入</h2><p>在项目下  1新建一个lib文件夹     2、添加三个jar文件  复制粘贴  3、选中三个jar文件 鼠标点击右键  Build path  —–Add to Build path  —–ok了 </p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p><strong>Timer是Java最早提供的一个任务调度器，它可以支持定时任务和重复任务的调度，如果希望借助于Timer进行任务调度，必须要满足Timer对任务本身的抽象规定，从刚才的Timer调度方法列表中可以看出，所有的方法第一个共同的参数均为TimerTask的对象，用于声明需要调度的任务中需要执行的指令代码</strong> </p>
</li>
<li><p><strong>一个Timer调度器的所有任务都运行在一个线程中，存在单个任务出现异常导致所有任务不能执行的隐患，而JDK5之后的ScheduledThreadPoolExecutor提供了并发任务调用，不存在这个隐患</strong></p>
</li>
<li><p><strong>Quartz是一个完全由java编写的开源任务调度框架</strong><br><img src="/2020/03/02/java/image126.png" alt><br><img src="/2020/03/02/java/image127.png" alt></p>
<h2 id="泛型概念"><a href="#泛型概念" class="headerlink" title="泛型概念"></a>泛型概念</h2></li>
<li><p>了解泛型与Object对象造型的优势</p>
</li>
<li><p>熟悉Java中类型擦除的特征与限制</p>
</li>
<li><p>掌握泛型类与泛型方法的实现方式 </p>
</li>
<li><p>泛型是JavaSE1.5的新特性，<strong>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数</strong>。这种参数类型可以用在类、接口和方法的创建中，分别称为<strong>泛型类、泛型接口、泛型方法</strong> </p>
</li>
<li><p>泛型会类型的“类型参数”，它们也被称为参数化类型（parameterizedtype）或参量多态（parametricpolymorphism）。其实泛型思想并不是Java最先引入的，C++中的模板就是一个早于运用泛型的例子，但是如果大家有过C++经验，请注意，<strong>Java泛型和C++模版有着较大的区别</strong>！</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2></li>
<li><p>Java语言引入泛型的好处是<strong>安全简单</strong>。可以将运行时类型相关错误提前到编译时错误</p>
</li>
<li><p>在JavaSE1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”（Java中的所有类型都是Object类的子类），“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。泛型的好处是在<strong>编译的时候检查类型安全</strong>，并且所有的强制转换都是自动和隐式的，<strong>提高代码的重用率</strong><br><img src="/2020/03/02/java/image128.png" alt></p>
</li>
<li><p>有了泛型之后，我们可以在编译阶段就发现异常的类型问题：<br><img src="/2020/03/02/java/image129.png" alt><br><img src="/2020/03/02/java/image130.png" alt></p>
<h2 id="编译器处理泛型"><a href="#编译器处理泛型" class="headerlink" title="编译器处理泛型"></a>编译器处理泛型</h2></li>
<li><p>通常情况下，一个编译器处理泛型有两种方式： </p>
</li>
<li><p>Codespecialization </p>
</li>
<li><p>在实例化一个泛型类或泛型方法时都产生一份新的目标代码（字节码or二进制代码）。例如，针对一个泛型list，可能需要针对string，integer，float产生三份目标代码 </p>
</li>
<li><p><strong>Codesharing</strong> </p>
</li>
<li><p><strong>对每个泛型类只生成唯一的一份目标代码；该泛型类的所有实例都映射到这份目标代码上，在需要的时候执行类型检查和类型转换</strong></p>
</li>
<li><p>C++中的模板（template）是典型的Codespecialization实现 </p>
</li>
<li><p>C++编译器会为每一个泛型类实例生成一份执行代码。执行代码中integerlist和stringlist是两种不同的类型。这样会导致代码膨胀（codebloat），需要程序员用技巧避免代码膨胀 </p>
</li>
<li><p>Codespecialization另外一个弊端是在引用类型系统中，浪费空间，因为引用类型集合中元素本质上都是一个指针。没必要为每个类型都产生一份执行代码。而这也是Java编译器中采用Codesharing方式处理泛型的主要原因</p>
</li>
</ul>
<ul>
<li><p>Java编译器通过Codesharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过<strong>类型擦除</strong>（typeerasue）实现的</p>
</li>
<li><p>类型擦除指的是通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器<strong>只为泛型类型生成一份字节码</strong>，并将其实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且在必要的时候添加类型检查和类型转换的方法 </p>
</li>
<li><p>类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码，类型擦除的主要过程如下： </p>
</li>
<li><p>将所有的泛型参数用其最左边界（最顶级的父类型）类型替换 移除所有的类型参数<br><img src="/2020/03/02/java/image131.png" alt><br><img src="/2020/03/02/java/image132.png" alt><br><img src="/2020/03/02/java/image133.png" alt><br><img src="/2020/03/02/java/image134.png" alt></p>
</li>
<li><p>第一个泛型类Comparable<A>擦除后A被替换为最左边界Object。Comparable<NumericValue>的类型参数NumericValue被擦除掉，但是这直接导致NumericValue没有实现接口Comparable的compareTo(Objectthat)方法，于是编译器充当好人，添加了一个<strong>桥接方法</strong><br>第二个示例中限定了类型参数的边界&lt;AextendsComparable<A>&gt;A，A必须为Comparable<A>的子类，按照类型擦除的过程，先讲所有的类型参数ti换为最左边界Comparable<A>，然后去掉参数类型A，得到最终的擦除后结果</A></A></A></NumericValue></A></p>
</li>
<li><p>正是由于类型擦除的隐蔽存在，直接导致了很多难以察觉的问题，例如无法利用同一泛型类的实例区分方法签名： </p>
</li>
<li><p>同理，如果定义了一个泛型一场类GenericException<T>，不能同时catch GenericException<Integer>和GenericException<String>，因为他们是相同的<br><img src="/2020/03/02/java/image135.png" alt></String></Integer></T></p>
</li>
</ul>
<p>//我们想要设计一个类，这个类可以存储任意数据类型，没有泛型怎么使用</p>
<ul>
<li><p><strong>虽然泛型实例不同，但是由于类型擦除后是同一字节码（typeerasure之后，就都是List了），因此不能用于区分方法签名</strong></p>
</li>
<li><p><strong>也正是由于Java中泛型使用类型擦除的原因，泛型类的静态变量是共享的</strong></p>
</li>
</ul>
<p><img src="/2020/03/02/java/image136.png" alt></p>
<ul>
<li><strong>泛型参数不同，但是共享类的静态成员</strong></li>
</ul>
<p><img src="/2020/03/02/java/image137.png" alt></p>
<ul>
<li><p>用另外一个示例也能说明类型擦除的这个问题： </p>
</li>
<li><p>代码中分别定义了一个接受String类型的List和一个接受Integer类型的List，按照正常的理解，泛型ArrayList<T>虽然是相同的，但是给它传了不同的类型参数，那么c1和2的类型应该是不同的。但是结果恰恰相反，由于类型擦除，运行程序发现二者的类型时相同的，都是List，而具体的类型参数信息String和Integer被擦除了。这就导致一个很麻烦的问题：<strong>在泛型代码内部，无法获得任何有关泛型参数类型的信息</strong><br><img src="/2020/03/02/java/image138.png" alt><br><img src="/2020/03/02/java/image139.png" alt></T></p>
</li>
<li><p><strong>所有泛型类的类型参数在编译时都会被擦除</strong>，虚拟机运行时中没有泛型，只有普通类和普通方法，从这一点上来说，Java中的泛型从某种程度上是一种语法糖 </p>
</li>
<li><p><strong>Java泛型不支持基本类型</strong>，即ArrayList<int>这样的代码是不允许的 </int></p>
</li>
<li><p>在泛型代码内部，无法获得任何有关泛型参数类型的信息，如果传入的类型参数为T，那么在泛型代码内部你不知道T有什么方法，属性，关于T的一切信息都丢失了 </p>
</li>
<li><p>创建泛型对象时请指明类型，让编译器尽早的做参数检查（请不要在新代码中使用原生态类型） </p>
</li>
<li><p>不要忽略编译器的警告信息，那意味着潜在的ClassCastException等着你 </p>
</li>
<li><p>Java的泛型类型不能用于new构建对象（也不能用于初始化数组）不清楚有没有无参构造</p>
</li>
</ul>
<p><img src="/2020/03/02/java/image140.png" alt></p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><ul>
<li>可以编写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用，下面是定义泛型方法的规则：</li>
<li>所有泛型方法声明都有<strong>一个类型参数声明部分</strong>（由尖括号分隔），该类型参数声明部分在<strong>方法返回类型之前</strong> </li>
<li>每一个类型参数声明部分包含<strong>一个或多个类型参数，参数间用逗号隔开</strong>。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符</li>
<li>类型参数能被用来<strong>声明返回值类型</strong>，并且能作为泛型方法得到的实际参数类型的占位符</li>
<li>泛型方法体的声明和其他方法一样。注意类型参数只能代表<strong>引用型类型</strong>，不能是原始类型（像int,double,char的等）</li>
</ul>
<p><img src="/2020/03/02/java/image141.png" alt><br><img src="/2020/03/02/java/image142.png" alt></p>
<ul>
<li>泛型类的声明和非泛型类的声明类似，除了在类名后面<strong>添加了类型参数声明部分</strong></li>
<li>和泛型方法一样，泛型类的类型参数声明部分也<strong>包含一个或多个类型参数</strong>，参数间用逗号隔开</li>
</ul>
<p><img src="/2020/03/02/java/image143.png" alt></p>
<ul>
<li>泛型接口的声明同泛型类的声明类似，在接口名之后，用尖括号将所有类型参数括起来：</li>
</ul>
<p><img src="/2020/03/02/java/image144.png" alt></p>
<ul>
<li>在泛型方法示例中我们已经看到了，泛型类型可以用于声明数组（不能用于初始化数组，此我们可以利用泛化数组来实现基础的集合工具 </li>
</ul>
<h2 id="数组协变"><a href="#数组协变" class="headerlink" title="数组协变"></a>数组协变</h2><ul>
<li>Java中数组的操作涉及泛型时有些特殊 </li>
<li>Java中的数组是<strong>协变</strong>的，下面的例子说明了什么叫协变（ </li>
</ul>
<p><img src="/2020/03/02/java/image145.png" alt><br><img src="/2020/03/02/java/image146.png" alt></p>
<ul>
<li><p>数组fruit  实例化之后每个元素应该都是苹果<br>第一个try块中，编译没有问题，运行出现异常 把水果父类对象存入到子类引用中<br>第二个try块中，编译没有问题，元素的本质是苹果，存储的是橘子  报错</p>
</li>
<li><p>上例中main方法中的第一行，创建了一个 Apple 数组并把它赋给 Fruit 数组的引用。这是有意义的，Apple 是 Fruit 的子类，一个 Apple 对象也是一种 Fruit 对象，所以一个 Apple 数组也是一种 Fruit 的数组。这称作<strong>数组的协变</strong>，Java 把数组设计为协变的，对此是有争议的，有人认为这是一种缺陷</p>
</li>
<li><p>尽管 Apple[] 可以 “向上转型” 为 Fruit[]，但数组元素的实际类型还是 Apple，我们只能向数组中放入 Apple或者 Apple 的子类。在上面的代码中，向数组中放入了 Fruit 对象和 Orange 对象。对于编译器来说，这是可以通过编译的，但是在运行时期，JVM 能够知道数组的实际类型是 Apple[]，所以当其它对象加入数组的时候就会抛出异常</p>
</li>
</ul>
<h2 id="泛型不支持协变"><a href="#泛型不支持协变" class="headerlink" title="泛型不支持协变"></a>泛型不支持协变</h2><ul>
<li>之前我们已经强调，泛型设计的目的之一是要使运行时期的类型相关错误在编译期就能发现，看看用泛型容器类来代替数组会发生什么（有关案例中提到的容器类型ArrayList将在集合内容详细讲解）：<br><img src="/2020/03/02/java/image147.png" alt></li>
<li>上面代码无法编译。当涉及到泛型时，尽管 Apple 是 Fruit 的子类型，但是 ArrayList<Apple> 不是 ArrayList<Fruit> 的子类型，<strong>泛型不支持协变</strong></Fruit></Apple></li>
</ul>
<h2 id="泛型向上造型"><a href="#泛型向上造型" class="headerlink" title="泛型向上造型"></a>泛型向上造型</h2><ul>
<li><p><strong>如果在泛型中确实需要建立这种 “向上转型” 的关系怎么办呢？这就需要通配符来发挥作用了</strong> </p>
</li>
<li><p><strong>利用 &lt;? extends Fruit&gt; 形式的上边界限定通配符，可以实现泛型的向上转型</strong><br><img src="/2020/03/02/java/image148.png" alt><br><img src="/2020/03/02/java/image149.png" alt></p>
</li>
<li><p>上面的例子中， flist 的类型是 List&lt;? extends Fruit&gt;，我们可以把它读作：一个类型的 List， 这个类型可以是继承了 Fruit 的某种类型。注意，这并不是说这个 List 可以持有 Fruit 的任意类型。通配符代表了一种特定的类型，它表示 “某种特定的类型，但是 flist 没有指定”。具体针对这个例子解释就是，flist 引用可以指向某个类型的 List，只要这个类型继承自 Fruit，可以是 Fruit 或者 Apple，比如例子中的 new ArrayList<Apple>，但是为了向上转型给 flist，flist 并不关心这个具体类型是什么</Apple></p>
</li>
<li><p>通配符 List&lt;? extends Fruit&gt; 表示某种特定类型 ( Fruit 或者其子类 ) 的 List，但是并不关心这个实际的类型到底是什么，反正是 Fruit 的子类型，Fruit 是它的上边界。那么对这样的一个 List 我们能做什么呢？其实如果我们不知道这个 List 到底持有什么类型，怎么可能安全的添加一个对象呢？在上面的代码中，向 flist 中添加任何对象，无论是 Apple 还是 Orange 甚至是 Fruit 对象，编译器都不允许，唯一可以添加的是 null。所以如果做了泛型的向上转型 (List&lt;? extends Fruit&gt; flist = new ArrayList<Apple>())，那么我们也就失去了向这个 List 添加任何对象的能力，即使是 Object 也不行</Apple></p>
</li>
<li><p>如果调用某个返回 Fruit 的方法，这是安全的。因为我们知道，在这个 List 中，不管它实际的类型到底是什么，但肯定能转型为 Fruit，所以编译器允许返回 Fruit </p>
</li>
<li><p>了解了通配符的作用和限制后，好像任何接受参数的方法我们都不能调用了。其实倒也不是，看下面的例子：<br><img src="/2020/03/02/java/image150.png" alt></p>
</li>
<li><p>上面的例子中，flist 的类型是List&lt;? extends Fruit&gt;，泛型参数使用了受限制的通配符，所以我们失去了向其中加入任何类型对象的例子，最后一行代码无法编译</p>
</li>
<li><p>但是 flist 却可以调用 contains 和 indexOf 方法，它们都接受了一个 Apple 对象做参数。如果查看 ArrayList 的源代码，可以发现 add() 接受一个泛型类型作为参数，但是 contains 和 indexOf 接受一个 Object 类型的参数，所以如果我们指定泛型参数为 &lt;? extends Fruit&gt; 时，add() 方法的参数变为 ? extends Fruit，编译器无法判断这个参数接受的到底是 Fruit 的哪种类型，所以它不会接受任何类型，然而，contains 和 indexOf 的类型是 Object，并没有涉及到通配符，所以编译器允许调用这两个方法。这意味着一切取决于泛型类的编写者来决定那些调用是 “安全” 的，并且用 Object 作为这些安全方法的参数。如果某些方法不允许类型参数是通配符时的调用，这些方法的参数应该用类型参数，比如 add(E e)<br><img src="/2020/03/02/java/image151.png" alt><br><img src="/2020/03/02/java/image152.png" alt></p>
<h2 id="super-T"><a href="#super-T" class="headerlink" title="? super T"></a>? super T</h2></li>
<li><p>通配符的另一个方向是　“超类型的通配符“: ? super T，T 是类型参数的下界。使用这种形式的通配符，我们就可以 ”传递对象” 了 </p>
</li>
<li><p>writeTo 方法的参数 apples 的类型是 List&lt;? super Apple&gt;，它表示某种类型的 List，这个类型是 Apple 的基类型。也就是说，我们不知道实际类型是什么，但是这个类型肯定是 Apple 的父类型。因此，我们可以知道向这个 List 添加一个 Apple 或者其子类型的对象是安全的，这些对象都可以向上转型为 Apple。但是我们不知道加入 Fruit 对象是否安全，因为那样会使得这个 List 添加跟 Apple 无关的类型<br><img src="/2020/03/02/java/image153.png" alt><br><img src="/2020/03/02/java/image154.png" alt></p>
</li>
<li><p>在了解了子类型边界和超类型边界之后，我们就可以知道如何向泛型类型中 “写入” ( 传递对象给方法参数) 以及如何从泛型类型中 “读取” ( 从方法中返回对象 。 </p>
</li>
<li><p>src 是原始数据的 List，因为要从这里面<strong>读取数据</strong>，所以用了<strong>上边界限定通配符</strong>：<strong>&lt;? extends T&gt;</strong>，取出的元素转型为 T。dest 是要<strong>写入</strong>的目标 List，所以用了<strong>下边界限定通配符</strong>：<strong>&lt;? super T&gt;</strong>，可以写入的元素类型是 T 及其子类型</p>
</li>
<li><p>还有一种通配符是无边界通配符，它的使用形式是一个单独的问号：List&lt;?&gt;，也就是没有任何限定</p>
</li>
<li><p>List&lt;?&gt; list 表示 list 是持有某种特定类型的 List，但是不知道具体是哪种类型。那么我们可以向其中添加对象吗？当然不可以，因为并不知道实际是哪种类型，所以不能添加任何类型，这是不安全的。而单独的 List list ，也就是没有传入泛型参数，表示这个 list 持有的元素的类型是 Object，因此可以添加任何类型的对象，只不过编译器会有警告信息</p>
</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>类对象：java.lang.Class</p>
<p>动物园看老虎，笼子前面有一个牌子进行品种的介绍 </p>
<ul>
<li>Java反射机制<strong>允许程序在运行时通过Reflection APIs取得任何一个已知名称的class的内部信息</strong>，包括其修饰符、父类、接口、构造方法、属性、方法等，并可于运行时改变属性值或者调用方法等； </li>
<li>Java反射机制是Java语言的一个重要特性，使得Java语言具备“动态性”： </li>
<li>在运行时获取任意一个对象所属的类的相关信息; </li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时获取任意一个类所具有的成员变量和方法；</li>
<li>在运行时调用任意一个对象的方法； </li>
<li>JAVA反射机制是构建框架技术的基础所在，例如后续学习的<strong>Spring框架</strong>等，都使用到反射技术； </li>
<li>Java的反射机制依靠反射API实现，反射API主要包括以下几个类，后续学习： </li>
<li>java.lang.Class类：代表一个类; </li>
<li>java.lang.reflect.Field 类：类的成员变量（成员变量也称为类的属性）; </li>
<li>java.lang.reflect.Method类：类的方法; </li>
<li>java.lang.reflect.Constructor 类：类的构造方法; </li>
<li>java.lang.reflect.Array类：动态创建数组，以及访问数组的元素的静态方法; </li>
</ul>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><ul>
<li>java.lang.Class类是反射机制中最重要的类，是使用反射机制时的“起点”； </li>
<li>JVM运行程序时，会将要使用到的类加载到内存中，同时就会自行为这个类创建一个Class对象，这个对象中就封装了类的所有信息，包括类中的属性、方法、构造方法、修饰符等； </li>
<li>Java.lang.Class类中定义了一系列的getXXX方法，可以获取Class中封装的其他信息； </li>
<li>Java.lang.Class类中定义了一系列的getXXX方法，可以获取Class中封装的其他信息；部分方法如下:<br><img src="/2020/03/02/java/image155.png" alt></li>
<li>java.lang.Class是使用反射的基础，那么获得Class对象就是重中之重，有三种方式可以得到Class对象：<br><img src="/2020/03/02/java/image156.png" alt></li>
</ul>
<p>创建Class对象<br><img src="/2020/03/02/java/image157.png" alt></p>
<ul>
<li><p>使用反射可以动态创建对象，Class类中定义了newInstance方法：<br><img src="/2020/03/02/java/image158.png" alt></p>
</li>
<li><p>反射API中定义了构造方法类Constructor，前面介绍过，使用Class类中方法可以获得Constructor对象，Constructor类中定义了如下方法可以构建类的对象：<br><img src="/2020/03/02/java/image159.png" alt><br><img src="/2020/03/02/java/image160.png" alt></p>
</li>
<li><p>Method类可以动态调用方法，并且可以返回方法相关的信息，Method类中的部分方法如下：<br><img src="/2020/03/02/java/image161.png" alt><br><img src="/2020/03/02/java/image162.png" alt></p>
</li>
</ul>
<p>动态调用java方法<br><img src="/2020/03/02/java/image163.png" alt></p>
<h2 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h2><ul>
<li><p>在实际编程中，我们常常需要一些用来包装值对象的类，例如Student、Employee、Order，这些类中往往没有业务方法，只是为了把需要处理的实体对象进行封装，有这样的特征： </p>
</li>
<li><p>属性都是私有的； </p>
</li>
<li><p>有无参的public构造方法； </p>
</li>
<li><p>对私有属性根据需要提供 公有的getXxx方法以及setXxx方法；例如属性名称为name,则有getName方法返回属性name值，setName方法设置name值；注意方法的名称通常是get或set加上属性名称，并把属性名称的首字母大写；这些方法称为getters/setters；getters必须有返回值没有方法参数；setter值没有返回值，有方法参数； </p>
</li>
<li><p>符合这些特征的类，被称为JavaBean； </p>
</li>
<li><p>内省（Inspector）机制就是基于反射的基础，Java语言对Bean类属性、事件的一种缺省处理方法。； </p>
</li>
<li><p>与Java内省有关的主要类及接口有： </p>
</li>
<li><p>java.beans.Introspector类: 为获得JavaBean属性、事件、方法提供了标准方法；通常使用其中的getBeanInfo方法返回BeanInfo对象； </p>
</li>
<li><p>Java.beans.BeanInfo接口：不能直接实例化，通常通过Introspector类返回该类型对象，提供了返回属性描述符对象（PropertyDescriptor）、方法描述符对象（MethodDescriptor） 、bean描述符（BeanDescriptor）对象的方法； </p>
</li>
<li><p>Java.beans.PropertyDescriptor类：用来描述一个属性，该属性有getter及setter方法； </p>
</li>
<li><p><strong>只要类中有getXXX方法，或者setXXX方法，或者同时有getXXX及setXXX方法，其中getXXX方法没有方法参数，有返回值；setXXX方法没有返回值，有一个方法参数；那么内省机制就认为XXX为一个属性</strong>； </p>
</li>
<li><p>可以使用PropertyDescriptor类的方法获取属性相关的信息，例如getName方法返回属性的名字： </p>
</li>
<li><p>//返回Employee类的BeanInfo对象</p>
</li>
<li><p>BeanInfo employeeInfo=Introspector.getBeanInfo(Employee.class);</p>
</li>
<li><p>//使用BeanInfo返回PropertyDescriptor对象数组</p>
</li>
<li><p>PropertyDescriptor[] propsDes=employeeInfo.getPropertyDescriptors();</p>
</li>
<li><p>//迭代所有的PropertyDescriptor，返回属性名字。由于从Object类继承getClass方法，所以属性名有class</p>
</li>
<li><p>for(PropertyDescriptor prop:propsDes){</p>
</li>
<li><p>System.out.println(prop.getName());</p>
</li>
<li><p>} </p>
</li>
</ul>
<p><img src="/2020/03/02/java/image164.png" alt></p>
<ul>
<li>很多框架都使用了内省机制检索对象的属性，定义属性名字时，名字最好起码以两个小写字母开头，例如stuName，而不要使用sName，某些情况下，可能会导致检索属性失败； </li>
<li>再次强调，内省机制检索属性时，是根据getter和setter方法确认属性名字，而不是根据类里声明的属性名决定；<br><img src="/2020/03/02/java/image165.png" alt><h2 id="注解的功能，了解常见JDK注解"><a href="#注解的功能，了解常见JDK注解" class="headerlink" title="注解的功能，了解常见JDK注解"></a>注解的功能，了解常见JDK注解</h2></li>
<li>定义：注解（Annotation），也叫元数据，是一种<strong>代码级别的说明</strong>。是Java 的JDK1.5版本开始引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、属性、方法、局部变量、方法参数等的前面，用来对这些元素进<strong>行说明，注释</strong>。 </li>
<li>作用分类：  </li>
<li>①编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】</li>
<li>② 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】</li>
<li>③编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】<br>很多框架技术的新版本中，都可以使用注解替代XML配置文件；</li>
</ul>
<h2 id="注解的声明形式如下："><a href="#注解的声明形式如下：" class="headerlink" title="注解的声明形式如下："></a>注解的声明形式如下：</h2><p>public @interface  注解名字 {<br>  注解属性<br>} </p>
<ul>
<li><p>声明注解类型MyAnnotation.java，如下所示： </p>
</li>
<li><p>public @interface MyAnnotation {</p>
</li>
<li></li>
<li><p>} </p>
</li>
<li><p>注解可以用于不同的目标，例如接口、类、构造方法、方法、属性、类型等； </p>
</li>
<li><p>声明注解时，可以使用JDK中已经定义的注解@Target声明注解修饰的目标； </p>
</li>
<li><p>@Target中使用枚举ElementType表示修饰目标，有如下几种修饰目标：<br><img src="/2020/03/02/java/image166.png" alt></p>
</li>
<li><p>修改MyAnnotation类为MyAnnotation2，添加@Target，指定修饰目标为TYPE，即类、接口、枚举等声明可用； </p>
</li>
<li><p>JDK中已经定义了注解@Retention，用来定义注解的声明周期； </p>
</li>
<li><p>@Retention使用枚举RetentionPolicy定义生命周期，共有三种情况：<br><img src="/2020/03/02/java/image167.png" alt></p>
</li>
<li><p>修改MyAnnotation2为MyAnnotation3，指定其生命周期为RUNTIME；<br><img src="/2020/03/02/java/image168.png" alt><br>注解属性看起来像个方法，其实是属性，属性类型包括所有基本类型、String、Class、enum、Annotation、以上类型的数组形式，注解元素声明形式如下：<br>public  String  urlpattern();<br>public  boolean    onload(); </p>
</li>
<li><p>修改注解类型MyAnnotation3.java为MyAnnotation4.java，添加2个属性，如下所示：<br><img src="/2020/03/02/java/image169.png" alt></p>
</li>
<li><p>注解中的属性在使用的时候可以指定值，也可以在声明的时候赋默认值； </p>
</li>
<li><p>例如，将MyAnnotation4改为MyAnnotation5，对onload属性赋默认值为false；<br><img src="/2020/03/02/java/image170.png" alt></p>
</li>
<li><p>使用注解非常简单，不管是JDK中内置的已经定义好的注解还是自定义的注解，只要使用  @注解名称（属性值列表）的形式，均可以使用； </p>
</li>
<li><p>LoginWebComponent中使用MyAnnotaion5，指定了urlpattern及onload属性值：<br><img src="/2020/03/02/java/image171.png" alt></p>
</li>
<li><p>Class类中定义了获取注解的方法： </p>
</li>
</ul>
<p><img src="/2020/03/02/java/image172.png" alt><br><img src="/2020/03/02/java/image173.png" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jinyeeeee.github.io/2020/03/02/java/" data-id="ck913fe9f000k80v0d0dvatsq"
         class="article-share-link">分享</a>
      
    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2020/03/02/js%E8%B0%83%E4%BC%98/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            js调优
          
        </div>
      </a>
    
    
      <a href="/2020/03/01/metasploit/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">metasploit</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
    </div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/technology.js"></script>

  </div>
</body>
</html>