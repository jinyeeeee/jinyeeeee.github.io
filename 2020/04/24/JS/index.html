<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    JS |
    
    yuchen</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/technology.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <section class="outer">
  <article id="post-JS" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JS
    </h1>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2020/04/24/JS/" class="article-date">
  <time datetime="2020-04-24T03:48:56.000Z" itemprop="datePublished">2020-04-24</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h1 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h1><h1 id="1简介"><a href="#1简介" class="headerlink" title="1简介"></a>1简介</h1><h2 id="1-1js简介"><a href="#1-1js简介" class="headerlink" title="1.1js简介"></a>1.1js简介</h2><h3 id="javascript的发展历程："><a href="#javascript的发展历程：" class="headerlink" title="javascript的发展历程："></a>javascript的发展历程：</h3><p>Netscape（网景）公司在开发出LiveScript脚本语言，当时的目的是在浏览器中使用该脚本操纵页面上的元素完成页面的特殊效果。<br>LiveScript后期由NetScape和Sun公司共同完成，而且LiveScript脚本语言遵照的一个基本原则就是尽可能的像java，后命名为javascript。<br>微软在IE 3.0 并搭载了一个 JavaScript 的克隆版，叫做 Jscript。<br>在ECMA（欧洲计算机制造商协会）的协调下，由Netscape、Sun、微软、Borland组成的工作组确定统一标准：ECMA-262，规范了脚本语言的定义及使用方式，并将遵循该规范的脚本语言称为ECMAScript 。</p>
<h3 id="javascript的使用场景"><a href="#javascript的使用场景" class="headerlink" title="javascript的使用场景"></a>javascript的使用场景</h3><p>嵌入动态文本于HTML页面，对浏览器事件做出响应。<br>读写HTML元素。<br>在数据被提交到服务器之前验证数据。<br>检测访客的浏览器信息。<br>控制cookies，包括创建和修改等。<br>基于Node.js技术进行服务器端编程。</p>
<h3 id="Javascript的基本特点："><a href="#Javascript的基本特点：" class="headerlink" title="Javascript的基本特点："></a>Javascript的基本特点：</h3><p>脚本语言：JavaScript是一种解释型的脚本语言,C、C++等语言先编译后执行,而JavaScript可以直接执行。<br>基于对象：JavaScript是一种基于对象的脚本语言,它不仅可以创建对象,也能使用现有的对象。（后面章节介绍）<br>简单:JavaScript语言中采用的是弱类型的变量类型,对使用的数据类型未做出严格的要求,是基于Java基本语句和控制的脚本语言,其设计简单紧凑。<br>跨平台：JavaScript只依赖于浏览器而与操作系统无关，目前JavaScript已被大多数的浏览器所支持。</p>
<h2 id="1-2web开发执行流程"><a href="#1-2web开发执行流程" class="headerlink" title="1.2web开发执行流程"></a>1.2web开发执行流程</h2><p>web服务器软件：一般指网站服务器，第三方计算机的程序，可解析http请求，并调用服务器程序完成http响应。<br><img src="/2020/04/24/JS/image524.png" alt></p>
<h3 id="浏览器端js执行基础组成："><a href="#浏览器端js执行基础组成：" class="headerlink" title="浏览器端js执行基础组成："></a>浏览器端js执行基础组成：</h3><p><strong>Js核心语法</strong>：包含js的数据类型、函数封装、内置对象与本地对象。<br>事件：事件是使用者对浏览器当前显示界面的操作，例如点击、鼠标移动、敲击键盘都是事件。<br><strong>DOM</strong>：文档对象模型（Document Object Model，简称DOM），现在可以简单的理解为浏览器供应商提供的操作页面元素的方式。Javascript并不能直接操作页面元素（例如拖拽等功能），但可以调用DOM完成。<br><strong>BOM</strong>： BOM(Browser Object Mode) 是指浏览器对象模型，是浏览器供应商提供的操作页面窗口的方式（例如打开新窗口、全屏显示等）。</p>
<h2 id="1-3js的引入方式"><a href="#1-3js的引入方式" class="headerlink" title="1.3js的引入方式"></a>1.3js的引入方式</h2><p>javascript语言如果直接编写在html文件上，浏览器将会将他的内容当作html代码执行，而不是javascript代码。常见的引入javascript的方式有三种：<br>内嵌javascript脚本<br>引入外部的javascript文件<br>在事件中编写javascript(不推荐)。<br>模块化引入（详见VUE章节）</p>
<pre><code>&lt;script&gt;
    alert(&quot;hello world!&quot;)
&lt;/script&gt;
&lt;script src=&quot;js/myjs.js&quot;&gt;&lt;/script&gt;
&lt;body&gt;
    &lt;button type=&quot;button&quot; onclick=&quot;alert(&apos;我爱你,中国!&apos;)&quot;&gt;按钮&lt;/button&gt;
&lt;/body&gt;</code></pre><h1 id="2变量和数据类型"><a href="#2变量和数据类型" class="headerlink" title="2变量和数据类型"></a>2变量和数据类型</h1><h2 id="2-1-语法概述"><a href="#2-1-语法概述" class="headerlink" title="2.1 语法概述"></a>2.1 语法概述</h2><p>语法：广义上是为了表述一个完整的含义，将词组有效组合的方式，人类的语法实际上是按照习惯传承下来，各种语言的语法都不相同。<br>计算机语言的语法：计算机不能直接识别人类的文字符号，只能识别二进制指令。各种高级、低级的语言都最终被翻译成二进制指令，被计算机执行。这些指令实际上是告诉计算机你要做什么。由于二进制指令很难被人理解和指令，因此科学家分析这些二进制指令后将这些指令翻译成人类可以识别的文字程序。例如 c c++、java、.net等、javascript。每一种语言都有特定的使用范围。</p>
<p>javascript是由如下几部分组成：<br>标示符：用户自定义的变量名、函数名等。<br>关键字：javascript的内置单词，每个关键字都代表某一个计算机操作。<br>操作符：+ - * % 等<br>注释：通过添加添加注释来对 JavaScript 进行解释。<br>转义字符：用一些普通字符的组合来代替一些特殊字符，由于其组合改变了原来字符表示的含义，因此称为“转义”<br>内置函数：浏览器供应商提供的函数，可以实现部分特定功能，如日期显示等等。<br>特殊符号：行代码分隔符; 代码块符号{}</p>
<h2 id="2-2基本语法规则"><a href="#2-2基本语法规则" class="headerlink" title="2.2基本语法规则"></a>2.2基本语法规则</h2><p>注释：编写在程序中作为程序的说明，以便于以后的参考、修改。在运行程序时不做处理。具备如下特点：<br>被注释的程序块不会执行.<br>注释可以提高代码的可读性，因此添加注释是编程的好习惯。<br>javascript的注释虽然不执行，但也会下载到客户端，因此在正式上线之前应使用其他工具去除掉全部的注释。<br>//单行注释<br>多行注释多行注释以 /* 开始，以 */ 结尾</p>
<p>关键字：目前在javascript语言中已经具有语法含义的英文词语，每个关键字都具有不同的使用场景和规则。<br><img src="/2020/04/24/JS/image525.png" alt><br>保留字：预计未来扩展javascript功能时会拓展的关键字。<br><img src="/2020/04/24/JS/image526.png" alt><br>标识符就是函数、变量的名字，由开发者自己起名。<br>命名规则：<br>不能使用javascript的关键字、保留字。<br>必须以字母、下划线（_）或美元符（$）开始。<br>后续的字符可以是字母、数字、下划线或美元符（数字是不允许作为首字符出现的。</p>
<h2 id="2-3变量"><a href="#2-3变量" class="headerlink" title="2.3变量"></a>2.3变量</h2><p>变量的概念：变量是存储信息的容器，变量可以根据变量名进行访问以及赋值。<br>var关键字：声明变量的关键字，如果在函数外部不使用var关键字，变量对应的内存地址将不会被浏览器回收，除非当前页面被关闭。<br>声明变量的方式</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    //声明变量
    var x;
    var x = 10;
    var x = 20,name = &quot;rose&quot;, age = 18;
&lt;/script&gt;</code></pre><p>修改变量的方式，var只在声明的时候被使用一次，修改变量的值直接使用变量的名字进行赋值。<br>变量重名规则：程序中要保证定义的多个变量不重名，如果重名并不像其他高级语言那样无法通过编译，而是采用如下规则：<br>如果两次变量的声明都对应赋值表达式，则后执行的变量会覆盖先执行的变量。<br>如果第一次变量的声明对应赋值表达式，第二次变量声明不对应赋值表达式，则第二次变量声明无效。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    //声明变量
    var x;
    var x = 10;
    var x = 20,name = &quot;rose&quot;, age = 18;

    var y = 100;
    var y;//声明无效
    var y = 200;//第二次赋覆盖第1次
    alert(y)
&lt;/script&gt;</code></pre><h2 id="2-4数据类型简介"><a href="#2-4数据类型简介" class="headerlink" title="2.4数据类型简介"></a>2.4数据类型简介</h2><p>数据类型: 变量值在内存中的存储方式。数据类型的主要作用是每一个类型对应的存储空间不同，从而更合理的使用内存。<br>数据类型分类：</p>
<ul>
<li>基本数据类型</li>
<li>对象类型</li>
</ul>
<p>基本数据类型：js引擎默认支持的数据类型，除了string类型外其余类型都占用固定内存空间，基本数据类型的数据存储在堆内存中（之后详解）。<br>基本数据类性的分类：</p>
<ul>
<li>undefined</li>
<li>null类型</li>
<li>boolean类型</li>
<li>number类型</li>
<li>string类型</li>
</ul>
<pre><code>var z;//udefined类型，变量里面没有存值，不知道类型
var b = true;//boolean类型的值
var i = 100;//number类型
var s = &quot;helloworld&quot;;//string字符串类型
null;//引用数据类型没有值，是对象类型的默认值，是js成立之初的一个错误，延续至今。</code></pre><p>对象数据类型：本质上是一组无序的名值对，存储在栈内存中，占用内存大小可以变化。<br>对象类型分类：<br>内置类型：如数组、日期类型。浏览器内置对象，可以直接使用。<br>用户自定类型：开发者自定义的对象。<br>对象类型、基本类型之间的区别：<br>定义方式不同<br>赋值方式不同<br>内存使用方式空间</p>
<h2 id="2-5typeof简介"><a href="#2-5typeof简介" class="headerlink" title="2.5typeof简介"></a>2.5typeof简介</h2><p>typeof：获取目标变量的数据类型，以字符串形式返回，typeof是系统内置函数<br>typeof的局限性：typeof只能区别出5个基本类型和对象类型，但无法识别对象类型的继承关系，以及对象类型赋值方式。</p>
<pre><code>var x;//undefined
x = 10;//number
x = true;//boolean
x = &quot;hello&quot;;//string
x = new Object();//object
alert(&quot;x的类型是&quot;+typeof(x));</code></pre><h2 id="2-6undefined类型"><a href="#2-6undefined类型" class="headerlink" title="2.6undefined类型"></a>2.6undefined类型</h2><p>只有变量，没有值。<br>undefined类型：是变量的默认赋值，表示”缺少值”，就是此处应该有一个值，但是还没有定义。<br>典型用法：<br>变量被声明了，但没有赋值时，就等于undefined。<br>调用函数时，应该提供的参数没有提供，该参数等于undefined。<br>函数没有返回值时，默认返回undefined。</p>
<pre><code>var x;//undefined</code></pre><h2 id="2-7null类型"><a href="#2-7null类型" class="headerlink" title="2.7null类型"></a>2.7null类型</h2><p>null类型：表示”没有对象”，即该处不应该有值。</p>
<p>null类型的特点：<br>undefined是null的衍生物，早期的null代表对象类型的数据为空。<br>null可以参与运算，在参与运算时js引擎会给null默认值。<br>null转为数值时为0。<br>undefined与null的区别：<br>含义不同：null代表不应该有值，undefined应该有值，但还没赋值。<br>null转为数值时为0；undefined转为数值时为NaN。</p>
<h2 id="2-8boolean类型"><a href="#2-8boolean类型" class="headerlink" title="2.8boolean类型"></a>2.8boolean类型</h2><p>值为true，或者false</p>
<h2 id="2-9number类型"><a href="#2-9number类型" class="headerlink" title="2.9number类型"></a>2.9number类型</h2><p>只要是数值就是number类型，不分整数和浮点数</p>
<pre><code>var a = 11;
var b = 11.5;</code></pre><p>number支持多进制赋值但最终还是以二进制存储</p>
<pre><code>var a = 11; //默认为十进制
var b = 010;//以0开头代表8进制，如080则仍以10进制解析
var c = 0xAF;//以0x开头代表16进制。
var d= 0b11;//以0b开头，是二进制</code></pre><p>number类型的浮点数表示方式</p>
<pre><code>var b = 0.1;
var c = .1;//可以省略0</code></pre><p>number类型转换<br>通过内置函数<br>parseInt(“…”):转成整数<br>parseFloat(“…”):转成浮点数<br>从字符串的第一个有效数字开始到第一个无效字符结束的内容进行数字转换。<br>对于无有效数字则返回NaN类型(Not A Number);<br>通过内置Number对象<br>Number(“11”)<br>number类型其他取值<br><strong>NaN：非数字。当执行parseInt无有效数字时返回</strong><br><strong>Infinity：无穷。当超过浮点类型最大范围时</strong></p>
<h2 id="2-10-string类型"><a href="#2-10-string类型" class="headerlink" title="2.10 string类型"></a>2.10 string类型</h2><p>string类型：字符串类型，可表示单个字符或多个字符的组合,采取可变内存的方式存储。<br>编写方式<br>义字符：用一些普通字符的组合来代替一些特殊字符<br>var s = “hello”;<br>var t = ‘world’;<br><img src="/2020/04/24/JS/image527.png" alt></p>
<h2 id="2-11对象类型"><a href="#2-11对象类型" class="headerlink" title="2.11对象类型"></a>2.11对象类型</h2><p>对象类型：或称引用类型，除了基本类型之外的都是引用类型或对象类型。</p>
<p>对象类型本质上是多个基础数据类型的数据封装。<br>与基础数据类型相比对象类型在内存存储结构、访问方式、声明方式都不同。</p>
<pre><code>var obj = {
    age:18,
    name:&quot;张三&quot;
};</code></pre><h1 id="3运算符"><a href="#3运算符" class="headerlink" title="3运算符"></a>3运算符</h1><p>运算符用于执行程序代码运算，会针对一个或一个以上操作数（数据类型）来进行运算。<br>位运算符：按照数值的二进制位进行运算。<br>算术运算符：完成基本的数学运算的符号，比如数字的处理使用到算术运算符号。<br>赋值运算符：它的作用是将一个表达式的值赋给一个变量。<br>比较运算符：比较数据的大小等使用的运算符。<br>逻辑运算符：用于连接boolean类型的表达式，计算最终逻辑值。<br>条件运算符：三目运算符。</p>
<h2 id="3-1算数运算"><a href="#3-1算数运算" class="headerlink" title="3.1算数运算"></a>3.1算数运算</h2><p>算数运算符：用于进行算术运算(arithmetic operators) 符号，就是用来处理四则运算的符号，一般用于数据的计算以及字符串的拼接。<br><img src="/2020/04/24/JS/image528.png" alt><br>%：结果的符号取决于左边数的符号</p>
<h2 id="3-2赋值运算"><a href="#3-2赋值运算" class="headerlink" title="3.2赋值运算"></a>3.2赋值运算</h2><p>赋值运算符用于给 JavaScript 变量赋值。<br><img src="/2020/04/24/JS/image529.png" alt></p>
<h2 id="3-3比较运算"><a href="#3-3比较运算" class="headerlink" title="3.3比较运算"></a>3.3比较运算</h2><p>比较运算符：&lt;、&gt;、&gt;=、&lt;=等操作符，用于对比数据的大小或编码。<br>可以连接非number、string类型的数据，但没有使用场景。<br>如果操作符两侧为number类型的数据，返回比较结果的boolean值。<br>如果一个操作数为字符另一个为number类型，则将字符转换为数字在做比较，返回比较结果的boolean值。<br>如果两个操作数都为字符，则比较首字母编码值，若相等比较第二个字母的编码值，以此类推。<br>==：123==”123”:true,只比较内容，不比较类型<br>===：123===”123”，既比较内容又比较类型</p>
<h2 id="3-4逻辑运算"><a href="#3-4逻辑运算" class="headerlink" title="3.4逻辑运算"></a>3.4逻辑运算</h2><p>逻辑运算符：逻辑运算符用于连接boolean类型的值或值为boolean类型的表达式，用于逻辑判断。<br><img src="/2020/04/24/JS/image530.png" alt><br>&amp;和&amp;&amp;的区别？</p>
<h2 id="3-5条件运算符"><a href="#3-5条件运算符" class="headerlink" title="3.5条件运算符"></a>3.5条件运算符</h2><p>条件运算符：条件运算符是一个三目运算符，用于连接三个变量或表达式，最终返回一个计算结果值。语法格式与java相同。<br><img src="/2020/04/24/JS/image531.png" alt></p>
<h2 id="3-6运算符的优先级"><a href="#3-6运算符的优先级" class="headerlink" title="3.6运算符的优先级"></a>3.6运算符的优先级</h2><p><img src="/2020/04/24/JS/image532.png" alt><br>有相同优先级的运算符按从左至右的顺序求值，但注意，这些顺序不需要特殊记忆，编程时对于优先级别不确定的，用（）来调节。</p>
<h2 id="3-7位运算"><a href="#3-7位运算" class="headerlink" title="3.7位运算"></a>3.7位运算</h2><p>&amp;  |  ^  ~  &gt;  &lt;   &gt;&gt;<br>有两个数，a =8 ，b=10，交换1个数的值。条件是：不声明第三个变量，交换2个数的值，至少使用2种方法。</p>
<h1 id="4流程控制语句"><a href="#4流程控制语句" class="headerlink" title="4流程控制语句"></a>4流程控制语句</h1><h2 id="4-1判断语句"><a href="#4-1判断语句" class="headerlink" title="4.1判断语句"></a>4.1判断语句</h2><p>if、else语句：是各门语言中都有的语句，也是最常用的语句。用来进行逻辑判断。常用的方式如下<br>  if 语句<br>  if…else 语句<br>  if…else if….else<br>if语句语法规范：</p>
<p>在javascript中对于条件表达式会默认使用Boolean类进行转换，例如if(undefined)会返回否。<br>只有当指定条件为 true 时，使用该语句来执行代码。<br>如果省略{}，则如果条件为true，则if语句下的第一行有效程序将会被执行，但为了程序的可读性和健壮性，要求必须加{}<br>为了阅读方便， 请遵照标准的缩进格式。</p>
<p>if…else if….else 语句 - 使用该语句来选择多个代码块之一来执行</p>
<h2 id="4-2-switch语句"><a href="#4-2-switch语句" class="headerlink" title="4.2 switch语句"></a>4.2 switch语句</h2><h2 id="4-3-do-while"><a href="#4-3-do-while" class="headerlink" title="4.3 do-while"></a>4.3 do-while</h2><h2 id="4-4-while"><a href="#4-4-while" class="headerlink" title="4.4 while"></a>4.4 while</h2><h2 id="4-5-for"><a href="#4-5-for" class="headerlink" title="4.5 for"></a>4.5 for</h2><p>for in，相当于java种的增强for循环。</p>
<pre><code>var arr=[1,2,3,4,5];
    for(a in arr){
    alert(a);//a是索引
}</code></pre><h1 id="5函数"><a href="#5函数" class="headerlink" title="5函数"></a>5函数</h1><h2 id="5-1函数的声明方式"><a href="#5-1函数的声明方式" class="headerlink" title="5.1函数的声明方式"></a>5.1函数的声明方式</h2><p>函数：一段包含应用程序的程序块，此程序块可以被其他程序通过函数名调用，目的是提高代码公用性、可维护性。<br>使用场景分析：<br><img src="/2020/04/24/JS/image533.png" alt><br><img src="/2020/04/24/JS/image534.png" alt><br>函数定义语法（一种方式）：<br><img src="/2020/04/24/JS/image535.png" alt><br>函数体内的程序在函数定义时并不执行，只有在调用函数并传递给有效的参数后才能执行函数体内的程序。<br>function:关键字，在定义函数时使用function来声明当前程序块为函数。function在因为使用场景不同，作用也不同。<br>functionname：函数的名称，在执行函数时，需要使用函数名调用函数中的程序块。<br>命名规则如下：<br>符合javascript标识符的命名规则。<br>首字母小写，多个单词组合时除首单词外，其余单词的首字母大写。<br>可以巧妙的使用缩写，例如rowNum表示行数。<br><strong>重名规则如果在一个网页中出现多个同名函数（不区分参数）,则最后定义的函数将覆盖之前的函数</strong><br>parameter：形式参数，在定义函数时，该参数并没有实际的数值，因此称为形式参数，形式参数为 0-多个，用逗号分开。函数体内可将形参作为变量使用。<br>函数调用时参数说明<br>js中调用函数时，实际传递的参数叫实参，实参的数量可以与形参的数量不同<br>也是可以计算。从第1个开始匹配的。没有被赋值的参数undefined，参与运算结果是NaN<br>如果给的实参的数量大于形参，正常执行。<br>在js函数内部，维护了一个arguments对象，专门用来存储参数，数组，arguments[0],arguments[1],arguments[2]。</p>
<pre><code>function add(a,b,c){
    return a+b+c;
    相当于return arguments[0]+arguments[1]+arguments[2];
}
function add1(){
   var sum = 0;
   for(a in arguments){
       sum += arguments[a];
   }
   return sum;
}
var sum1 = add1(10,20,30,40);
alert(sum1);</code></pre><p>在声明数组时，虽然参数可以任意变化的，但是我们在声明的时候，根据意义，有几个参数写几个参数，根据意义和数量，正确地调用。</p>
<p>return : 返回，函数执行后返回给调用程序的值，一般为执行结果，例如如下程序计算出1+2+。。N的值。<br>特殊说明<br>如果函数体内没有return，则js引擎会在函数体最后一句程序语句后执行return;代表返回一个undefined；<br>可以使用return跳出程序函数<br>不需要返回值类型，可以正常返回值，正常接收就可以。</p>
<p>定义函数的方式：<br>普通函数方式：</p>
<pre><code>function functionName(paramter) {}</code></pre><p>匿名函数：</p>
<pre><code>window.onload = function (paramter){}</code></pre><p>函数表达式：</p>
<pre><code>var f = function(paramter) {}</code></pre><p>Function对象：不建议使用，但可以帮助我们理解js的核心</p>
<pre><code>var b = new Function(&apos;a&apos;,&apos;b&apos;,&apos;return a+b&apos;);</code></pre><p>写一个函数，判断一个值是不是水仙花数。</p>
<pre><code>function functionname(value){
    //取出各个位上的数字
    //个位
    var ge = value%10;
    //十位
    var shi = parseInt(value/10%10);
    //百位
    var bai = parseInt(value/100);
    //alert(ge+&quot;:&quot;+shi+&quot;:&quot;+bai);
    if(value==ge*ge*ge +shi*shi*shi+bai*bai*bai){
        return true;
    }
    return false;
}
var result = functionname(168);
alert(result);</code></pre><h1 id="6面向对象编程"><a href="#6面向对象编程" class="headerlink" title="6面向对象编程"></a>6面向对象编程</h1><h2 id="6-1构造函数"><a href="#6-1构造函数" class="headerlink" title="6.1构造函数"></a>6.1构造函数</h2><p>理解JS对象实现的基础:<br>构造函数：函数的另外一种执行方式，执行后创建对象，并创建原型对象。<br>原型对象(prototype)：是函数对象（当且仅当函数对象）的一个内部属性，值是一个普通的对象，用户可以访问、操作该对象。<br>原型链(<strong>proto</strong>)：每个对象都具备的不可访问的内部属性（指针）（chrom等浏览器可以访问，但无法操作）,指针指向构造函数对应的原型对象。<br>Function函数：函数对象。<br>Object函数：所有创建对象的祖辈对象，也是由Function对象实现的。<br><img src="/2020/04/24/JS/image536.png" alt><br>构造函数：构造函数的声明方式与普通函数完全一致，但调用方式不同，返回的结果及内存结构也不同，执行构造函数将会返回一个该构造函数对应的对象。<br>构造函数的定义(与普通函数定义完全一致，但使用构造函数一般替代类，因此要符合java的规范)<br><img src="/2020/04/24/JS/image537.png" alt></p>
<h2 id="6-2原型链和原型对象"><a href="#6-2原型链和原型对象" class="headerlink" title="6.2原型链和原型对象"></a>6.2原型链和原型对象</h2><p>原型对象(prototype)：是函数对象（当且仅当函数对象）的一个内部属性，值是一个普通的对象，用户可以访问、操作该对象。<br>原型链(<strong>proto</strong>)：每个对象都具备的不可访问的内部属性（指针）（chrom等浏览器可以访问，但无法操作）,指针指向构造函数对应的原型对象。<br>原型链的特点：<br>原型链的终点是Object对象的prototype属性，该属性的<strong>proto</strong>为null，所有连接构成原型链。（稍后详解）<br>对象可以调用原型链上的所有属性以及函数。</p>
<p>原型链的作用：<br>使用原型链可以模拟类的功能。<br>使用原型链可以实现继承关系。<br>原型对象(prototype)的创建：<br>在预编译或执行匿名函数时，由js引擎调用new Function()创建函数对象，以及函数对象的prototype对象。只有函数对象才有prototype属性。<br>函数对象的本质就是一个变量，函数名是变量名，值为函数对象。</p>
<p>原型链指针(<strong>proto</strong>) 的特点：<br>不可访问性：在IE等浏览器中<strong>proto</strong>属性不可访问。<br>不可操作性：不能修改原型链指针的指向。<br>多元性：所有的对象类型（包含Function）都包含原型链指针。<br>连接性：对象的原型链指针默认指向构造函数的prototype对象，但prototype对象的<strong>proto</strong>也会作为原型链的一部分，直到连接到Object的prototype对象。<br>通用性：在原型链上所有prototype对象中的属性和函数，对象都可以访问和调用。</p>
<h2 id="6-3Object对象"><a href="#6-3Object对象" class="headerlink" title="6.3Object对象"></a>6.3Object对象</h2><p>Object函数：对象函数，是由Function实现的，原型链的最终端，是所有对象类型的父类。Object函数本质：Object就是用function实现的特殊构造函数。<br>创建对象的方式:<br>字面形式创建对象：</p>
<pre><code>//字面形式的创建对象
var obj = {
    name:&quot;jack&quot;,
    age:18,
    sayhello:function(){
        console.log(&quot;sayhello......&quot;);
    }
}
//调用属性和函数
console.log(obj.name);
console.log(obj.age);
obj.sayhello();</code></pre><p>构造函数的方式创建对象：</p>
<pre><code>//以构造函数的形式创建对象
var obj1 = new Object();
obj1.name = &quot;rose&quot;;
obj1.age = 20;
obj1.sayhello = function(){
    console.log(&quot;new Object()&quot;);
}
console.log(obj1.name);
console.log(obj1.age);
obj1.sayhello();
对象就是无序的名值对
key：对象的变量名。
value:变量实际值，可以为基本类型，对象类型（包含函数）。</code></pre><p>Object原型函数：在Object对象的prototype对象里封装的函数，这些函数可以被任何对象调用。<br>Obj.hasOwnProperty(‘field’)：判断某对象是否含有特定的自身属性。<br>Obj2.isPrototypeOf（obj1）：判断一个对象是否存在于另一个对象的原型链上。<br>obj.propertyIsEnumerable(‘field’)：判断一个对象的某一个属性是否是枚举类型的。<br>obj.toLocaleString()：将一个对象转换为本地字符串。<br>obj.toString()：将一个对象转换为字符串。<br>obj.valueOf()：返回对象的值，一般由js引擎、Function、Object级别函数调用，请不要覆盖、调用。</p>
<pre><code>//Object内部的方法子类可以直接使用
obj1.hasOwnProperty()
function Person(){

}
var p = new Person();
//p也可以调用该方法
p.hasOwnProperty()</code></pre><p>6.4Function对象<br>Function函数：函数对象，任何一个函数的定义最终都是生成了一个Function对象，Function是自省的（自己调用自己创建自己的）。<br><img src="/2020/04/24/JS/image538.png" alt><br>函数对象与函数体的区别<br>函数对象是无序属性的集合，不调用函数也会经过预编译，加载到内存中。<br>函数体是程序块，在调用时，由函数对象执行apply方法进行执行，执行时才会加载到内存，执行后会弹栈。</p>
<p>函数的全局属性与函数说明<br>arguments:参数数组，在函数调用后才会赋值，在函数体内也可以访问。 已经废弃<br>length：函数声明时的参数数量。<br>apply(this,arguments):执行函数体内容。<br>    –this：在函数体的中this指针。<br>    –arguments：传递给函数体的参数、数组。<br>call(this,paramter1，paramter2…):执行函数体内容。<br>    –this：在函数体的中this指针。<br>    –paramter：传递给函数体的参数。</p>
<h2 id="6-5对象的创建模式和继承"><a href="#6-5对象的创建模式和继承" class="headerlink" title="6.5对象的创建模式和继承"></a>6.5对象的创建模式和继承</h2><p>构造原型组合模式：使用构造函数和原型模式组合完成对象创建。构造函数完成基本属性的赋值，原型完成对象函数的绑定。</p>
<pre><code>//除了Object，其他的对象都要通过构造函数创建，通过构造函数创建的对象，会有原型对像
function Person(name,age){
    this.name = name;
    this.age = age;
    //this.say = function(){}
}
//函数通过原型对象来声明
Person.prototype.say = function(){
    console.log(this.name+&quot;今年&quot;+this.age+&quot;岁了。&quot;)
}
//创建对象
var p = new Person(&quot;jack&quot;,18);
p.say();</code></pre><p>寄生组合继承模式：<br>继承：继承是面向对象重要的特征。继承是指子类对象拥有父类对象的属性与方法，同时子类对象可以扩展、覆盖父类对象的属性和方法。<br><img src="/2020/04/24/JS/image539.png" alt><br>混合继承方式：通过构造函数、原型链共同完成继承。使用最多的方案。</p>
<pre><code>//实现继承，Student继承Person
function Student(name,age,schoolName){
    this.schoolName = schoolName;
    //super(name,age),但是js中没有super
    //要调用父类的构造函数
    Person.call(this,name,age);
}
//子类还可以有自己扩展的方法，gotoSchool
Student.prototype = new Person();
Student.prototype.goToSchool = function(){
    console.log(this.name+&quot;去&quot;+this.schoolName+&quot;上学了。&quot;);
}
//创建Student对象
var s = new Student(&quot;rose&quot;,19,&quot;北大&quot;);
s.say();
s.goToSchool();</code></pre><h2 id="6-6闭包"><a href="#6-6闭包" class="headerlink" title="6.6闭包"></a>6.6闭包</h2><p>闭包（ closure ）：闭包的目的是读取其他函数内部变量，由于正常函数执行后都会进行弹栈，从而不再保存临时变量，因此闭包会使函数的临时变量永久保存在内存中。<br>通过内部函数才能访问函数的变量，因此所有闭包的实现方式都是通过函数内部创建内部函数的方式实现。<br>闭包会导致函数执行过程中内存不会释放，要注意使用场景与频繁程度。<br>之前的解决响应函数代码就是一种闭包形式</p>
<pre><code>//在函数的内容声明函数，内部的函数使用外部函数的变量
function outer(){
    var x = 10;
    function inner(){
        alert(x);
    }
    inner();
}
//调用外部函数
outer();

function display(){
    var s = &quot;hello closure&quot;;
    function displayInner(){
        return s;
    }
    return displayInner();
}
//调用display
alert(display());</code></pre><h1 id="7本地以及内置对象"><a href="#7本地以及内置对象" class="headerlink" title="7本地以及内置对象"></a>7本地以及内置对象</h1><h2 id="7-1对象类型概述"><a href="#7-1对象类型概述" class="headerlink" title="7.1对象类型概述"></a>7.1对象类型概述</h2><p><img src="/2020/04/24/JS/image540.png" alt><br>宿主对象了解（之后再DOM、BOM章节详解）：<br>宿主：寄居在主人家。Javascript需要插入或运行在浏览器内，因此可以称js宿主在浏览器提供的环境内，浏览器是js的宿主环境。<br>宿主对象：由 ECMAScript 实现的宿主环境提供的对象。通俗的讲就是浏览器依据w3c制定的规范（DOM、htmlDOM）开发出来的对外接口，而这些接口是js对象（当然也要符合ECMAscript标准）。<br>宿主对象分类（简单理解）：<br>DOM：用于操作网页内元素的接口。<br>BOM：用于操作浏览器窗口的接口。</p>
<p>Js内置对象：“独立于宿主环境的 ECMAScript 对象”。<br>js内置对象就是浏览器开发商依据标准（ECMA-262）使用原生javascript开发的对象（function）<br>js内置对象与浏览器、网页上的元素无关。<br>js内置对象包含Object、Function、Array、String、Boolean、Number、Date、RexExp。<br>js内置对象在网页加载前就已经可以使用。<br>Js内置对象分类：<br>本地对象：javascript开发的引用类型，如String、Function、Boolean等等，这些引用类型都是function。<br>内置对象：已经被实例化的对象，如Math，内置对象都是Object。</p>
<h2 id="7-2Math对象"><a href="#7-2Math对象" class="headerlink" title="7.2Math对象"></a>7.2Math对象</h2><p>Math对象：该对象用来执行常见的数学运算。Math对象在网页加载时已经由js引擎创建Math的实例对象。<br>获取Math对象的方式</p>
<p>Math对象内置接口<br>Math的全局方法，例如Math.random();<br>Math的常量,例如Math.Pi;<br><img src="/2020/04/24/JS/image541.png" alt></p>
<pre><code>&lt;script&gt;
    console.log(Math.ceil(5.9));//6
    console.log(Math.floor(-9.7));//-10
    console.log(Math.max(10,4));//10
    console.log(Math.min(-8,34));//-8
    //产生随机数的[0,1),写一个[20,30)之间的随机数
    var v = parseInt(Math.random()*10+20);//[0,10)+20
    console.log(v);
&lt;/script&gt;</code></pre><h2 id="7-3基本类型的封装类型"><a href="#7-3基本类型的封装类型" class="headerlink" title="7.3基本类型的封装类型"></a>7.3基本类型的封装类型</h2><p>基本类型封装类型：js的内置对象，提供了对字符、数字、布尔三个基本类型的封装。封装类型中的属性和函数可以协助完成对基本类型数据的操作，例如截取字符串等。<br>String：字符类型的封装类型。<br>Number：数值类型的封装类型。<br>Boolean：布尔类型的封装类型。<br>初始化方式：</p>
<pre><code>var str = new String(&apos;aa&apos;);</code></pre><h3 id="7-3-1String类型常用api接口："><a href="#7-3-1String类型常用api接口：" class="headerlink" title="7.3.1String类型常用api接口："></a>7.3.1String类型常用api接口：</h3><p><img src="/2020/04/24/JS/image542.png" alt></p>
<pre><code>&lt;script&gt;
    //获取长度
    var s = &quot;I love you, China!&quot;;
    console.log(s.length);//18
    //返回某个位置的字符
    console.log(s.charAt(3));//o ,值从0开始
    //返回某个位置字符的编码
    console.log(s.charCodeAt(5));//101，e所对应的unicode编码中的值 a，97
    //返回字符串的一部分
    console.log(s.slice(3,8));//ove y，包括左边，不包括右边
    //求子串
    console.log(s.substring(3,8));//ove y，包括左边，不包括右边
    console.log(s.substr(3,8));//ove you,，第2个参数指长度，多少个字符
    //判断某个元素是否存在
    console.log(s.indexOf(&quot;love&quot;));//2，第一个字符出现的索引位置，第一次出现
    console.log(s.lastIndexOf(&quot;o&quot;));//8，最后一个o的索引位置
    //去掉两端的空格
    console.log(s.trim());//I love you, China!
    //大小写的转换
    console.log(s.toUpperCase());//I LOVE YOU, CHINA!
    console.log(s.toLowerCase());//i love you, china!
    var ss = &quot;name:zhangsan&quot;;
    var info = ss.split(&quot;:&quot;);
    for(i in info){
        console.log(info[i]);
    }
&lt;/script&gt;</code></pre><h3 id="7-3-2数组"><a href="#7-3-2数组" class="headerlink" title="7.3.2数组"></a>7.3.2数组</h3><p>Js数组与其他语言（例如java）的数组的相同点：<br>功能相同，都是存储介质。<br>操作相同，都是需要循环遍历数组的内容，同时都提供了修改数组数据的方式。<br>Js数组与其他语言（例如java）的数组的区别：<br>Js数组对象是由js编写的本地对象，而其他语言中的数组都是独立的数据类型。<br>Js数组的长度可变化。<br>Js数组存储的数据可以为不同数据类型。<br>Js数组由于是对象，因此可以为数组对象设定属性。</p>
<p>数组的初始化<br>数组初始化后可以设定长度，若没有赋值，则数组中的元素为undefined<br>如果访问数组的索引号大于数组长度，则出现程序异常。<br>通过数组的length属性可以访问数组的实际长度。<br>数组的内容可以为任意数据类型。</p>
<pre><code>//数组的声明
var arr1 = new Array();
console.log(arr1.length);
//java中，数组的长度为0，能不能写arr[0] F
arr1[0] = 1;
arr1[1] = 2;
console.log(arr1[0]);
console.log(arr1[1]);
console.log(&quot;------------------&quot;);
//声明长度
var arr2= new Array(10);
console.log(arr2.length);
console.log(arr2[1]);
arr2[5] = 10;
console.log(arr2[5]);
arr2[15]=100;//长度16
console.log(arr2.length);
console.log(&quot;------------------&quot;);
//直接给出元素
var arr3 = [1,2,&quot;hello&quot;,true];
console.log(arr3.length);
for(index in arr3){
    console.log(arr3[index]);
}</code></pre><h2 id="7-4-正则表达式"><a href="#7-4-正则表达式" class="headerlink" title="7.4 正则表达式"></a>7.4 正则表达式</h2><p>正则表达式：正则表达式使用一种有规则的字符串来检验目标字符串是否匹配。<br>用于检查目标字符串串是否包含某个小字符串、或将匹配的子串做替换或提取子字符串的位置。<br>正则表达式也是一串特殊的字符，转换为某种算法，根据这个算法来匹配文本。<br>正则表达式与js无关，但可以在js中调用。<br><img src="/2020/04/24/JS/image543.png" alt><br>正则表达式在web前端方向的使用场景：<br>数据验证：测试表单数据输入是否合法。<br>    –验证Email地址合法性<br>    –验证网址、电话号码、出生年月等输入信息的正确性。<br>    –验证用户名、密码的注册信息安全性。<br>替换文本：使用正则表达式来识别字符串中的特定字符，并且删除或替换特定字符，<br>    –删除目标字符串中的空格、tab等。<br>    –对特殊字符进行字符转换。<br>提取子字符串：使用正则表达式在目标字符串中提取子字符串，–网址中获取域名。</p>
<p>RegExp对象：用于执行或预编译正则表达式的对象。<br>实例化方式<br><img src="/2020/04/24/JS/image544.png" alt><br>flag说明：flag为字符类型，可以联合使用，取值如下。<br>i：对大小写不敏感的匹配。<br>g:对全局字符进行匹配。<br>m：对多行数据进行匹配。<br><img src="/2020/04/24/JS/image545.png" alt></p>
<pre><code>&lt;script&gt;
    //咏狗蚤函数创建对象,6位数字
    var reg = new RegExp(&quot;^[0-9]{6}$&quot;,&quot;i&quot;);

    console.log(reg.test(&quot;1234567&quot;));
    //wifi密码，8位以上，数字不能开头，数字，字母表示，8位以上,区分大小写
    var reg2 = /^[a-zA-Z]\w{7,}$/;
    console.log(reg2.test(&quot;w123abc88888&quot;));
&lt;/script&gt;</code></pre><h2 id="7-5Date日期对象"><a href="#7-5Date日期对象" class="headerlink" title="7.5Date日期对象"></a>7.5Date日期对象</h2><p>Date对象：提供用于处理日期和时间的属性及方法。使用时先获取该某一时刻的Date对象的引用，然后通过该引用获取详细的时间信息。<br>Date对象的内部组成：<br>构造函数：初始化Date对象实例的构造函数。<br>静态方法：不需要创建Date实例，直接使用Date调用的方法。<br>实例方法：Date对象可以直接调用的方法，又包含set、get两种不同的功能。<br><img src="/2020/04/24/JS/image546.png" alt><br>静态方法：静态方法不需要实例化就可以直接使用日期来调用，Date有两个主要的静态方法。<br>Number Date.now（）:返回系统当前时间的格林威治时间，类型为number.<br>Number Date.parse(‘2012/12/01 16:07:32’)<br>    –参数：代表时间的字符串，格式为yyyy/mm/dd hh:mm:ss。<br>    –返回参数所代表时间的格林威治时间，类型为number。</p>
<p>实例方法：Date的实例对象有三类方法。<br>以set开头的方法是为实例对象设定时间，<br>以get开头的方法为获取当前实例对象的时间，以下列出常用的实例方法。<br>其他方法：包含将日期对象转换为字符串，以及将字符串转换为时间的方法。</p>
<pre><code>&lt;script&gt;
    //获取当前日期距离1970年1月1日0时的毫秒值
    var now = Date.now();
    console.log(now);
    var d = Date.parse(&quot;2020/04/20 15:53:06&quot;);
    console.log(d);
    //通过当前毫秒值创建日期对象
    var date = new Date(now);
    console.log(date);
    //获取当前日期对象
    var date2 = new Date();
    console.log(date2)
    //获取年月日，时分秒，星期
    var year = date2.getFullYear();
    var month = date2.getMonth()+1;//0-11
    var day = date2.getDate();//日期
    var week = date2.getDay();//获取星期几
    var hour = date2.getHours();//小时
    var minute = date2.getMinutes();//分钟
    var s = date2.getSeconds();//秒
    console.log(year+&quot;-&quot;+month+&quot;-&quot;+day+&quot;   星期&quot;+week+&quot;  &quot;+hour+&quot;:&quot;+minute+&quot;:&quot;+s);
&lt;/script&gt;</code></pre><p><img src="/2020/04/24/JS/image547.png" alt><br><img src="/2020/04/24/JS/image548.png" alt><br><img src="/2020/04/24/JS/image549.png" alt></p>
<h1 id="8-DOM编程"><a href="#8-DOM编程" class="headerlink" title="8 DOM编程"></a>8 DOM编程</h1><h2 id="8-1DOM标准"><a href="#8-1DOM标准" class="headerlink" title="8.1DOM标准"></a>8.1DOM标准</h2><p>三个标准的意义以及关系：<br>CORE DOM接口中只声明了一般结构化文档的访问方式，包含对文档元素的增删改查等接口，html与xml也都是结构化的文档。<br>XML DOM接口中声明了用于操作XML元素的方式，比CORE DOM接口声明的接口更明确。<br>HTML DOM接口中声明了操作HTML元素的方式，CORE DOM接口只明确了一个类标签的操作方式，但HTML DOM确声明了每一个HTML标签的操作接口。<br>不同语言对三个标准的实现：<br>接口的实现与标准无关，但是接口的调用方式与返回方式与语言类型相关。<br>语言一般只实现部分接口（例如js中实现了DOM接口和HTMLDOM接口用来操作文档）</p>
<p>在网页中的DOM、HTML DOM：<br>遵照DOM接口、HTML DOM接口开发的操作网页（文档）元素的一组程序实现。<br>接口都是由浏览器实现的，也只能在浏览器中运行。<br>浏览器在加载时网页时将每一个网页元素都封装成了一个javascript对象，这个对象封装了在DOM、HTMLDOM规定的属性以及方法（只有IE有些区别）。<br>DOM与HTMLDOM的区别：<br>在DOM中每一个元素都是节点，都拥有相同的属性和方法。例如body、div。而HTML DOM为不同类型的网页元素封装了不同的方法和属性。<br>DOM接口在浏览器中兼容，而HTML DOM确不完全兼容。<br>与CSS类似，浏览器都扩充了私有的HTML DOM。</p>
<p>在网页开发中的DOM版本：<br>DOM1：W3C组织确定网页开发的标准由DOM核心与DOM HTML两个模块组成。<br>DOM2：DOM2通过对象接口增加了对鼠标和用户界面事件（DHTML长期支持鼠标与用户界面事件）、范围、遍历（重复执行DOM文档）和层叠样式表（CSS）的支持。<br>DOM3：包含一个名为“DOM载入与保存”的新模块，DOM核心扩展后可支持XML1.0的所有内容，包括XML Infoset、 XPath、和XML Base。<br>DOM扩展：在DOM3后（2008年后），部分浏览器增加了众多私有的DOM方法和属性，后被其他浏览器接纳。HTML5规范中也增加了对于DOM的新功能，后被浏览器接纳。不专属于DOM标准，但在高版本浏览器中兼容，称为DOM扩展。</p>
<h2 id="8-2DOM树与节点类型"><a href="#8-2DOM树与节点类型" class="headerlink" title="8.2DOM树与节点类型"></a>8.2DOM树与节点类型</h2><p><img src="/2020/04/24/JS/image550.png" alt><br>DOM对象的加载过程：<br>首先封装文档对象document<br>在解析html网页元素时，当检测到开始标签时，封装DOM元素，并将DOM元素挂在父节点上。<br>解析到结束标签时DOM元素与该元素子元素封装完毕。<br>网页的全部元素都转换为DOM对象后，只需要操作DOM对象就可以改变文档结构。<br>注意事项：<br>在html元素解析成DOM元素时，所有的回车、换行等都被封装为文本类型的DOM对象。<br>使用DOM对象要保证DOM对象加载完成后。</p>
<p>DOM对象的类型：在CORE DOM的接口中规定了在结构化的文档中有12个DOM类型，但很多都是应用于XML的，应用在html文档中的有效对象类型如下：<br>文档类型：文档全局对象document，封装了检索、创建文档元素的属性和方法。nodeType=9。<br>节点类型：也成为元素类型，封装了检索父子节点、操作当前节点的属性和方法，所有的html元素都是节点类型。nodeType=1。<br>文本类型：节点类型下的文字内容对象。nodeType=3。</p>
<p>OM对象的继承关系：浏览器都是通过继承关系来完成DOM元素的封装（不同浏览器有所不同），以下是chrome浏览器的继承关系。<br><img src="/2020/04/24/JS/image551.png" alt></p>
<h2 id="8-3DOM对象的属性与方法"><a href="#8-3DOM对象的属性与方法" class="headerlink" title="8.3DOM对象的属性与方法"></a>8.3DOM对象的属性与方法</h2><p>本章节包含Document以及HTMLDocuemnt的兼容属性以及方法，按照功能可分为如下几类：<br>访问文档子节点<br>访问文档基本元素节点<br>访问文档的特殊集合<br>创建元素、文本类型Dom对象</p>
<p>document访问HTML文档的基本元素：<br>document.documentElement：获取HTML标签的dom对象。<br>document.docType：获取HTML文档的文档头字符。<br>document.body：获取body的dom对象。<br>document.head：获取head标签的dom对象。<br>document.title：获取title的文字标题。</p>
<pre><code>//获取文档中所有的元素，相遇与一个完整的html页面的内容
var elements = document.documentElement;
console.log(elements);
//获取文档额doctype
var doctype = document.doctype;
console.log(doctype);//&lt;!DOCTYPE html&gt;
//获取body标签
var body = document.body;
console.log(body);
//获取head对象
var head = document.head;
console.log(head);
//获取title对象的文字标题
var title = document.title;
console.log(title);</code></pre><p><img src="/2020/04/24/JS/image552.png" alt><br>document访问文档内子节点的方式：<br>DomObj document.getElementById(‘id’):根据ID获取DOM对象，如果获取不到返回null。<br>HTMLCollection document.getElementsByTagName(‘tagName’):根据标签名（忽略大小写）获取全部该标签的对象。<br>HTMLCollection：DOM集合对象（非Array） 又称为伪数组<br>HTMLCollection document.getElementsByName(‘name’)</p>
<pre><code>//获取子元素
//通过id获取元素
var h1 = document.getElementById(&quot;header&quot;);
console.log(h1);
//通过class名获取，可以重复，HTMLCollection
var p = document.getElementsByClassName(&quot;desc&quot;);
console.log(p);
//通过标签名获取元素，可以重复HTMLCollection
var div = document.getElementsByTagName(&quot;div&quot;);
console.log(div);
//通过name获取,nodeList
var username = document.getElementsByName(&quot;username&quot;);
console.log(username);</code></pre><p><img src="/2020/04/24/JS/image553.png" alt><br>document对象封装了常用的网页元素集合，都是HTMLCollection类型的，都属于HTML DOM标准的实现，但在浏览器中完全兼容。<br>images：全部图片DOM对象集合。<br>anchors：全部带name属性的A标签DOM对象集合。<br>links：全部带href属性的A标签DOM对象集合。<br>forms：全部表单DOM对象集合。<br>Script：全部javascript标签DOM对象。</p>
<pre><code>&lt;body&gt;
    &lt;img src=&quot;img/1.webp&quot;&gt;&lt;br&gt;
    &lt;a name=&quot;top&quot;&gt;&lt;/a&gt;&lt;br/&gt;
    &lt;a href=&quot;http://www.baidu.com&quot;&gt;打开百度&lt;/a&gt;&lt;br&gt;
    &lt;form action=&quot;server&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;
        &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/br&gt;
        &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;script&gt;
    //获取所有的图片
    var imgs = document.images;
    console.log(imgs);
    //获取所有带有name属性的a标签
    var a_names = document.anchors;
    console.log(a_names);
    //获取带有href属性的a标签那
    var a_href = document.links;
    console.log(a_href);
    //获取所有的表单元素
    var forms = document.forms;
    console.log(forms);
    //获取script标签
    var my_scripts = document.scripts;
    console.log(my_scripts);
&lt;/script&gt;</code></pre><p><img src="/2020/04/24/JS/image554.png" alt></p>
<h3 id="8-3-1创建元素"><a href="#8-3-1创建元素" class="headerlink" title="8.3.1创建元素"></a>8.3.1创建元素</h3><p>document封装了用于创建元素类型、文本类型DOM对象的方法。<br>document.write(‘html’):根据参数内容重新更新文档内的内容。<br>document.createElement(‘tagname’)：根据标签名创建元素类型DOM对象，此DOM对象处于游离状态，没有挂接在DOM树上，无法显示。<br>document.createTextNode(‘content’)：根据内容创建文本类型DOM对象，此DOM对象处于游离状态，没有挂接在DOM数上，无法显示。</p>
<pre><code>&lt;script&gt;
    //直接更新文档
    document.write(&quot;html&quot;);
    document.write(&quot;&lt;p style=&apos;color:red&apos;&gt;段落标签&lt;/p&gt;&quot;);
    //创建元素,不显示，没有放在文档中
    var div = document.createElement(&quot;div&quot;);
    //创建文本节点,不显示，没有放在文档中
    var text = document.createTextNode(&quot;我爱你，中国！&quot;);
&lt;/script&gt;</code></pre><h3 id="8-3-2属性操作"><a href="#8-3-2属性操作" class="headerlink" title="8.3.2属性操作"></a>8.3.2属性操作</h3><p>Element对象封装了节点类型DOM对象特有的属性以及方法：<br>获取属性的方式：对于本元素已具备的属性可以使用obj.attName访问（不建议使用），对于私有属性按照规范要以data-开头</p>
<pre><code>obj.getAttribute(‘attName’)：获取当前节点指定属性的值。</code></pre><p>设定属性的方式：</p>
<pre><code>obj.setAttribute(‘attName’,’attValue’):设置当前节点指定属性的值。</code></pre><p>删除属性的方式：</p>
<pre><code>obj.removeAttribute(‘attName’):删除当前节点指定属性的值。

//通过name获取元素
var username =  document.getElementsByName(&quot;username&quot;);
//获取属性的值
var type = username[0].getAttribute(&quot;type&quot;);
console.log(type);
//设置属性
username[0].setAttribute(&quot;id&quot;,&quot;username&quot;);
console.log(username[0]);
//移除属性
//username[0].removeAttribute(&quot;id&quot;);
//console.log(username[0]);</code></pre><h3 id="8-3-3样式操作"><a href="#8-3-3样式操作" class="headerlink" title="8.3.3样式操作"></a>8.3.3样式操作</h3><p>HTMLElement对象封装了设定元素样式的方法，属于HTMLDOM范畴，但浏览器完全兼容：<br>设定或获取CSS属性的方式：</p>
<pre><code>obj.style.color = ‘red’：设置或获取当前元素的css属性值。cssAttribute取消了-，采用换字母大写的方式。</code></pre><p>设定或获取CSS样式类的方式：</p>
<pre><code>obj.className=“input-but”
//创建元素，设置属性
var div = document.createElement(&quot;div&quot;);
div.setAttribute(&quot;id&quot;,&quot;mydiv&quot;);
//设置样式 元素.style.属性名称=属性值;值一定要用”“引起来
//border-style:驼峰命名法 borderStyle
div.style.color = &quot;red&quot;;
var text = document.createTextNode(&quot;文本内容&quot;);
div.appendChild(text);
console.log(div);
&lt;style&gt;
    .myinput{
        width: 200px;
        height: 40px;
    }
&lt;/style&gt;
//为input设置样式
username[0].className = &quot;myinput&quot;;</code></pre><h3 id="8-3-4元素增删改操作"><a href="#8-3-4元素增删改操作" class="headerlink" title="8.3.4元素增删改操作"></a>8.3.4元素增删改操作</h3><p>Element对象封装了增加修改删除当前元素的方式：<br>增加元素到文档树的方式<br>parentObj.appendChild(obj):将指定元素挂接到父元素下。<br>parentObj.insertBefore(newObj,brotherObj):将指定元素挂接到某个兄弟元素之前。<br>修改元素的方式：</p>
<pre><code>parent.replaceChild(newObj,oldObj):替换指定元素的某一个子节点。</code></pre><p>删除元素的方式：</p>
<pre><code>parent.removeChild(obj):删除指定元素的某一个子元素。
&lt;body&gt;
    &lt;ul&gt;
        &lt;li class=&quot;bj&quot;&gt;北京&lt;/li&gt;
        &lt;li class=&quot;tj&quot;&gt;天津&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
&lt;script&gt;
    //获取ul
    var ul = document.getElementsByTagName(&quot;ul&quot;)[0];
    //创建一个&lt;li&gt;&lt;/li&gt;
    var li = document.createElement(&quot;li&quot;);
    //为li设置属性
    li.setAttribute(&quot;class&quot;,&quot;sh&quot;);
    //添加文本节点
    //var text = document.createTextNode(&quot;上海&quot;);
    //将文本内容添加到&lt;li&gt;&lt;/li&gt;
    //li.appendChild(text);
    //添加文本
    li.innerHTML=&quot;&lt;span style=&apos;color:red&apos;&gt;上海&lt;span&gt;&quot;;
    //li.innerText=&quot;&lt;span style=&apos;color:red&apos;&gt;上海&lt;span&gt;&quot;;
    //将li添加到ul
    //ul.appendChild(li);
    //兄弟元素
    ul.insertBefore(li,document.getElementsByClassName(&quot;tj&quot;)[0]);
    //移除元素，父元素移除
    ul.removeChild(document.getElementsByClassName(&quot;tj&quot;)[0]);
    //修改元素
    ul.replaceChild(li,document.getElementsByClassName(&quot;tj&quot;)[0]);
&lt;/script&gt;</code></pre><h3 id="8-3-5HTMLDOM属性和方法"><a href="#8-3-5HTMLDOM属性和方法" class="headerlink" title="8.3.5HTMLDOM属性和方法"></a>8.3.5HTMLDOM属性和方法</h3><p>Html属性：<br>innerHTML：设置或获取当前元素内的html，可以解析HTML标签。<br>innerText：设置或获取当前元素内的文字内容，不可以解析HTML标签，把标签当做普通文本处理。<br>outerHTML：获取元素的外部html。<br>获取大小的属性<br>offsetHeight/offsetWidth：获取用户可见的当前对象的高度和宽度，包含边线。<br>scrollHeight/scrollWidth:获取当前对象的实际宽度和高度，包含需要滚动的部分。<br>位置属性：<br>offsetParent：获取当前元素距离最近的使用相对定位获取绝对定位的祖元素。<br>offsetLeft/offsetTop:获取当前元素的左上角与其offsetParent的左上角的水平/垂直方向的偏移量。<br>由于HTMLDOM的API过于繁杂，建议其余模块查阅API文档进行开发，开发时注意兼容性。</p>
<h1 id="9-事件机制"><a href="#9-事件机制" class="headerlink" title="9 事件机制"></a>9 事件机制</h1><h2 id="9-1事件概述"><a href="#9-1事件概述" class="headerlink" title="9.1事件概述"></a>9.1事件概述</h2><p>事件：指用户在通过外部设备与浏览器发生的一些特定交互，这些交互会被浏览器所监听，监听后会调用用户声明的响应程序去处理本次交互。同时浏览器也会将本次交互的一些基本信息封装在一个独立的对象，用户在处理程序中可以调用这些对象。这种设定监听，并有监听者来调用目标程序的方式，在开发中又称为观察者模式。<br><img src="/2020/04/24/JS/image555.png" alt><br>事件中重要的知识点<br>事件流：事件触发的内部机制<br>事件的绑定方式：如何将不同类型的事件绑定给响应程序。<br>事件对象：由浏览器封装好的Object对象，对象中包含本次事件的基本信息（例如事件的目标、事件所在位置、事件类型等），以及一些事件的操作方法。<br>响应函数：在响应函数调用dom、事件对象完成业务逻辑开发（注意事项，只有在响应函数被加载后，在与浏览器进行交互，响应函数才能执行）。</p>
<h2 id="9-2事件流"><a href="#9-2事件流" class="headerlink" title="9.2事件流"></a>9.2事件流</h2><p>事件流：浏览器在执行事件处理程序的顺序。例如<br><img src="/2020/04/24/JS/image556.png" alt><br>冒泡方式：事件响应函数从最具体的元素开始执行，执行后向上层父节点传播。父节点的根节点为window对象<br><img src="/2020/04/24/JS/image557.png" alt><br>捕获方式：事件响应函数从最上层元素开始执行，执行后向下层子节点传播。Netscape浏览器早期流动方式。<br><img src="/2020/04/24/JS/image558.png" alt><br>DOM2中的事件流标准：先按照捕获流进行传播，后按照冒泡流进行传播。（所有浏览器都支持），但在事件绑定时要说明响应函数的事件流方式。<br><img src="/2020/04/24/JS/image559.png" alt></p>
<h2 id="9-3事件的绑定方式"><a href="#9-3事件的绑定方式" class="headerlink" title="9.3事件的绑定方式"></a>9.3事件的绑定方式</h2><p>事件的绑定方式：将对html元素或窗口的操作绑定给响应函数的方式。共四种<br>Html级别绑定<br>符合DOM0级的事件绑定方式<br>符合DOM2级的事件绑定方式</p>
<h3 id="9-3-1HTML级别的绑定"><a href="#9-3-1HTML级别的绑定" class="headerlink" title="9.3.1HTML级别的绑定"></a>9.3.1HTML级别的绑定</h3><p>Html级别绑定：在html中内嵌js程序。最早期的事件绑定方式，不符合DOM标准。绑定的程序会被浏览器以eval的方式执行。<br>特点:<br>HTML代码域JavaScript代码紧密的耦合在一起，没有实现相互分离。<br>如果事件程序是一个函数，要保证在html执行并显示该组件时，函数已经经过预处理加载到内存。<br>不符合DOM标准，无法设定事件流。</p>
<pre><code>&lt;body&gt;
    &lt;input type=&quot;button&quot; value=&quot;按钮1&quot; onclick=&quot;func1()&quot;&gt;&lt;br /&gt;
&lt;/body&gt;
&lt;script&gt;
    function func1(){
        alert(&quot;您点击了按钮1。。。。。&quot;)
    }
&lt;/script&gt;</code></pre><h3 id="9-3-2-DOMO级别的绑定"><a href="#9-3-2-DOMO级别的绑定" class="headerlink" title="9.3.2 DOMO级别的绑定"></a>9.3.2 DOMO级别的绑定</h3><p>DOM0级的事件绑定方式：将响应程序直接赋值给dom元素的事件属性。这是DOM最早版本规定的事件绑定方式。被所有浏览器兼容。特点:<br>可以使用匿名函数或普通函数作为响应程序。<br>在响应函数中this代表目标元素。<br>不符合DOM2标准，无法设定事件流。<br>无法传递参数，但可以通过其他方式传递<br>对同一个事件只能绑定一个响应函数，最后绑定的的响应函数将会执行。<br>通过obj.onXXXX = null可以解除绑定。</p>
<pre><code>&lt;input type=&quot;button&quot; value=&quot;按钮2&quot; id=&quot;btn2&quot;&gt;
&lt;script&gt;    
    //为按钮2绑定
    document.getElementById(&quot;btn2&quot;).onclick = function(){
        alert(&quot;您点击了按钮2&quot;);
    }
&lt;/script&gt;</code></pre><h3 id="9-3-3DOM2级别的绑定"><a href="#9-3-3DOM2级别的绑定" class="headerlink" title="9.3.3DOM2级别的绑定"></a>9.3.3DOM2级别的绑定</h3><p>DOM2级的事件绑定方式：符合DOM2的规定，绑定后可以设定事件流的顺序</p>
<pre><code>domObj.addEventListener(eventType,fun,eventFlow);</code></pre><p>–domObj:dom对象。<br>–eventType:事件类型，例如click（注意省略on），字符类型。<br>–fun：响应函数，可以为匿名函数，但使用匿名函数无法解除绑定，function类型，在目标函数中this指向当前dom对象。<br>–eventFlow:设定事件流。默认值false。true冒泡false捕获。</p>
<pre><code>//第三个采参数，代表事件，true捕获，从父到子，如果是false，冒泡，从子到父
//为body添加事件
document.body.addEventListener(&quot;click&quot;,function(){
    alert(&quot;您点击了body&quot;);
},true);</code></pre><p>事件的解除绑定方式：</p>
<pre><code>domObj.remove EventListener( eventType,fun,eventFlow);</code></pre><p>–domObj:dom对象。<br>–eventType:事件类型，例如click（注意省略on），字符类型。<br>–fun：响应函数，只能解除绑定非匿名函数。<br>–eventFlow:设定事件流,跟绑定时对应。</p>
<pre><code>//通过dom2,可以考虑事件流的影响
document.getElementsByClassName(&quot;div2&quot;)[0].addEventListener(&quot;click&quot;,fun,true);
function fun(){
    alert(&quot;您点击了div2&quot;);
}
//解除绑定        document.getElementsByClassName(&quot;div2&quot;)[0].removeEventListener(&quot;click&quot;,fun,true);</code></pre><h2 id="9-4事件对象"><a href="#9-4事件对象" class="headerlink" title="9.4事件对象"></a>9.4事件对象</h2><h3 id="9-4-1事件对象的方法"><a href="#9-4-1事件对象的方法" class="headerlink" title="9.4.1事件对象的方法"></a>9.4.1事件对象的方法</h3><p>事件对象：在执行响应函数前由浏览器创建的对象，该对象封装了本次事件的基本信息以及处理事件流的方法。<br>阻止冒泡及捕获的属性以及方法。<br>bubbles：获取绑定的事件的方式是否设定了冒泡或捕获（只有使用DOM2级绑定方式是返回true）。Boolean类型<br>stopPropagation()：在bubbles为true时，阻止继续冒泡或捕获。<br>stopImmediatePropagation()：强制阻止冒泡或捕获。</p>
<pre><code>&lt;body&gt;
    &lt;div class=&quot;div1&quot;&gt;
        &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;style&gt;
        .div1{
            width: 200px;
            height: 200px;
            background-color: yellow;
        }
        .div2{
            width: 100px;
            height: 100px;
            background-color: red;
        }
&lt;/style&gt;</code></pre><p><a href="./JS/20200421/06-事件流.html">点击查看效果</a></p>
<p>分别为body，div1，和div2添加点击监听</p>
<pre><code>//第三个采参数，代表事件，true捕获，从父到子，如果是false，冒泡，从子到父
//为body添加事件
//在每一个事件中，都 默认有一个对象，代表事件对象，可以直接使用
document.body.addEventListener(&quot;click&quot;, function(e) {
    alert(&quot;您点击了body&quot;);
}, true);
//为div1添加事件
document.getElementsByClassName(&quot;div1&quot;)[0].addEventListener(&quot;click&quot;, function() {
    alert(&quot;您点击了div1&quot;)
}, true);
document.getElementsByClassName(&quot;div2&quot;)[0].addEventListener(&quot;click&quot;, function(e) {
    alert(&quot;您点击了div2&quot;);
}, true);</code></pre><p>True代表事件流为捕获，当点击div2时，先显示点击了body，再显示点击了div1，最后显示点击了div2<br>阻止事件的传播，在body的点击事件内，添加阻止的代码，这样div1,和div2就不会响应事件了。</p>
<pre><code>document.body.addEventListener(&quot;click&quot;, function(e) {
    alert(&quot;您点击了body&quot;);
    //e代表事件对象
    alert(e.bubbles);
    e.stopPropagation();//阻止传播，不管用
    e.stopImmediatePropagation();//强制阻止
}, true);</code></pre><p><a href="./JS/20200421/07-阻止事件的传播.html">点击查看效果</a><br>阻止默认行为的属性以及方法（默认行为：某些元素在用户操作时，在不调用任何程序的情况下，也会发生具体行为，例如input type=submit在点击时会提交整个form表单）<br>defaultPrevented：获取是否阻止了默认行为，boolean类型。<br>preventDefault():阻止默认行为。</p>
<pre><code>&lt;body&gt;
    &lt;form class=&quot;form&quot; action=&quot;server.html&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;span&gt;&lt;/span&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;script&gt;
//当我们点击提交按钮时，会触发表单的提交事件，这也是提交按钮的默认行为
    document.getElementsByClassName(&quot;form&quot;)[0].onsubmit = function(){
         //获取username的值，
         var username =  document.getElementsByName(&quot;username&quot;)[0].value.trim();
         if(username==&quot;&quot;){
             alert(&quot;用户名不能为空！&quot;);
             //阻止默认行为，事件内自动封装了event，不能跳转，方式1
             event.preventDefault();
             //阻止表单的提交，方式2
             //return false;
         }
    }
&lt;/script&gt;</code></pre><p><a href="./JS/20200421/08-阻止表单提交.html">点击查看效果</a></p>
<h3 id="9-4-2事件属性"><a href="#9-4-2事件属性" class="headerlink" title="9.4.2事件属性"></a>9.4.2事件属性</h3><p>常用的基本属性，下面四个属性均为只读属性。<br>target:(srcElement）获取事件对应的最详细元素Dom对象。<br>currentTarget：获取绑定了响应函数的Dom对象，currentTarget不一定与target相等。<br>type：获取事件类型，例如click。<br>timeStamp：获取时间戳。Number类型。</p>
<h2 id="9-5焦点事件类型"><a href="#9-5焦点事件类型" class="headerlink" title="9.5焦点事件类型"></a>9.5焦点事件类型</h2><p>事件类型：用户交互的方式如点击、双击等。（本章节只讲述html4中的事件类型，html5的事件类型参见之后章节）。依据事件的操作方式，事件类型又可以分为以下几类。<br>焦点事件<br>鼠标事件<br>键盘事件<br>窗口事件<br>变动事件<br>常用的焦点事件一般用于表单元素得到或失去焦点时的调用响应函数进行数据验证。<br>focusout:失去焦点时事件。<br>focusin:得到焦点时事件。<br>blur：老版本的失去焦点事件，与focusout功能一致，但无法冒泡。<br>focus：老版本的得到焦点事件，与focusin功能一致，但无法冒泡</p>
<pre><code>&lt;body&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt;
    &lt;span style=&quot;display: none;&quot;&gt;username获取焦点了&lt;/span&gt;
&lt;/body&gt;
&lt;script&gt;
    //添加获取焦点的事件
    document.getElementById(&quot;username&quot;).addEventListener(&quot;focusin&quot;,function(){
        document.getElementsByTagName(&quot;span&quot;)[0].style.display=&quot;inline-block&quot;;
    },false);
    //添加失去焦点的事件
    document.getElementById(&quot;username&quot;).addEventListener(&quot;focusout&quot;,function(){
        var username = event.currentTarget.value;
        alert(username);
    },false);
&lt;/script&gt;</code></pre><p><a href="./JS/20200421/09-常用事件.html">点击查看效果</a></p>
<h2 id="9-6鼠标事件"><a href="#9-6鼠标事件" class="headerlink" title="9.6鼠标事件"></a>9.6鼠标事件</h2><p>常用的鼠标事件一般用于用户使用鼠标操作网页元素时。<br>click : 多用在某个对象控制地范围内地鼠标点击后抬起事件。<br>dblclick : 鼠标双击事件触发的事件。<br>mousedown : 鼠标上地按钮被按下时触发的事件。<br>mouseup : 鼠标按下后，松开时激发的事件<br>mouseover : 鼠标移动到某对象范围地上方时触发的事件<br>mousemove : 鼠标移动时触发的事件。<br>mouseout : 鼠标离开某对象范围时触发的事件。<br>mousewheel ：鼠标滚轮滚动式触发的事件。<br>contextmenu：鼠标右键菜单弹出前触发的事件。</p>
<pre><code>&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;style&gt;
    div{
        width: 100px;
        height: 100px;
        background-color: red;
    }
&lt;/style&gt;
&lt;script&gt;
    //获取元素
    document.getElementsByTagName(&quot;div&quot;)[0].addEventListener(&quot;mouseover&quot;,function(){
        //将div的背景颜色改为绿色
        //event.currentTarget.style.backgroundColor=&quot;green&quot;;
        event.currentTarget.style.backgroundColor=&quot;green&quot;;
        event.currentTarget.style.transition = &quot;backgroundColor 1s&quot;;
    },false);
    document.getElementsByTagName(&quot;div&quot;)[0].addEventListener(&quot;mouseout&quot;,function(){
        //将div的背景颜色改为绿色
        event.currentTarget.style.backgroundColor=&quot;red&quot;;
    },false);
&lt;/script&gt;</code></pre><p><a href="./JS/20200421/10-鼠标的移入移出.html">点击查看效果</a></p>
<h2 id="9-7键盘事件"><a href="#9-7键盘事件" class="headerlink" title="9.7键盘事件"></a>9.7键盘事件</h2><p>常用的键盘事件如下。<br>keydown : 当键盘按下时调用，如不松手则反复调用（非输入按键只调用一次），输入中文时，每次点击都会调用。<br>keyup : 当键盘松开时调用。<br>keypress :当键盘按下时调用，如不松手则反复调用，输入中文时，每次点击都会调用。但对于非字符输入不调用。<br>   以上三个方法都可以在回调函数中通过event.keyCode获取字符码<br>textInput : 只有可编辑区域（例如文本框、文本域），输入成功一个字符时才会调用。此方法通过event.data获取输入的字符。</p>
<h2 id="9-8事件委托机制"><a href="#9-8事件委托机制" class="headerlink" title="9.8事件委托机制"></a>9.8事件委托机制</h2><p>思考 ：在网页上给一组功能完全一致的Dom对象绑定同一个事件既影响执行效率，又会浪费内存资源。<br><img src="/2020/04/24/JS/image560.png" alt><br>事件委托：将一组相似的事件的响应函数统一绑定给一个外层DOM对象，当用户触发外层DOM对象时，调用同一个响应函数执行，通过参数来判断触发的子DOM节点。<br>事件委托机制用于一组相似的操作事件，同时事件的响应函数为同一个。<br>父DOM节点被触发后，应根据操作的实际对象判断是否执行响应函数。<br>在jquery的on方法中实现了事件委托机制的具体封装（参见之后章节）。</p>
<h1 id="10BOM对象"><a href="#10BOM对象" class="headerlink" title="10BOM对象"></a>10BOM对象</h1><h2 id="10-1window对象"><a href="#10-1window对象" class="headerlink" title="10.1window对象"></a>10.1window对象</h2><p>BOM（Browser Object Model）：浏览器对象模型，用于操作浏览器窗口的一组接口。<br>DOM与BOM的区别：<br>DOM接口都是在操作浏览器的BODY内的元素，无论是DOM、HTMLDOM都是浏览器遵循w3c标准对外公布的标准接口，在浏览器中兼容性强。<br>BOM是操作浏览器本身，比如窗口大小、子窗口等等。BOM没有标准的标准，但由于现代浏览器几乎都封装了浏览器对象，并公布了对外接口。</p>
<p>BOM的主要对象：<br>window：对象表示浏览器中打开的窗口。Window对象也封装了Dom标准中Global对象涵盖的全部内容，是js、DOM、HTMLDOM的运行环境。<br>navigator： 对象包含有关浏览器的信息。<br>screen:对象包含有关客户端显示屏幕的信息。<br>history： 对象包含用户（在浏览器窗口中）访问过的 URL。<br>location：对象包含有关当前 URL 的信息，主要的作用是网页跳转。</p>
<pre><code>navigator、screen、history、location都是window对象的一个属性对象。获取方式为 window.XXXX.</code></pre><p>window：对象表示浏览器中打开的窗口，包含如下几类属性及方法。<br>Dom中规定的Global对象中的函数和属性。<br>浏览器内置对象及Function类。<br>用户自定义的全局属性、对象以及Function类。<br>用于操作窗口对象的属性及方法。（本节介绍）<br>其他BOM对象。</p>
<h3 id="10-1-1间隔执行与延迟执行"><a href="#10-1-1间隔执行与延迟执行" class="headerlink" title="10.1.1间隔执行与延迟执行"></a>10.1.1间隔执行与延迟执行</h3><p>间隔执行：在固定的时间间隔内执行指定程序，与js主程序采取多线程执行方式。方法如下</p>
<pre><code>number setInterval(fun,time);设置间隔调用</code></pre><p>参数说明：</p>
<pre><code>fun：在固定时间间隔内执行的程序函数。
time：固定时间间隔，单位为毫秒。</code></pre><p>返回类型说明：</p>
<pre><code>number：返回类型为number，本次间隔调用的唯一标示，主要用于取消间隔调用。
clearInterval(number);取消间隔调用 
&lt;body&gt;
    &lt;span class=&quot;time&quot; id=&quot;time&quot;&gt;&lt;/span&gt;
    &lt;br&gt;
    &lt;input type=&quot;button&quot;value=&quot;停止时钟&quot; class=&quot;stop&quot;&gt;
&lt;/body&gt;
&lt;script&gt;
    function setTime(){
        //获取日期对象
        var date  = new Date();
        //获取date对象中的年月日时分秒
        var y = date.getFullYear();
        var m = date.getMonth()+1;
        var d = date.getDate();
        var h = date.getHours();
        var min = date.getMinutes();
        var s = date.getSeconds();
        //将时间信息链接成字符串
        var time_str = y+&quot;-&quot;+m+&quot;-&quot;+d+&quot; &quot;+h+&quot;:&quot;+min+&quot;:&quot;+s;
        console.log(time_str);
        //将事件信息，放在span标签内
        document.getElementById(&quot;time&quot;).innerText = time_str;
    }

    //时间单位是毫秒
    var set_time = setInterval(setTime,1000);
    //为按钮添加点击事件
    document.getElementsByClassName(&quot;stop&quot;)[0].addEventListener(&quot;click&quot;,function(){
        clearInterval(set_time);
    },false);

&lt;/script&gt;</code></pre><p><a href="./JS/20200421/11-间隔执行.html">点击查看效果</a><br>延迟执行：在固定的时间间隔内执行指定程序，与js主程序采取多线程执行方式。方法如下</p>
<pre><code>number setTimeout(fun,time);设置延迟执行</code></pre><p>参数说明：</p>
<pre><code>fun：在固定时间间隔内执行的程序函数。
time：固定时间间隔，单位为毫秒。</code></pre><p>返回类型说明：</p>
<pre><code>number：返回类型为number，本次间隔调用的唯一标示，主要用于取消间隔调用。
&lt;body&gt;
    &lt;span class=&quot;time&quot; id=&quot;time&quot;&gt;&lt;/span&gt;
    &lt;br&gt;
    &lt;input type=&quot;button&quot;value=&quot;停止时钟&quot; class=&quot;stop&quot;&gt;
&lt;/body&gt;
&lt;script&gt;
    function setTime(){
        //获取日期对象
        var date  = new Date();
        //获取date对象中的年月日时分秒
        var y = date.getFullYear();
        var m = date.getMonth()+1;
        var d = date.getDate();
        var h = date.getHours();
        var min = date.getMinutes();
        var s = date.getSeconds();
        //将时间信息链接成字符串
        var time_str = y+&quot;-&quot;+m+&quot;-&quot;+d+&quot; &quot;+h+&quot;:&quot;+min+&quot;:&quot;+s;
        console.log(time_str);
        //将事件信息，放在span标签内
        document.getElementById(&quot;time&quot;).innerText = time_str;
        //var set_time = setTimeout(setTime,1000);
    }
    //setTime();
    //时间单位是毫秒,3000毫秒以后执行
    var set_time = setTimeout(setTime,3000);
    //为按钮添加点击事件
    document.getElementsByClassName(&quot;stop&quot;)[0].addEventListener(&quot;click&quot;,function(){
        //停止时钟
        clearTimeout(set_time);
    },false);
&lt;/script&gt;</code></pre><p><a href="./JS/20200421/12-延迟执行.html">点击查看效果</a></p>
<h3 id="10-1-2窗口方法"><a href="#10-1-2窗口方法" class="headerlink" title="10.1.2窗口方法"></a>10.1.2窗口方法</h3><p>打开提示框：alert(message),其中message为提示框信息<br>打开确认框：confirm(message) ,其中message为确认框信息<br>打开新窗口：open(‘url’,’target’)<br>–url：打开窗口对应的网页url。<br>–target：打开方式。与href中的target一样，取值如下（_top,_self,_blank,_parent,frameName）。（默认值为_blank）</p>
<pre><code>&lt;body&gt;
    &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;打开百度&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;通过location打开百度&quot;&gt;
&lt;/body&gt;
&lt;script&gt;
    //提示框
    alert(&quot;现在出问题了！&quot;);
    //返回true，false，确定：true
    var res = confirm(&quot;确定要删除吗？&quot;);
    console.log(res);
    if(res){
        //执行删除的操作
    }    
    //open方法，打开页面
    document.getElementById(&quot;btn&quot;).addEventListener(&quot;click&quot;,function(){
        open(&quot;http://www.baidu.com&quot;,&quot;_blank&quot;);
    },false);
&lt;/script&gt;</code></pre><p>点击按钮以后，会在新的窗口中打开百度</p>
<h2 id="10-2location对象"><a href="#10-2location对象" class="headerlink" title="10.2location对象"></a>10.2location对象</h2><p>location对象：对象表示窗口的地址对象，作为一个属性封装在window对象中。对象的常用属性：<br>host：设置或获取当前窗口地址的域名及端口。格式为127.0.0.1:8020。<br>hostname：设置或获取当前窗口地址的域名。格式为127.0.0.1。<br>protocol：设置或获取当前窗口地址的请求方式。格式为http:<br>port ：设置或获取当前窗口地址的端口。 格式为8020。<br>href:设置或获取当前窗口地址的全路径。最常用，一般用于网页刷新、网页跳转、网页参数的解析。<br>其中，href属性是我们的常用属性，用来跳转。</p>
<pre><code>&lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;通过location打开百度&quot;&gt;
document.getElementsByClassName(&quot;btn&quot;)[0].onclick = function(){
    window.location.href = &quot;http://www.baidu.com&quot;;
}</code></pre><p>这样也可以实现页面跳转，只是不能指定打开方式。</p>
<h2 id="10-3navigator对象"><a href="#10-3navigator对象" class="headerlink" title="10.3navigator对象"></a>10.3navigator对象</h2><p>navigator对象：对象表示窗口的浏览器对象，作为一个属性封装在window对象中。navigator对象的通用属性：<br>appCodeName：返回浏览器的代码名， 例如chrome以Netscape 代码为基础的浏览器中，它的值是 “Mozilla”。<br>appName：返回浏览器的名称，例如chrome基于 Netscape 的浏览器中，这个属性的值是 “Netscape”<br>userAgent ：返回浏览器客户端基本信息。<br>language：返回当前浏览器的语言。<br>plugins：返回当前浏览器安装的插件信息。</p>
<pre><code>//获取浏览器客户端信息
var info = window.navigator.userAgent;
console.log(info);</code></pre><h2 id="10-4screen对象"><a href="#10-4screen对象" class="headerlink" title="10.4screen对象"></a>10.4screen对象</h2><p>screen对象：对象表示窗口对应的屏幕信息。screen对象的通用属性：<br>availHeight：返回显示屏幕的高度 (除 Windows 任务栏之外)。<br>availWidth：返回显示屏幕的宽度 (除 Windows 任务栏之外)。<br>height：返回显示屏幕的高度。<br>width：返回显示器屏幕的宽度。</p>
<pre><code>//获取屏幕的可用高度，去掉任务栏
var avail_Height = window.screen.availHeight;
console.log(avail_Height);
//获取屏幕高度
var height = window.screen.height;
console.log(height);</code></pre><h2 id="10-5history对象"><a href="#10-5history对象" class="headerlink" title="10.5history对象"></a>10.5history对象</h2><p>history对象：对象表示窗口的历史记录对象。history对象的通用属性与方法<br>length：返回浏览器历史列表中的 URL 数量<br>back()：加载 history 列表中的前一个 URL路径。<br>forward()：加载 history 列表中的下一个 URL路径。<br>go(step)：加载 history 列表中的前/后step个URL路径，参数可以为负。<br>实现页面之间的跳转，每个跳转之后的url都会存储在history中，只有先跳转才能实现。<br>第一个网页</p>
<pre><code>&lt;body&gt;
    &lt;a href=&quot;15-1.html&quot;&gt;打开15-1&lt;/a&gt;
    &lt;button id=&quot;last&quot;&gt;上一页&lt;/button&gt;&lt;button id=&quot;next&quot;&gt;下一页&lt;/button&gt;
&lt;/body&gt;
&lt;script&gt;
    //上一页
    document.getElementById(&quot;last&quot;).onclick = function(){
        //window.history.back();
        window.history.go(-1);
    }
    //下一页
    document.getElementById(&quot;next&quot;).onclick = function(){
        //window.history.forward();
        window.history.go(1);
    }    
&lt;/script&gt;</code></pre><p>第二页：</p>
<pre><code>&lt;body&gt;
    &lt;h1&gt;15-1&lt;/h1&gt;
    &lt;a href=&quot;15-2.html&quot;&gt;打开15-2&lt;/a&gt;
&lt;/body&gt;</code></pre><p>第三页：</p>
<pre><code>&lt;body&gt;
    &lt;h1&gt;15-2&lt;/h1&gt;
&lt;/body&gt;</code></pre><p><a href="./JS/20200421/15-history.html">点击查看效果</a></p>
<h1 id="11-Ajax访问"><a href="#11-Ajax访问" class="headerlink" title="11 Ajax访问"></a>11 Ajax访问</h1><h2 id="11-1Ajax的技术组成"><a href="#11-1Ajax的技术组成" class="headerlink" title="11.1Ajax的技术组成"></a>11.1Ajax的技术组成</h2><p>AJAX的执行原理：AJAX不用刷新整个页面便可与服务器通讯的办法<br><img src="/2020/04/24/JS/image561.png" alt><br>图1 Web的传统模型。客户端向服务器发送一个请求，服务器返回整个页面，如此反复<br><img src="/2020/04/24/JS/image562.png" alt><br>图2 在Ajax模型中，数据在客户端与服务器之间独立传输。服务器不再返回整个页面，而只返回可用信息。<br>Ajax的技术组成：AJAX实际上是几种技术以一种全新的方式聚合在一起的方式。<br>服务器端语言：服务器需要具备向浏览器发送特定信息的能力。Ajax与服务器端语言无关。<br>XML (eXtensible Markup Language，可扩展标记语言) 是一种描述数据的格式。Aajx 程序需要某种格式化的格式来在服务器和客户端之间传递信息，XML 是其中的一种选择。<br>HTML和 CSS（Cascading Style Sheet,级联样式单）标准化呈现；<br>DOM（Document Object Model,文档对象模型）实现动态显示和交互；<br>使用XMLHTTP组件XMLHttpRequest对象进行同步或异步数据读取,非w3c标准<br>使用JavaScript绑定和处理所有数据。</p>
<h2 id="11-2XHR对象介绍"><a href="#11-2XHR对象介绍" class="headerlink" title="11.2XHR对象介绍"></a>11.2XHR对象介绍</h2><p>XHR对象：AJAX核心对象，是XMLHttpRequest对象的缩写，封装在window对象中，封装了发送AJAX请求、接收响应的属性以及方法。最早是在IE5中以ActiveX组件的形式实现的，现在已经被所有高级浏览器兼容。<br>Internet Explorer把XMLHttpRequest实现为一个ActiveX对象<br>其他浏览器（Firefox、Safari、Opera…）把它实现为一个window对象的内置对象window.xmlHttpRequest。<br>浏览器虽然获取XHR对象的方法不同，但对象内的属性和方法确相同。<br>创建兼容的XHR对象：</p>
<pre><code>function getXhr(){
    //判断浏览器是否支持
    if(window.XMLHttpRequest){
        return new XMLHttpRequest();
    }else{
        //ie低版本
        return new window.ActiveXObject(&quot;Microsoft.XMLHttp&quot;);
    }
}</code></pre><p>如果XMLHttpRequest对象存在，则把 xhr 的值设为该对象的新实例。如果不存在，就去检测 ActiveObject 的实例是否存在，如果答案是肯定的，则把微软 XMLHTTP 的新实例赋给 xhr。</p>
<p>XHR对象API接口总览（绿色为常用接口）<br><img src="/2020/04/24/JS/image563.png" alt><br>其余API接口：<br><img src="/2020/04/24/JS/image564.png" alt></p>
<h2 id="11-3发送Ajax请求的步骤介绍"><a href="#11-3发送Ajax请求的步骤介绍" class="headerlink" title="11.3发送Ajax请求的步骤介绍"></a>11.3发送Ajax请求的步骤介绍</h2><p>发送AJAX请求的步骤：<br>调用open方法，代表预备发送请求。<br>如果请求类型为POST，则需设定响应头。<br>发送http请求指令，传递参数。<br>声明请求状态改变的回调函数，接收服务器响应信息。<br><img src="/2020/04/24/JS/image565.png" alt></p>
<h2 id="11-4发送请求核心API"><a href="#11-4发送请求核心API" class="headerlink" title="11.4发送请求核心API"></a>11.4发送请求核心API</h2><p>open(method, url, asynch)：open 方法允许程序员用一个Ajax调用向服务器发送请求。<br>method：请求类型，类似 “GET”或”POST”的字符串。若需要向服务器发送数据，用POST，若使用GET请求，则可以在url地址栏传递参数，但原则上字符数量不超过2000，且不同服务器解码方式不同容易造成乱码。<br>url：路径字符串，可以为get请求传递参数，有些浏览器会把多个请求的结果缓存在同一个URL，造成网页更新不及时，可在url中增加时间戳避免缓存。<br>asynch：表示请求是否要异步传输，默认值为true。同步传输将导致网页等待期间无法操作，建议使用异步传输。<br>setRequestHeader(header,value):设定响应头，响应头用于描述元数据。参数描述：<br>header： 响应头的名字;如果用POST请求向服务器发送数据，需要将 “Content-type” 的首部设置为 “application/x-www-form-urlencoded”.它会告知服务器正在发送数据，并且数据已经符合URL编码了<br>value：响应头的值。<br>注意事项：该方法必须在open()之后才能调用。<br><img src="/2020/04/24/JS/image566.png" alt><br>send(data)：根据open方法设定的参数，发送实际http请求指令。参数说明：<br>data：将要传递给服务器的字符串（字符类型）。<br>注意事项：<br>若选用的是 GET 请求，则不会发送任何数据。<br>post请求发送的数据类型为用=分开的名值对，如果需要传送JSON对象，则需要转型。<br><img src="/2020/04/24/JS/image567.png" alt><br>完整的发送AJAX的get请求的案例：<br><img src="/2020/04/24/JS/image568.png" alt><br>完整的发送AJAX的post请求的案例：<br><img src="/2020/04/24/JS/image569.png" alt></p>
<h2 id="11-5接收响应核心API"><a href="#11-5接收响应核心API" class="headerlink" title="11.5接收响应核心API"></a>11.5接收响应核心API</h2><p>接收服务器响应依靠XHR的如下接口实现：<br>onreadystatechange:服务器响应状态改变的事件属性。<br>readyState：表示Ajax请求的当前状态<br>status：服务器返回的http响应状态，如200代表正常404代表没找到资源。<br>responseText：服务器返回的字符格式。<br>responseXML：服务器返回的XML格式（前端开发中使用很少）。<br><strong>xhr上述属性都是由服务器端修改，而非客户端修改，因此是只读属性</strong>。</p>
<p>onreadystatechange:服务器响应状态改变的事件属性，值为函数类型。<br>服务器会通知客户端当前的通信状态，每次 readyState 属性的改变都会触发 readystatechange事件。<br><img src="/2020/04/24/JS/image570.png" alt><br>readyState：表示Ajax请求的当前状态。它的值用数字代表。取值范围：<br>0 代表未初始化。 还没有调用 open 方法<br>1 代表正在加载。 open 方法已被调用，但 send 方法还没有被调用<br>2 代表已加载完毕。send 已被调用。请求已经开始<br>3 代表交互中。服务器正在发送响应<br><strong>4 代表完成。响应发送完毕</strong>。<br>注意事项：<br>readyState 值的变化会因浏览器的不同而有所差异。但是当请求结束的时候，每个浏览器都会把 readyState 的值统一设为 4。<br>编写时应注意把onreadystatechange赋值编写在open之前。</p>
<p>status：服务器发送的响应状态码。常用状态码及其含义：<br><strong>404 没找到页面(not found)</strong><br><strong>403 禁止访问(forbidden)</strong><br><strong>500 内部服务器出错(internal service error)</strong><br><strong>200 一切正常(ok)</strong><br><strong>304 没有被修改(not modified)</strong><br>注意事项：通过XHR.status和 200 或 304 比较，可以确保服务器是否已发送了一个成功的响应。</p>
<p>responseText:服务器返回的响应数据，字符类型。<br>XMLHttpRequest 的 responseText 属性包含了从服务器发送的数据。它是一个HTML,XML或普通文本，这取决于服务器发送的内容。<br>当 readyState 属性值变成 4 时, responseText 属性才可用，表明 Ajax 请求已经结束。<br>responseXML：服务器返回的响应数据，格式为xml，字符类型，不建议使用。<br>如果服务器返回的是 XML， 那么数据将储存在 responseXML 属性中。<br>只用服务器发送了带有正确头部信息的数据时， responseXML 属性才是可用的。 MIME 类型必须为 text/xml</p>
<p>完整的接收响应信息的案例：</p>
<pre><code>xhr.onreadystatechange = function(e){
if(e.target.readyState==4){
    if (e.target.status == 200 || e.target.status == 304) {
        alert(e.target.responseText);
    }
  }
} </code></pre><p>发送get请求的代码：</p>
<pre><code>&lt;script&gt;
    function getXhr(){
        //判断浏览器是否支持
        if(window.XMLHttpRequest){
            return new XMLHttpRequest();
        }else{
            //ie低版本
            return new window.ActiveXObject(&quot;Microsoft.XMLHttp&quot;);
        }
    }
    //1.创建对象
    var xhr = getXhr();
    //监听状态的变化，放在open之前
    xhr.onreadystatechange = function(e){
        //判断状态的变化
        if(e.target.readyState==4){
            //服务器接收成功，完成发送
            //判断响应状态码
            if(e.target.status==200 || e.target.status==304){
                //服务端响应成功
                var result = e.target.responseText;
            }
        }
    }
    //准备发送,get请求将参数拼接在url后面
    xhr.open(&quot;GET&quot;,&quot;XxxServlet?参数1=值1&amp;参数2=值2&quot;,true);
    //fa送出去
    xhr.send(null);    
&lt;/script&gt;</code></pre><p>发送post请求：</p>
<pre><code>&lt;script&gt;
    function getXhr(){
        //判断浏览器是否支持
        if(window.XMLHttpRequest){
            return new XMLHttpRequest();
        }else{
            //ie低版本
            return new window.ActiveXObject(&quot;Microsoft.XMLHttp&quot;);
        }
    }
    //1.创建对象
    var xhr = getXhr();
    //监听状态的变化
    xhr.onreadystatechange = function(e){
        //判断状态的变化
        if(e.target.readyState==4){
            //服务器接收成功，完成发送
            //判断响应状态码
            if(e.target.status==200 || e.target.status==304){
                //服务端响应成功
                var result = e.target.responseText;
            }
        }
    }
    //准备发送
    xhr.open(&quot;POST&quot;,&quot;XxxServlet&quot;,true);
    //如果是post请求，一定要加这句话
    xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);
    //fa送出去，将传递的参数放在send中发送
    xhr.send(&quot;参数名=值&amp;参数名=值&quot;);        
&lt;/script&gt;</code></pre><h2 id="11-6JSON介绍"><a href="#11-6JSON介绍" class="headerlink" title="11.6JSON介绍"></a>11.6JSON介绍</h2><p>AJAX 是一门与语言无关的技术，例如网页、android、IOS，都可以使用AJAX，同时多种web服务器都可以响应AJAX。<br><img src="/2020/04/24/JS/image571.png" alt><br>多客户端都可以统一访问一个服务器<br>不同语言开发的服务器端程序都可以被不同客户端访问。</p>
<h3 id="11-6-1JSON格式介绍"><a href="#11-6-1JSON格式介绍" class="headerlink" title="11.6.1JSON格式介绍"></a>11.6.1JSON格式介绍</h3><p>JSON（JavaScript Object  Notation）：一种简单的数据格式，比xml更轻巧。<br>JSON是JavaScript原生格式，这意味着在JavaScript中处理JSON数据不需要任何特殊的API或工具包。<br>JSON的基本规则就是无序的名值对，但严格意义上名称要用””包裹。数据值只能为数字、字符、数组、布尔、JSON对象。</p>
<pre><code>{“flag”:true}  {“fav”:[“java”,”js”]}</code></pre><p>JSON对象存在嵌套关系，可以无限嵌套</p>
<pre><code>{&quot;key1&quot;:{&quot;key11&quot;:{&quot;key111&quot;:&quot;val11&quot;}}}
    //json对象
    var p = {
        &quot;name&quot;:&quot;zhangsan&quot;,
        &quot;age&quot;:18
    };
    console.log(p.name);
    console.log(p.age);

    //json数组
    var p2 = {
        &quot;name&quot;:&quot;lisi&quot;,
        &quot;age&quot;:20,
        &quot;citys&quot;:[
            &quot;北京&quot;,&quot;天津&quot;,&quot;昆明&quot;
        ]
    }
    console.log(p2.citys[0]);//北京

    //值是一个对象
    var p3 = {
        &quot;name&quot;:&quot;lisi&quot;,
        &quot;age&quot;:20,
        &quot;emploee&quot;:{
            &quot;id&quot;:10001,
            &quot;name&quot;:&quot;程序员&quot;,
            &quot;salary&quot;:10000
        }
    }
    console.log(p3.emploee.salary);

    // 值是json数组，数组内存储对象
    var p4 = {
        &quot;name&quot;:&quot;lisi&quot;,
        &quot;age&quot;:20,
        &quot;citys&quot;:[
            {
                &quot;name&quot;:&quot;北京&quot;
            },
            {
                &quot;name&quot;:&quot;天津&quot;
            },
            {
                &quot;name&quot;:&quot;昆明&quot;
            }
        ]
    }
    console.log(p4.citys[1].name);</code></pre><p>JSON格式的转换：JSON是一种数据格式，以字符格式传输。<br><img src="/2020/04/24/JS/image572.png" alt><br>ECMAscript中扩展了字符与JSON格式相互转换的方式。<br>String JSON.stringify(obj)：将ECMAscript对象转换为字符。<br>    –String ：返回类型。<br>    –JSON：window对象的全局属性，但只有在高版本浏览器中兼容。<br>    –stringify:JSON对象的全局方法，将目标对象转换为字符。<br>    –obj:需要转换的对象。</p>
<pre><code>var obj = {userName:&apos;zhangsan&apos;,password:&apos;123&apos;};
xhr.send(&quot;param=&quot; + JSON.stringify (obj));</code></pre><p>Obj JSON.parse(Str)：将JSON格式的字符转换为ECMAscript对象。<br>    –obj：返回类型，对象。<br>    –str:需要转换的字符。<br>    –代码示例</p>
<pre><code>var str=&apos;{&quot;user&quot;:&quot;zhongruan&quot;}&apos;;
alert (JSON.parse(str).user);</code></pre><h3 id="11-6-2模拟登陆案例"><a href="#11-6-2模拟登陆案例" class="headerlink" title="11.6.2模拟登陆案例"></a>11.6.2模拟登陆案例</h3><p>HTML内容：</p>
<pre><code>&lt;body&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;
    &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;
    &lt;button&gt;登陆&lt;/button&gt;
&lt;/body&gt;</code></pre><p>JS内容：</p>
<pre><code>&lt;script&gt;    
    //为登陆按钮添加点击事件
    document.getElementsByTagName(&quot;button&quot;)[0].onclick = function(){
        //1.创建对象
        var xhr = getXhr();
        //监听状态的变化
        xhr.onreadystatechange = function(e){
            //判断状态的变化
            if(e.target.readyState==4){
                //服务器接收成功，完成发送
                //判断响应状态码
                if(e.target.status==200 || e.target.status==304){
                    //服务端响应成功，将字符转成json格式
                    var result = JSON.parse(e.target.responseText);
                    console.log(result.success);
                }
            }
        }
        //准备发送
        xhr.open(&quot;GET&quot;,&quot;login.json&quot;,true);
        //fa送出去
        xhr.send(null);
    }
    function getXhr(){
        //判断浏览器是否支持
        if(window.XMLHttpRequest){
            return new XMLHttpRequest();
        }else{
            //ie低版本
            return new window.ActiveXObject(&quot;Microsoft.XMLHttp&quot;);
        }
    }        
&lt;/script&gt;</code></pre><p><a href="./JS/20200421/18-模拟登陆.html">点击查看效果</a><br>login.json文件与当前html文件在同一路径下：<br>{“success”:false}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jinyeeeee.github.io/2020/04/24/JS/" data-id="ck9i9zxyr000q6ov0c0a6ewdo"
         class="article-share-link">分享</a>
      
    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2020/04/24/Jquery/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Jquery
          
        </div>
      </a>
    
    
      <a href="/2020/04/22/html2/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">html2</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
    </div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/technology.js"></script>

  </div>
</body>
</html>