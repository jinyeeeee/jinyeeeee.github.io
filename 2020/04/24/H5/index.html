<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    H5 |
    
    yuchen</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/technology.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <section class="outer">
  <article id="post-H5" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      H5
    </h1>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2020/04/24/H5/" class="article-date">
  <time datetime="2020-04-24T15:36:27.000Z" itemprop="datePublished">2020-04-24</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h1 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h1><h1 id="1h5的标签与全局属性"><a href="#1h5的标签与全局属性" class="headerlink" title="1h5的标签与全局属性"></a>1h5的标签与全局属性</h1><h2 id="1-1什么是H5"><a href="#1-1什么是H5" class="headerlink" title="1.1什么是H5"></a>1.1什么是H5</h2><p>Html5：万维网的核心语言、HTML规范的第五次重大修改。<br>发展历程：<br>1999年12月HTML4.01版本发布。<br>2006 年，Web Hypertext Application Technology Working Group （Web超文本应用技术工作组 –WHATWG，致力于Web 表单和应用程序规则的指定）与W3C（专注于XHTML2.0规则制定）决定进行合作，来创建一个新版本的 HTML。<br>2012年12月17日，W3C正式宣布HTML5规范已经正式定稿。<br>2013年5月6日， HTML 5.1正式草案公布。<br>2014年10月29日，w3c宣布标准规范制定完成。</p>
<p>Html5与html4的区别：<br>取消了一些过时的HTML4标记，并增加了一些标签改善文档结构的功能，增强了html语义化。<br>增加了用于移动端的事件类型。<br>一些全新的表单输入对象。<br>全新的，更合理的Tag以及DOM接口。<br>离线缓存以及本地数据库。<br>Canvas、SVG等图形处理<br>音频视频处理。<br>webworker、websocket等全局对象。</p>
<p>Html与xhtml的区别：<br>xml:规范的标记语言，用来保存以及传输数据，w3c制定规范。<br>xhtml： 以xml的标准严格规范的html标准，2000年发布最早版本，W3C的推荐web网页开发标准。<br>xhtml就是更加规范的html<br>xhtml的特点：<br>xhtml元素必须被正确地嵌套。<br>xhtml元素必须被关闭。<br>标签名必须用小写字母。<br>xhtml文档必须拥有根元素</p>
<p>Html5的兼容性：<br>废弃标签仍然可用，但不建议使用。<br>只有高版本浏览器才能基本兼容html5的新增标签与属性（例如IE10以上）。<br>部分低版本浏览器支持部分html5新内容。<br>兼容性解决方案参见各个章节。<br>HTML5的使用场景：<br>手机网页制作<br>在第三方打包工具配合下制作手机app。<br>第三方app的开发工具（例如微信公众号）。<br>动画以及手机游戏制作等。<br><a href="./H5/20200423/25-h5入门.html">查看效果</a></p>
<h2 id="1-2HTML5入门程序"><a href="#1-2HTML5入门程序" class="headerlink" title="1.2HTML5入门程序"></a>1.2HTML5入门程序</h2><input type="date">

<h2 id="1-3HTML5中废弃的标签"><a href="#1-3HTML5中废弃的标签" class="headerlink" title="1.3HTML5中废弃的标签"></a>1.3HTML5中废弃的标签</h2><p>Html5中已经废弃的标签如下<br>Acronym、 applet 、basefont、big、center、dir、font、frame、frameset、m、noframes、noscript、s<br>便于记忆的方式：<br>取消了用于显示、布局类的标签例；如big、m、font等。（在H5中推荐使用css来替代）。<br>取消了早期框架标签；如frame、frameset（推荐使用iframe）。<br>取消不长使用的标签；如noframes、noscript等。<br>特殊说明：废弃的标签基本上仍然可以被现在的浏览器解析，但不建议大家在项目开发中沿用。</p>
<h2 id="1-4DOCTYPE和meta扩展"><a href="#1-4DOCTYPE和meta扩展" class="headerlink" title="1.4DOCTYPE和meta扩展"></a>1.4DOCTYPE和meta扩展</h2><p>浏览器的文档模式( Document Mode):浏览器渲染文档的模式。<br>严格模式(标准模式)：是指浏览器按照 W3C 标准解析代码。<br>混杂模式（怪异模式）：是指浏览器用指定的方式解析代码。<br>模式触发：<br>DOCTYPE不存在或形式不正确会浏览器以混杂模式呈现网页。<br>只声明Doctype，不引用任何dtd文件，以严格模式呈现网页（html5标准）。</p>
<pre><code>&lt;!DOCTYPE htm1&gt;</code></pre><p>包含DTD和URI的DOCTYPE，严格模式呈现网页，以dtd文件对应的版本呈现网页。</p>
<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;
&quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</code></pre><p>获取模式的方式：document.compatMode取值范围如下：<br>CSS1Compat：严格模式。<br>BackCompat：严格模式关闭（混杂模式）。</p>
<p>在H5中扩展了meta的charset属性： </p>
<meta charset="utf-8">  声明文档使用的字符编码(html5)
<meta http-equiv="“content-type”" content="“text/html;" charset="UTF-8”">（ html4）
![](./H5/image578.png)
## 1.5布局的语义化标签
Html5保留了html4大多数语义化标签，同时新增了若干的语义化标签，这些标签并不起显示作用，但增强了html的可读性，与div、span等类似，称为语义化标签。
article：标签装载显示一个独立的文章内容，例如一篇文章、报导、小说。
section ：标签定义文档中的节（section、区段），例如一个小说中的一章节。
aside：用来装载非正文类的内容，对于主题内容的说明。
header ：标签定义文档的页面头部，通常是一些引导和导航信息
footer ： 标签定义 section 或 document 的页脚
nav ：标签定义显示导航链接
![](./H5/image579.png)
## 1.6其他扩展标签
Html5中扩展的标签：
标题组标签(hgroup )：一般作为多个标题的容器。

<pre><code>&lt;hgroup class=&quot;hgroup&quot;&gt;
    &lt;h2&gt;会议内容&lt;/h2&gt;
    &lt;h2&gt;会议主题&lt;/h2&gt;
&lt;/hgroup&gt;</code></pre><p>媒体标签（figure、figcaption）：作为独立的媒体内容(例如图像、图表、照片、代码等等)的容器，同时包含对这些媒体的说明文字。</p>
<pre><code>&lt;figure&gt;
    &lt;img src=&quot;img/1.jpg&quot; width=&quot;200px&quot; /&gt;
    &lt;figcaption&gt;这是一张神奇的图片&lt;/figcaption&gt;
&lt;/figure&gt;</code></pre><p><mark> ：用于突出显示文本内容，例如</mark></p>
<p>我的薪资是<mark>10000</mark></p>

<p>详情标签（details、summary）：details中可以定义默认显示标题（summary），以及标题对应的内容，通过点击标题显示和隐藏标题内容。</p>
<pre><code>&lt;details open=&quot;open&quot;&gt;
    &lt;summary&gt;dafsdfas&lt;/summary&gt;
    &lt;p&gt;dasfsdfsafs&lt;/p&gt;
    dfasfsafsdf
&lt;/details&gt;</code></pre><p>进度条标签（progress）： 标签定义运行中的进度。<br><img src="/2020/04/24/H5/image580.png" alt><br><progress max="100" value="80" data-value="80" draggable="true"></progress><br><a href="./H5/20200423/25-h5入门.html">查看效果</a></p>
<h2 id="1-7新增全局属性"><a href="#1-7新增全局属性" class="headerlink" title="1.7新增全局属性"></a>1.7新增全局属性</h2><p>常用的新增全局属性说明：<br>contenteditable：规定当前元素的内容是否可以编辑。 true /false<br>contextmenu：规定当前元素的右键菜单对应的dom对象id（不兼容）。<br>data-yourvalue：规定用户定义的自定义属性，在html5中规定自定义属性应该以data-开头。<br>draggable：规定当前元素是否可以拖拽，但浏览器的默认行为会阻止拖拽行为，需要配合js以及拖拽的api来实现。<br>hidden：规定当前元素是否显示。<br>tabindex：设置当前元素获取焦点的顺序，默认是按照元素的位置（从上到下）获取焦点，在h5中若设定取值为-1，元素无法获取焦点。<br>designMode:document对象的全局属性，设定当前网页内的元素是否可以编辑。</p>
<pre><code>&lt;progress max=&quot;100&quot; value=&quot;80&quot; data-value=&quot;80&quot; draggable=&quot;true&quot;&gt;&lt;/progress&gt;</code></pre><h2 id="1-8新增标签的兼容性"><a href="#1-8新增标签的兼容性" class="headerlink" title="1.8新增标签的兼容性"></a>1.8新增标签的兼容性</h2><p>Html5扩展的标签、dom对象只有在高版本浏览器中兼容，Html5扩展的语义化编程的标签在低版本浏览器中不识别，可以使用html5.js来解决,解决步骤。<br>下载html5shv.js。<br>在head中引入js。（只能在head中）。<br>Html5.js的实现思路：<br>网页加载时，html5js将不识别的元素修改为div、span的dom对象，并且设定默认样式。<br>html.js只能解决部分语义化标签的兼容性（新增属性的兼容性也无法解决）。</p>
<h1 id="2html5新增表单API"><a href="#2html5新增表单API" class="headerlink" title="2html5新增表单API"></a>2html5新增表单API</h1><h2 id="2-1新增表单标签与属性"><a href="#2-1新增表单标签与属性" class="headerlink" title="2.1新增表单标签与属性"></a>2.1新增表单标签与属性</h2><p>HTML5新增表单元素：<br>datalist ：元素规定输入域的选项列表。代码示例如下</p>
<pre><code>&lt;body&gt;
    &lt;input type=&quot;text&quot; list=&quot;list&quot;&gt;
    &lt;datalist id=&quot;list&quot;&gt;
        &lt;option&gt;第一项&lt;/option&gt;
        &lt;option&gt;第二项&lt;/option&gt;
        &lt;option&gt;第三项&lt;/option&gt;
        &lt;option&gt;第四项&lt;/option&gt;
    &lt;/datalist&gt;

&lt;/body&gt;</code></pre><p><a href="./H5/20200423/26-新的下拉列表.html">查看效果</a><br>HTML5增加了若干表单增强属性：<br>placeholder：当输入框内无内容时，设定输入框默认显示的文字。通常用于文本框、搜索框等。<br>autocomplete：设置是否将表单成功提交后将内容缓存到cookie中，下次输入时进行信息提示，取值为on/off,可用于form表单以及input系列标签（一般建议用localstorage取代）。<br>autofocus：设定当前元素在网页加载时获得焦点。如果网页超过一个元素属性为autofocus，则作废，非赋值属性。<br>valueAsNumber/valueAsDate:返回dom对象的value值转换为数字的结果。valueAsDate非H5标准，但在高版本浏览器中都兼容。<br>required：设定当前元素为必填，若没有填写则表单无法提交。H5中增加了对表单数据进行验证，以及错误反馈的方式，但有很大的局限性，可参与文档。</p>
<pre><code>&lt;body&gt;
    &lt;h1&gt;我的表单&lt;/h1&gt;
    &lt;form action=&quot;server.html&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot; autocomplete=&quot;off&quot; 
        required=&quot;required&quot; autofocus=&quot;autofocus&quot;&gt;&lt;br&gt;
        &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;&gt;&lt;br&gt;
        &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;

&lt;/body&gt;</code></pre><p><a href="./H5/20200423/27-新的表单属性.html">查看效果</a></p>
<h2 id="2-2新增输入类型"><a href="#2-2新增输入类型" class="headerlink" title="2.2新增输入类型"></a>2.2新增输入类型</h2><p>HTML5中增加了input标签的类型：<br>email：输入类型为email。<br>url：输入类型为地址url。<br>number：输入类型为数字。<br>range：输入类型为滑块选择。<br>日期选择器：(date, month, week, time, datetime, datetime-local)<br>search：输入类型为查找。<br>color：输入类型为颜色。</p>
<pre><code>&lt;body&gt;
    &lt;form&gt;
        &lt;input type=&quot;email&quot;&gt;&lt;br&gt;
        &lt;input type=&quot;color&quot;&gt;&lt;br&gt;
        &lt;input type=&quot;date&quot;&gt;&lt;br&gt;
        &lt;input type=&quot;number&quot; min=&quot;-10&quot; max=&quot;10&quot; step=&quot;2&quot; value=&quot;0&quot;&gt;&lt;br&gt;
        &lt;input type=&quot;search&quot;&gt;&lt;br&gt;
        0&lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;100&quot;&gt;100
        &lt;input type=&quot;submit&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;</code></pre><p><a href="./H5/20200423/28-新的type属性.html">查看效果</a></p>
<h2 id="2-3File扩展"><a href="#2-3File扩展" class="headerlink" title="2.3File扩展"></a>2.3File扩展</h2><h3 id="2-3-1File介绍"><a href="#2-3-1File介绍" class="headerlink" title="2.3.1File介绍"></a>2.3.1File介绍</h3><p>文件选择标签file增加了如下两个属性：<br>multiple：设定当前元素可以选取多个文件。<br>accept：设定当前选择器可以选择的MIME类型或后缀名。</p>
<pre><code>&lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;&quot; multiple accept=&quot;image/jpg,image/png&quot; /&gt;</code></pre><p>File对象：文件选择框选择的文件对象，封装了文件的基本信息。<br>File对象获取方式：</p>
<pre><code>document.getElementByld(&quot;file&quot;).files//files为伪数组
&lt;input type= &quot;file&quot; id=&quot;file&quot; onchange=&quot;debugger;&quot;/&gt;</code></pre><p>File对象的属性说明：<br>lastModifiedDate：最后修改日期。<br>name：文件名称。<br>size：文件大小<br>type：文件的mime类型。</p>
<p>File对象的方法说明：</p>
<pre><code>Blob slice(startPos,endPos);</code></pre><p>将目标文件分片成二进制对象，常用于大文件上传。<br>    –Blob：返回值，二进制大对象，是一个可以存储二进制信息容器。<br>    –startPos：分片的起始位置。<br>    –endPos：分片终止位置。</p>
<p>FileReader：用于读取文件选择标签选择的File的Dom对象。<br>FileReader的兼容性：在FireFox、chrom的高版本浏览器中兼容，因此需要判断。<br>FileReader的创建方式：</p>
<pre><code>var fr = new FileReader();</code></pre><p><img src="/2020/04/24/H5/image581.png" alt><br>FileReader的事件类型<br><img src="/2020/04/24/H5/image582.png" alt></p>
<h3 id="2-3-2上传图片并回显案例"><a href="#2-3-2上传图片并回显案例" class="headerlink" title="2.3.2上传图片并回显案例"></a>2.3.2上传图片并回显案例</h3><pre><code>&lt;body&gt;
    &lt;form&gt;
        &lt;label for=&quot;img&quot;&gt;+&lt;/label&gt;
        &lt;input type=&quot;file&quot; name=&quot;img&quot; id=&quot;img&quot; style=&quot;display: none;&quot; 
        onchange=&quot;selectImg()&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;style&gt;
    label{
        display: block;
        width:200px;
        height: 200px;
        border:1px solid #f00;
        text-align: center;
        line-height: 200px;
        font-size: 40px;
        color:#f00;
    }
&lt;/style&gt;
&lt;script src=&quot;js/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    function selectImg(){
        //获取上传的文件
        //$(&quot;:file&quot;):jquery对象，在h5中，文件上传多个，files：类似数组，索引取出
        var file = $(&quot;:file&quot;)[0].files[0];
        //创建文件读取流对象
        var fr = new FileReader();
        //用流对象文件，
        fr.readAsDataURL(file);
        //fr有load事件，当文件加载完毕就会触发该事件
        fr.onload = function(){
            //从当前事件中取出图片的url
            var url = event.target.result;
            //将图片设置到label中
            //将+去掉
            $(&quot;label&quot;).text(&quot;&quot;);
            //将图片设置到label
            $(&quot;label&quot;).css({
                &quot;background-image&quot;:&quot;url(&quot;+url+&quot;)&quot;,
                &quot;background-size&quot;:&quot;100% 100%&quot;
            })
        }
    }
&lt;/script&gt;</code></pre><p><a href="./H5/20200423/29-file.html">查看效果</a></p>
<h1 id="3媒体元素"><a href="#3媒体元素" class="headerlink" title="3媒体元素"></a>3媒体元素</h1><h2 id="3-1媒体简介"><a href="#3-1媒体简介" class="headerlink" title="3.1媒体简介"></a>3.1媒体简介</h2><p>什么是多媒体：多媒体是多种不同的UI交互格式。它可以是您听到或看到的任何内容，文字、图片、音乐、音效、录音、电影、动画等等。<br>html5之前媒体播放：在H5之前视频、音频的播放需要借助其他组件实现（例如flash），因此需要安装浏览器的插件。<br>html5的媒体播放：H5新增了两个与媒体相关的标签，用于视频、音频播放，同时提供了控制视频、音频播放的api接口。<br><img src="/2020/04/24/H5/image583.png" alt><br>音频以及视频概述：音频或视频的本质是一个容器，以视频为例包含如下内容：<br>音频轨道<br>视频轨道<br>元数据：视频封面、标题、字幕等。<br>主流视频容器：<br>主流解码器：音频或视频容器很大,需要按照一定规则进行编码才能在网络传输，播放时需要解码器进行解码。<br>常用的音频解码器：<br><img src="/2020/04/24/H5/image584.png" alt><br>常用的视频解码器：<br><img src="/2020/04/24/H5/image585.png" alt><br>媒体元素的兼容性解决方案：<br>浏览器对多媒体元素的支持：<br>IE 9+、Firefox、Opera、Chrome 和 Safari 都支持 <audio> <video>标签。<br>IE 8 或更早版本的 IE 浏览器不支持 <audio> 标签。(需要安装第三方播放插件，如html5media、mediaplay等)。<br>浏览器支持的播放格式不统一造成的不兼容：<br>视频或音频在上传到服务器后，由服务器转换为其他格式。<br>浏览器播放时选择支持的格式加载视频。<br><img src="/2020/04/24/H5/image586.png" alt></audio></video></audio></p>
<h2 id="3-2视频"><a href="#3-2视频" class="headerlink" title="3.2视频"></a>3.2视频</h2><p>Video标签的属性说明：video具备html全局属性，同时具备如下私有属性：<br><img src="/2020/04/24/H5/image587.png" alt></p>
<h3 id="3-2-1兼容性"><a href="#3-2-1兼容性" class="headerlink" title="3.2.1兼容性"></a>3.2.1兼容性</h3><p>video的兼容性检测方法：检测浏览器是否支持video标签</p>
<pre><code>if (document.createElement(&apos;video&apos;).canPlayType){
    alert(&apos;可以使用&apos;);
}</code></pre><p>不可执行视频的信息提示</p>
<pre><code>&lt;video src=&quot;video/1.1 spring概述.mp4&quot; controls=&quot;controls&quot; width=&quot;300px&quot; height=&quot;300px&quot;&gt;
你的浏览器无法播放当前视频,&lt;!--如果当前浏览器无法使用video控件，在此处进行相关的说明--&gt;
&lt;/video&gt;</code></pre><p>source标签：video的子标签，可以为video标签指定多个媒体源,video按照从上到下的顺序检索第一个可以播放的视频源。</p>
<pre><code>&lt;video&gt;
    &lt;source src=&quot;1.mp4&quot;&gt;&lt;source&gt;
    &lt;source src=&quot;1.ogg&quot;&gt;&lt;source&gt;
&lt;/video&gt;</code></pre><p>source的属性：<br>src:媒体资源的路径<br>type:媒体资源文件的类型，例如 type=“video/mp4”<br>media:播放媒体的客户端类型，默认all<br>兼容性的解决方案：使用source标签指定多个媒体源以及flash资源：</p>
<pre><code>&lt;video width=&quot;1000&quot; height=&quot; 600&quot; controls=&quot;controls&quot;&gt;
    &lt;source src=&quot;mp4/1.1 spring概述.mp4&quot;&gt;&lt;/source&gt;
    &lt;object width=&quot;&quot; height=&quot;&quot; type=&quot;application/x-shockwave-flash&quot; data=&quot;flash/11.swf&quot;&gt;
        &lt;param name=&quot;movie&quot; value=&quot;flash/11.swf&quot; /&gt;
    &lt;/object&gt;
    //当前浏览器不支持video直接撟放，点击这里下载视频:
    &lt;a href=&quot;myvideo.webm&quot;&gt;下载视频&lt;/a&gt;
&lt;/video&gt;</code></pre><p>浏览器会选择可以加载的第一个视频资源播放，降低了浏览器无法播放的风险。</p>
<h3 id="3-2-2video对象"><a href="#3-2-2video对象" class="headerlink" title="3.2.2video对象"></a>3.2.2video对象</h3><p>video对象(HTMLVideoElement)：video标签的DOM对象。封装了控制视频播放的属性及方法。如下属性为dom属性<br>只读属性：<br>duration：媒体文件的播放时间长度，以秒为单位。<br>paused：获取视频是否为暂停状态。<br>ended:获取视频是否为结束状态。<br>startTime:返回最早的播放开始时间，一般是0<br>error：返回错误状态。<br>currentSrc：返回当前播放或已经加载文件的路径<br>videoWidth、videoHeight：返回视频的固有或自适应的宽度和高度。</p>
<p>控制属性：<br>autoplay：设定或获取自动播放。<br>loop：设定或获取是否自动循环。<br>currentTime:设定获取当前播放的时间。<br>controls:设定或获取是否有控制条<br>volume：设定或获取当前音量（0-1）。<br>muted：设定或获取是否静音。<br>autobuffer：通知播放器在播放开始前是否进行缓冲加载，在autoplay设定的情况下，无法使用。<br>width、height：设定视频显示大小，但有可能与视频固有高度宽度不符合。</p>
<p>video的控制函数：<br><img src="/2020/04/24/H5/image588.png" alt><br>video的私有事件类型<br><img src="/2020/04/24/H5/image589.png" alt></p>
<h3 id="3-2-3案例"><a href="#3-2-3案例" class="headerlink" title="3.2.3案例"></a>3.2.3案例</h3><pre><code>&lt;video src=&quot;video/演员.mp4&quot; 
controls=&quot;controls&quot; autoplay=&quot;autoplay&quot; width=&quot;300px&quot; loop=&quot;loop&quot;&gt;&lt;/video&gt;</code></pre><p>可以通过设置属性，控制video的显示和播放。<br>Controls:控制条<br>Autoplay：自动播放<br>Width:宽度<br>Height：高度<br>Loop：循环播放</p>
<p>为了处理浏览器的兼容性问题，经常需要做如下处理</p>
<pre><code>&lt;video&gt;
    &lt;source src=&quot;video/演员.mp4&quot;&gt;&lt;/source&gt;
    &lt;source src=&quot;video/演员.ogg&quot;&gt;&lt;/source&gt;
    &lt;source src=&quot;video/演员.webm&quot;&gt;&lt;/source&gt;
    &lt;!-- 插件播放的代码 --&gt;
    您的浏览器不支持，请您更新版本或者下载插件，链接
&lt;/video&gt;</code></pre><p>我们还可以通过video对象的属性和方法来控制显示和播放</p>
<pre><code>&lt;script&gt;
    //首先video
    var video = document.getElementsByTagName(&quot;video&quot;)[0];
    //设置controls
    video.controls = true;
    //设置播放
    video.play();
&lt;/script&gt;</code></pre><p><a href="./H5/20200423/02-video.html">查看效果</a></p>
<h2 id="3-3音频"><a href="#3-3音频" class="headerlink" title="3.3音频"></a>3.3音频</h2><p>目前audio支持的三种视频格式：<br><img src="/2020/04/24/H5/image590.png" alt><br>audio标签的属性说明： autio具备html全局属性，同时具备如下私有属性（audio基本上具备了出调节大小外的全部video的功能。其余参见手册）<br><img src="/2020/04/24/H5/image591.png" alt></p>
<h1 id="4canvas与svg"><a href="#4canvas与svg" class="headerlink" title="4canvas与svg"></a>4canvas与svg</h1><h2 id="4-1Canvas简介"><a href="#4-1Canvas简介" class="headerlink" title="4.1Canvas简介"></a>4.1Canvas简介</h2><p>Canvas：可以使用 JavaScript 在网页上绘制图像。<br>基本特点：<br>画布是一个矩形区域，您可以使用画笔在此矩形区域内制图，画笔是javascript控制的canvas接口。<br>可以在画布中嵌入图片、文字等其他html元素。<br>画布的提供了阴影渐变等内置api接口，辅助制图。<br>画布提供了内嵌视频的功能。<br>使用画布可以制作小游戏，如果需要制作大规模网游，需要借助第三方游戏引擎。<br>canvas的核心组成：<br><img src="/2020/04/24/H5/image592.png" alt><br>Canvas标签：<br>默认值：300pxX150px的矩形区域。<br>注意事项：在h5规范中with、height为非负整数，但主流浏览器都支持像素修饰（建议使用非负整数，代表像素）。</p>
<pre><code>&lt;canvas id=&quot;myCanvas&quot; width=&quot;600&quot; height=&quot;500&quot;&gt;
&lt;/canvas&gt;</code></pre><p>运行环境对象（ CanvasRenderingContext2D ）：封装了在画布上绘图的属性和方法。。<br>运行环境对象的获取方式：</p>
<pre><code>var canvas = document.getElementByld(&quot;canvas&quot;);
var context = canvas.getContext(&quot;2d&quot;);//也可以通过dom对象
获取webgl对象(本次课程只讨论2d效果的canvas制作)</code></pre><p>canvas转存为图片的方式：canvas.toDataURL(“image/png”,0.1)<br>–param1：图片的mime类型<br>–param2:取值范围是（0.1—1）表示图片的质量。</p>
<p>Canvas的入门程序（使用canvas绘制一条蓝色直线)。</p>
<pre><code>context.beginPath();
context.moveTo(100,100);
context.lineTo(200,200);
context.strokeStyle=&quot;blue&quot;;
context.stroke();</code></pre><p>beginPath();开始直线的绘图；<br>moveTo(x,y);将绘图的位置移动到坐标所在位置。<br>lineTo(x,y);设定直线的结束位置坐标。<br>strokeStyle:设定直线或边线的样式（此处为颜色）。<br>stroke():运行环境开始填充边线。</p>
<h3 id="4-1-1绘制直线"><a href="#4-1-1绘制直线" class="headerlink" title="4.1.1绘制直线"></a>4.1.1绘制直线</h3><p>绘制直线的主要API介绍：<br>beginPath() ：开始一个画布中的一条新路径。<br>moveTo(x,y) ：设定起始路径。<br>lineTo(x,y):以直线的方式绘制到指定坐标点，需要调用stroke才能显示。<br>stroke() : 使用线段的方式绘制路径。<br>lineWidth属性：设定线条宽度。<br>strokeStyle：指定路径的颜色、模式和渐变。<br>lineCap：指定线条的末端如何绘制。合法的值是 “butt”、”round” 和 “square”。默认值是 “butt”。<br>lineJoin：设定直线的连接点。取值范围是round/bevel/miter<br>绘制直线：<br>    <body><br>        <canvas id="canvas" width="500px" height="300px"></canvas><br>    </body><br>    <style><br>        #canvas{<br>            border: 1px solid #000;<br>        }<br>    </style><br>    <script><br>        //获取canvas对象<br>        var c = document.getElementById("canvas");<br>        //获取去上下文对象<br>        var context = c.getContext("2d");<br>        //开始<br>        context.beginPath();<br>        //给个起点<br>        context.moveTo(100,50);<br>        //给个终点<br>        context.lineTo(400,200);<br>        context.lineWidth = "5";<br>        //设置颜色<br>        context.strokeStyle="#00f";<br>        //结束<br>        context.stroke();<br>    </script><br><a href="./H5/20200423/03-canvas.html">查看效果</a></p>
<h3 id="4-1-2绘制矩形"><a href="#4-1-2绘制矩形" class="headerlink" title="4.1.2绘制矩形"></a>4.1.2绘制矩形</h3><pre><code>var canvas = document. getElementById(&quot;canvas&quot;) ;
var context = canvas . getContext (&quot;2d&quot;) ;
context . beginPath() ;
context. strokeRect (100, 100, 50, 50) ;
context. fillRect (100, 100, 50, 50) ;
context.clearRect (100, 100,50,50) ;

&lt;body&gt;
    &lt;canvas id=&quot;canvas&quot; width=&quot;300px&quot; height=&quot;150px&quot;&gt; &lt;/canvas&gt;
&lt;/body&gt;
&lt;style&gt;
    #canvas{
        border: 1px solid #000;
    }
&lt;/style&gt;
&lt;script&gt;
    //获取canvas
    var c = document.getElementById(&quot;canvas&quot;);
    //获取上下文
    var context = c.getContext(&quot;2d&quot;);
    //准备绘制
    context.beginPath();
    context.strokeStyle = &quot;#00f&quot;;
    //绘制边线
    context.strokeRect(50,25,200,100);
    //填充颜色
    context.fillStyle = &quot;#f00&quot;;
    //填充内部
    context.fillRect(50,25,200,100);        
&lt;/script&gt;</code></pre><p><a href="./H5/20200423/04-绘制矩形.html">查看效果</a></p>
<h3 id="4-1-3绘制圆形"><a href="#4-1-3绘制圆形" class="headerlink" title="4.1.3绘制圆形"></a>4.1.3绘制圆形</h3><p>绘制圆形的主要API介绍：<br>arc(x, y, radius, startAngle, endAngle, counterclockwise)<br><img src="/2020/04/24/H5/image593.png" alt></p>
<pre><code>&lt;body&gt;
    &lt;canvas id=&quot;canvas&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;style&gt;
    #canvas{
        border:1px solid #000;
    }
&lt;/style&gt;
&lt;script&gt;
    var c = document.getElementById(&quot;canvas&quot;);
    var context = c.getContext(&quot;2d&quot;);
    //绘制
    context.beginPath();
    //圆心x坐标，y坐标，半径，开始角度，结束角度，是否逆时针
    context.arc(200,200,100,0,Math.PI*2,true);
    //填充颜色
    context.fillStyle = &quot;#f00&quot;;
    context.stroke();//外面的线
    context.fill();//填充圆的内部
&lt;/script&gt;</code></pre><p><a href="./H5/20200423/05-绘制圆形.html">查看效果</a></p>
<h2 id="4-2透明度背景与阴影设定"><a href="#4-2透明度背景与阴影设定" class="headerlink" title="4.2透明度背景与阴影设定"></a>4.2透明度背景与阴影设定</h2><p>Canvas中设定背景填充有如下几种方式：<br>背景颜色填充。<br>背景图片填充。<br>背景透明度设定。<br>背景渐变设定(了解)。<br>背景颜色填充的API介绍：<br>context.fillStyle:设定背景的样式，取值为颜色或背景图片。<br>context.stroke():以指定样式填充背景。<br>代码示例：</p>
<pre><code>context.fillStyle = &quot;red&quot;;
context.stroke();</code></pre><p>背景透明度设定API介绍：<br>globalAlpha：设定背景的透明度，取值为0-1的浮点数。<br>代码示例：</p>
<pre><code>context.globalAlpha = 0.5</code></pre><p>背景图片填充：可以作为背景的媒体：图片、Canvas元素、Video（一般选择图片作为背景）。<br>创建背景样式的方式</p>
<pre><code>context.createPattern(imgDom,type);</code></pre><p>imgDom：dom元素（图片、canvas、video）<br>type:背景的平铺方式.取值为repeat， repeat-x， repeat-y， 以及 no-repeat，默认情况是 repeat 。<br>代码示例</p>
<pre><code>var video = document.createElement(&quot;video&quot;);
video.width = 100;
video.height = 100;
video.src = &quot;0-课程介绍.mp4&quot;;
video.oncanplay = function() {
var pattern = ctx.createPattern(video,&quot;no-repeat&quot;);
ctx.fillStyle = pattern;
ctx.fillRect (100, 100, 300,300);</code></pre><p>为指定区域增加阴影需要使用如下属性：<br>context.shadowColor：设定阴影颜色，取值为颜色码。<br>context.shadowBlur:设定阴影的模糊等级，取值为整数。<br>context.shadowOffsetX：设定阴影的x轴偏移量，单位为像素。<br>context.shadowOffsetY：设定阴影的x轴偏移量，单位为像素。</p>
<p>Canvas提供了如下方法和属性来控制文字填充以及文字的字体样式等。<br>context.fillText(text,x,y):在指定位置填充文字内容。<br>context.strokeText(text,x,y):在指定位置以描边的方式填充文字内容。<br>    –text:文字内容。<br>    –x/y:文字所在的位置。（默认以xy所在位置开始）。<br>context.font：设定字体以及大小。<br>context.textAlign：设定字体水平方向上的对齐方式。 left||right|| center||start||end<br>context.textBaseline = 设定垂直方向上的对齐方式。取值范围是top||middle||bottom</p>
<p>图像绘制：使用网页上或dom对象中的图片图像绘制到canvas上。<br>方法介绍：</p>
<pre><code>context.drawlmage(imgdom,x,y,width,height)</code></pre><p>–imgdom:imgdom对象<br>–x/y：图像显示的左上角坐标。<br>–width/height:图像显示的大小。</p>
<pre><code>var img = new Image() ;
img.src = &quot;1.png&quot;;
img.onload = function() {
    context.drawImage (img, 100, 100, 300, 300);
}</code></pre><h2 id="4-3svg介绍"><a href="#4-3svg介绍" class="headerlink" title="4.3svg介绍"></a>4.3svg介绍</h2><p>什么是SVG？<br>SVG指可伸缩矢量图形 (Scalable Vector Graphics)<br>SVG用来定义用于网络的基于矢量的图形<br>SVG使用XML描述2D图形的语言。<br>SVG由若干元素组成，每个元素都支持特定事件处理。<br>canvas 与 SVG 的比较<br><img src="/2020/04/24/H5/image594.png" alt><br>使用svg的方式：svg为后缀，以xml为基本语法规则。，在页面上引用svg文件。<br><img src="/2020/04/24/H5/image595.png" alt><br>本案例为绘制一个以（100,50）为圆心，半径为40px，颜色为黑色的原型<br>引用svg文件:有如下几种方式引入svg文件（也可以将svg的代码写入到网页上，但不推荐使用）。<br>使用embed标签引入svg</p>
<pre><code>&lt;embed src=&quot;svg/7.2.svg&quot; width=&quot;300&quot; height=&quot;100”
type=&quot;image/svg+xmL&quot; pluginspage=&quot;http://www.adobe.com/svg/viewer/install/&quot;/&gt;</code></pre><p>使用object标签引入svg（已过时）</p>
<pre><code>&lt;object data=&quot;svg/7.2.svg&quot; width=&quot;300&quot; height=&quot;100&quot; type=&quot;image/svg+xmL&quot; codebase= &quot;http://www.adobe.com/svg/viewer/install/&quot;/&gt;</code></pre><p>使用iframe引入svg。</p>
<pre><code>&lt;iframe src=&quot;svg/7.2.svg&quot; width=&quot;300&quot; height= &quot;100&quot;&gt;
&lt;/iframe&gt;</code></pre><h1 id="5离线应用"><a href="#5离线应用" class="headerlink" title="5离线应用"></a>5离线应用</h1><h2 id="5-1离线应用简介"><a href="#5-1离线应用简介" class="headerlink" title="5.1离线应用简介"></a>5.1离线应用简介</h2><p>Webstorage：在浏览器获取服务器信息后，将信息缓存到客户端本地硬盘的技术。使用场景：<br>用户关闭浏览器后仍然可以在硬盘中读取信息，例如用户登录时的密码保存。<br>减少客户端与服务器端交互次数，提升效率。<br>离线应用时使用。<br>Webstorage功能分类：<br>cookie：早期webstorage的雏形，但能存储的内容少，依赖于Internet选项设置，信息存储不安全。（本次课程不包含）<br>非结构化数据存储：以名值对方式存储的信息。（localstorage、sessionstorage）。<br>本地数据库（索引数据库indexed DB）。<br>离线应用：系统脱离网络后仍能通过本地存储进行阅览。<br>使用场景分析：<br>微信的好友、历史信息可以离线阅读。<br>新闻类网站已阅览信息可以离线打开。<br>HTML5中提供的离线应用API<br>资源文件缓存(application storage)：将网页或app需要的程序、图片等文件进行本地化存储。<br>在线状态检测：客户端检索网络状态。<br>本地数据存储(web storage)：本地数据库与非格式化存储机制。<br>在线状态检测：<br>Html5中增加了用于判断网页加载时网络运行情况的属性。</p>
<pre><code>if (window.navigator.onLine == true) {
    alert(&quot;网页加载时连接网络&quot;);
} else {
    alert(&quot;网页加载时未能连接网络&quot;);
}</code></pre><p>Html5中增加了当网络状态改变时触发的事件。</p>
<pre><code>window.addEventListener (&quot;online&quot;,function() {
    alert(&quot;重新连接网络&quot;);
}) ;
window.addEventListener (&quot;offline&quot;,function() {
    alert(&quot;已经断网&quot;);
}) ;</code></pre><h2 id="5-2localstorage与sessionstorage"><a href="#5-2localstorage与sessionstorage" class="headerlink" title="5.2localstorage与sessionstorage"></a>5.2localstorage与sessionstorage</h2><p>sessionStorage ：用于在当前一个域名下存储公用的物理内存对象，当用户关闭某一个域的网页后自动清空。<br>sessionStorage大小限制：每款浏览器不同，以chrom为例，sessionStorage的最大限制为2.5m。<br>sessionStorage的访问限制：<br>窗口必须在同一个域内。<br>网页在一个浏览器窗口下，或新窗口由旧窗口打开。<br>关闭网页时缓存清除。</p>
<p>使用场景</p>
<ul>
<li>系统登陆后保存用户基本信息</li>
<li>在网购时,多个页面共享购物清单</li>
</ul>
<p>sessionStorage主要API介绍（与localstorage相同）。<br>length：返回当前域名已经保存的信息数量。<br>setItem(“key”,”value”):设定存储信息，也可以对象的赋值方式。<br>getItem（“key”）:获取存储信息。<br>key(index):获取指定位置的key值。<br>removeItem(“key”):删除指定key值得数据信息。<br>clear():删除当前域名下所有存储信息。</p>
<p>localStorage ：用于在当前一个域名下存储公用的物理内存对象，与sessionStorage使用方式完全一致，但永久保存。<br>localStorage大小限制：每款浏览器不同，一般500万字符左右。<br>localStorage的访问限制：<br>localstorage只能被不同窗口的同一个网页地址所共享。<br>localStorage的数据信息将永久保留，需要程序删除信息。<br>使用场景：记录各个网站的登录名、登录密码。</p>
<h3 id="5-2-1模拟登录案例"><a href="#5-2-1模拟登录案例" class="headerlink" title="5.2.1模拟登录案例"></a>5.2.1模拟登录案例</h3><p>localStorage的基本用法：</p>
<pre><code>&lt;script&gt;
    //模拟登录
    //向localstorage存入值
    var storage  = window.localStorage;
    //存值,如果键相同，就是修改，一旦存入永远都有效
    storage.setItem(&quot;username&quot;,&quot;jack&quot;);
    storage.setItem(&quot;password&quot;,&quot;123&quot;);
    //键相同，就是修改
    storage.setItem(&quot;username&quot;,&quot;rose&quot;);
    storage.setItem(&quot;password&quot;,&quot;456&quot;);
    //移除内容
    storage.removeItem(&quot;username&quot;);
    storage.removeItem(&quot;password&quot;);
&lt;/script&gt;</code></pre><p>模拟登录操作：</p>
<pre><code>&lt;body&gt;
    &lt;form&gt;
        &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot;&gt;&lt;br&gt;
        &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密吗&quot;&gt;&lt;br /&gt;
        &lt;input type=&quot;button&quot; value=&quot;登录&quot; id=&quot;login&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;script&gt;
    //模拟登录
    //向localstorage存入值
    var storage  = window.localStorage;
    //存值,如果键相同，就是修改，一旦存入永远都有效
    storage.setItem(&quot;username&quot;,&quot;jack&quot;);
    storage.setItem(&quot;password&quot;,&quot;123&quot;);
    //键相同，就是修改
    storage.setItem(&quot;username&quot;,&quot;rose&quot;);
    storage.setItem(&quot;password&quot;,&quot;456&quot;);
    //移除内容
    storage.removeItem(&quot;username&quot;);
    storage.removeItem(&quot;password&quot;);
    //用户信息
    storage.setItem(&quot;jack&quot;,&quot;123&quot;);
    console.log(storage);
    //点击登录，获取用户名和密吗
    var login = document.getElementById(&quot;login&quot;);
    //为它添加点击事件
    login.onclick = function(){
        //获取用户名和密吗
        var username = document.getElementsByName(&quot;username&quot;)[0].value.trim();
        var password = document.getElementsByName(&quot;password&quot;)[0].value.trim();
        //要与本地中的数据对比，如果能找到，就登录成功
        //一个一个对比
        for(var i = 0;i&lt;storage.length;i++){
            //判断键是否为用户名
            if(storage.key(i)==username){
                //判断值与密码是否相同
                if(storage.getItem(username)==password){
                    alert(&quot;登录成功！&quot;)
                }
            }else{
                    alert(&quot;登录失败&quot;);
            }
        }
    }
&lt;/script&gt;</code></pre><h2 id="5-3文件缓存"><a href="#5-3文件缓存" class="headerlink" title="5.3文件缓存"></a>5.3文件缓存</h2><p>资源文件缓存(application storage)：又称为应用程序缓存，将网页或app需要的程序、图片等文件进行本地化存储。<br>应用程序缓存为应用带来三个优势：<br>离线浏览 – 用户可在应用离线时使用它们<br>速度 – 已缓存资源加载得更快<br>减少服务器负载 – 浏览器将只从服务器下载更新过或更改过的资源。<br>应用程序缓存核心术语：</p>
<p>Bootstrap内容参考bootcss.com,bootstrap<br>App Cache:浏览器内置缓存程序组件，是整个浏览器应用程序缓存的实现，应用程序缓存最大为5M<br>Manifest文件：应用程序缓存的配置文件，由app cache读取，并缓存。</p>
<pre><code>&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot;&gt;
    &lt;script src=&quot;js/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
            &lt;div class=&quot;col-md-4&quot; style=&quot;background-color: red;height: 100px;&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;col-md-4&quot; style=&quot;background-color: green;height: 100px;&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;col-md-4&quot; style=&quot;background-color: blue;height: 100px;&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;img src=&quot;img/1.jpg&quot; class=&quot;img-circle&quot; width=&quot;200px&quot;&gt; 
    &lt;h1&gt;标题&lt;/h1&gt;

    &lt;span class=&quot;glyphicon glyphicon-grain&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;

    &lt;a href=&quot;#&quot;&gt;Inbox &lt;span class=&quot;badge&quot;&gt;42&lt;/span&gt;&lt;/a&gt;

    &lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot;&gt;
      Messages &lt;span class=&quot;badge&quot;&gt;4&lt;/span&gt;
    &lt;/button&gt;
&lt;/body&gt;</code></pre><p><img src="/2020/04/24/H5/image596.png" alt><br>postMessage：该方法是window对象的全局方法，提供了多个页面之间信息交互的方式。<br>postMessage解决的问题如下（传统的方式也可以解决）：<br>页面和其打开的新窗口的数据传递<br>多窗口之间消息传递<br>页面与嵌套的iframe消息传递<br>上面三个问题的跨域数据传递<br>postMessage的方法的使用，可以跨域访问。</p>
<p>–window:目标窗口的BOM对象。<br>–Str：传递的参数信息，不支持json，需要转换。<br>–Origin：域名（协议+ip+端口），可以用*替换，目的是安全验证。<br>代码示例（向当前网页的子网页myIframe传递信息）<br>离线缓存配置文件：以manifest结尾的文件<br><img src="/2020/04/24/H5/image597.png" alt><br>应用缓存的更新：一旦应用被缓存，则每次访问网页时都会从缓存中获取文件资源，而不去同步服务器资源。如下几种情况可以更新缓存文件。<br>用户清空浏览器缓存<br>manifest 文件被修改<br>调用App cache的接口程序来更新应用缓存。<br>App Cache组件：浏览器内置缓存程序组件，提供了一组操作离线缓存的事件以及接口。都封装在window.applicationCache对象中。<br>检测浏览器是否支持离线缓存的方式</p>
<p>判断离线缓存的状态：<br><img src="/2020/04/24/H5/image598.png" alt><br>手动更新离线缓存的方法：前提是manifest文件更改。<br>更新离线缓存：window.applicationCache.update()；<br>替换离线缓存。window.applicationCache.swapCache();</p>
<h1 id="6-PostMessage"><a href="#6-PostMessage" class="headerlink" title="6.PostMessage"></a>6.PostMessage</h1><p>postMessage的方法的使用，可以跨域访问。</p>
<pre><code>if (typeof window.postMessage == &apos;undefined&apos;) {
//不支持postmessage
}</code></pre><p>–window:目标窗口的BOM对象。<br>–Str：传递的参数信息，不支持json，需要转换。<br>–Origin：域名（协议+ip+端口），可以用*替换，目的是安全验证。<br>代码示例（向当前网页的子网页myIframe传递信息）</p>
<pre><code>document.myIframe.postMessage (JSON.stringify({userName:&apos;zhangsan&apos;}),
&quot;http://127.0.0.1:8020/html5Teach/&quot;);</code></pre><p>代码示例（子网页声明接收信息的回调函数）</p>
<pre><code>window.addEventListener(&apos;message&apos;,function(e) {
    console.log(e.data);
    parent.postMessage(&quot;sss&quot;,&quot;*&quot;);
})</code></pre><p>特殊说明：<br>postMessage可以完成非同源网页之间的信息传递。<br>无法使用postMessage与服务器端程序交互。<br>Mvom = Htmlscript.inner;<br>XMLHttpRequest2：在xhr1的基础上扩展了若干功能，是发送ajax请求的升级版本。<br>XHR1的缺点如下：<br>只支持文本数据的传送，无法用来读取和上传二进制文件。<br>发送请求时无法跟踪请求的进度。<br>受到“同域限制”。<br>XHR2的升级内容如下：<br>设置HTTP请求的时限。<br>可以使用FormData对象管理表单数据以及上传文件。<br>发送跨域请求。<br>获取数据传输的进度。<br>跨域资源共享（ CORS ）：XHR2提供了跨域资源共享模式，允许ajx请求的跨域访问，前提是浏览器必须支持这个功能，而且服务器端必须同意这种”跨域”。<br>nodejs的express框架跨域配置方式：</p>
<pre><code>appal(&apos;*&apos;,function(req, res, next) {
    res.header(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);
    res.set(&apos;Access-Control-Allow-Headers&apos;,&apos;Content-Type&apos;);
    res.set(&apos;Access-Control-Allow-Methods&apos;,&apos;GET,POST,DELETE,PUT&apos;);
    next();
});</code></pre><p>设置HTTP请求的时限：XHR2增加了timeout属性，可以设置HTTP请求的时限，超过时限自动停止本次请求。</p>
<h1 id="7-请求的进度：XHR2增加了若干请求状态以及进度事件。"><a href="#7-请求的进度：XHR2增加了若干请求状态以及进度事件。" class="headerlink" title="7.请求的进度：XHR2增加了若干请求状态以及进度事件。"></a>7.请求的进度：XHR2增加了若干请求状态以及进度事件。</h1><pre><code>var xhr = new XMLHttpRequest();
xhr.onprogress = function(e) {
    console.log(e.total);
    console.log(e.loaded);
    console.1og (e.lengthComputable);
}
xhr.onload = function() {
    alert (&quot;上传成功&quot;);
}
xhr.onerror = function() {
    alert (&quot;上传失败&quot;);
}</code></pre><p>“后面的”是侯建了。<br>XHR2增加了timeout事件类型，当超出时限时调用，常用语消息提醒。<br>获取若干了状态与了<br>Webworker：window的内置对象，通过webworker可以以多线程的方式执行多个js文件。<br><img src="/2020/04/24/H5/image599.png" alt><br>子线程文件中无法访问dom接口，但可以访问例如xhr等接口。<br>子线程只能够动态引入其他js文件，但其他js文件无法使用DOM接口。<br>主线程与子线程的通信通过postMessage方法。</p>
<p>Bootstrap内容参考bootcss.com,bootstrap<br>App Cache:浏览器内置缓存程序组件，是整个浏览器应用程序缓存的实现，应用程序缓存最大为5M<br>Manifest文件：应用程序缓存的配置文件，由app cache读取，并缓存。</p>
<pre><code>&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot;&gt;
    &lt;script src=&quot;js/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
            &lt;div class=&quot;col-md-4&quot; style=&quot;background-color: red;height: 100px;&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;col-md-4&quot; style=&quot;background-color: green;height: 100px;&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;col-md-4&quot; style=&quot;background-color: blue;height: 100px;&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;img src=&quot;img/1.jpg&quot; class=&quot;img-circle&quot; width=&quot;200px&quot;&gt; 
    &lt;h1&gt;标题&lt;/h1&gt;

    &lt;span class=&quot;glyphicon glyphicon-grain&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;

    &lt;a href=&quot;#&quot;&gt;Inbox &lt;span class=&quot;badge&quot;&gt;42&lt;/span&gt;&lt;/a&gt;

    &lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot;&gt;
      Messages &lt;span class=&quot;badge&quot;&gt;4&lt;/span&gt;
    &lt;/button&gt;
&lt;/body&gt;</code></pre><p><img src="/2020/04/24/H5/image600.png" alt><br>postMessage：该方法是window对象的全局方法，提供了多个页面之间信息交互的方式。<br>postMessage解决的问题如下（传统的方式也可以解决）：<br>页面和其打开的新窗口的数据传递<br>多窗口之间消息传递<br>页面与嵌套的iframe消息传递,可能去掉了元素隐藏与现实的透明度<br>上面三个问题的跨域数据传递<br>postMessage的方法的使用，可以跨域访问。</p>
<p>–window:目标窗口的BOM对象。<br>–Str：传递的参数信息，不支持json，需要转换。<br>–Origin：域名（协议+ip+端口），可以用*替换，目的是安全验证。<br>代码示例（向当前网页的子网页myIframe传递信息）<br>离线缓存配置文件：以manifest结尾的文件<br><img src="/2020/04/24/H5/image601.png" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jinyeeeee.github.io/2020/04/24/H5/" data-id="ck9i6u3h80008g8v0a6ssarnr"
         class="article-share-link">分享</a>
      
    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2020/04/24/H5/20200423/02-video/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            H5/20200423/02-video
          
        </div>
      </a>
    
    
      <a href="/2020/04/24/Jquery/20200422/js/jquery-1.9.1.min/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Jquery/20200422/js/jquery-1.9.1.min</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
    </div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/technology.js"></script>

  </div>
</body>
</html>