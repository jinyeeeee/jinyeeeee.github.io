<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    java3 |
    
    yuchen</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/technology.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <section class="outer">
  <article id="post-java3" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java3
    </h1>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2020/04/15/java3/" class="article-date">
  <time datetime="2020-04-15T08:48:13.000Z" itemprop="datePublished">2020-04-15</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h2 id="XML："><a href="#XML：" class="headerlink" title="XML："></a>XML：</h2><p><strong>XML 指可扩展标记语言（EXtensible Markup Language）</strong><br>XML 的<strong>设计宗旨是传输数据，而不是显示数据</strong><br>XML 标签<strong>没有被预定义，需要自行定义标签</strong><br>XML 被设计为具有自我描述性，不依赖与语言平台<br>XML 是 <strong>W3C 的推荐标准</strong><br> XML 不会做任何事情，XML 被设计用来结构化、存储以及传输信息：<br>红包的作用和XML文件一样，本身只是一个数据的封装格式，而里面存放的具体内容才是关键<br>1、XML文件版本及字符编码集声明<br>2、XML允许编写人员定义自己的标签和自己的文档结构<br>实例中的标签没有在任何XML标准中定义过（比如 <to> 和 <from>）。这些标签是由我们编写该XML文档时自定义的，这是因为XML语言没有预定义的标签</from></to></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;note&gt;
  &lt;to&gt;Tove&lt;/to&gt;
  &lt;from&gt;Jani&lt;/from&gt;
  &lt;heading&gt;Reminder&lt;/heading&gt;
  &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;
&lt;/note&gt;</code></pre><p>这条便签具有自我描述性，它包含了发送者和接受者的信息，同时拥有标题以及消息主体<br>这个 XML 文档不会做任何事情，它仅仅是包装在 XML 标签中的纯粹的信息。我们需要编写程序，才能传送、接收和解析这个文档（XML 和JSON是目前各种应用程序之间进行数据传输的最常用的格式）<br>XML文件形成了一种树结构，它从“根部”开始，然后扩展到“枝叶”<br>XML 文档必须包含根节点。该节点是所有其他节点的父节点（<strong>一个XML文档有且只有一个根节点</strong>）<br>XML 文档中的<strong>节点元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端，所有的元素都可以有子元素：</strong><br><img src="/2020/04/15/java3/image334.png" alt><br>父、子以及同胞等术语用于描述节点元素之间的关系。父元素拥有子元素。相同层级上的子元素成为同胞（兄弟或姐妹），所有的元素都可以有文本内容和属性，一个经典实例：<br><img src="/2020/04/15/java3/image335.png" alt><br>将上例树状结构转换为XML文档后的示例如下：<br><img src="/2020/04/15/java3/image336.png" alt></p>
<p>拥有正确语法的 XML 被称为“形式良好”的 XML，通过 DTD 验证的XML是“合法”的 XML，“形式良好”的 XML 文档拥有正确的语法：<br><strong>XML文档必须有一个根元素<br>XML节点元素都必须有一个关闭标签<br>XML标签对大小写敏感<br>XML元素必须被正确的嵌套<br>XML属性值必须加引号</strong><br><img src="/2020/04/15/java3/image337.png" alt><br><img src="/2020/04/15/java3/image338.png" alt></p>
<p>W3C 支持一种基于 XML 的 DTD 代替者，它名为 XML Schema：<br><img src="/2020/04/15/java3/image339.png" alt><br><?xml version="1.0" encoding="UTF-8"?><br><web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemalocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"><br></web-app></p>
<h2 id="DOM、SAX区别"><a href="#DOM、SAX区别" class="headerlink" title="DOM、SAX区别"></a>DOM、SAX区别</h2><p>一般情况下，程序中对XML文档进行解析可以使用两种方式：DOM和SAX：<br>DOM：<br>Document Object Model，文档对象模型，将整个文档加载进内存并分析整颗树的数据结构，根据节点元素之间的父子关系完成整棵树上所有节点的遍历<br>优势：符合XML树的数据结构逻辑定义，可以对树结构进行修改<br>劣势：需要完整加载文档，对于LDAP领域等能够产生超大型XML文档的环境明显不适用<br>SAX:<br>Simple API for XML,针对XML文档的事件驱动解析引擎，逐行对文档进行分析，遇到文档的特定组成部分后回调预先定义的事件回调<br>优势：无需预先完整加载文档，不会对程序的运行时内存造成毁灭性影响<br>劣势：不符合XML文档的本质数据结构，只能用来解析遍历，而不能修改<br><img src="/2020/04/15/java3/image340.png" alt><br><img src="/2020/04/15/java3/image341.png" alt></p>
<pre><code>public class DocumentTest {
    public static void main(String[] args) throws ParserConfigurationException, FileNotFoundException, SAXException, IOException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = factory.newDocumentBuilder();
        Document doc = db.parse(new FileInputStream(&quot;src/note.xml&quot;));
        Node n = doc.getDocumentElement();
        NodeList links = n.getChildNodes();
        for (int i = 0; i &lt; links.getLength(); i++) {
            Node node = links.item(i);
            NodeList links2 = node.getChildNodes();
            for (int j = 0; j &lt; links.getLength(); j++) {
                Node node2 = links2.item(j);
                if(node2!=null &amp;&amp; node2.getNodeType()==node2.TEXT_NODE)
                    System.out.println(node.getNodeName()+&quot;: &quot;+node2.getNodeValue());                
            }

        }
    }
}</code></pre><p>结果</p>
<pre><code>to: Tove
from: Jani
heading: Reminder
body: Don&apos;t forget me this weekend!</code></pre><p>对DOM节点进行修改后，可以利用Transformer API将DOM结构还原为XML文档:<br><img src="/2020/04/15/java3/image342.png" alt><br><img src="/2020/04/15/java3/image343.png" alt></p>
<h2 id="SAX解析"><a href="#SAX解析" class="headerlink" title="SAX解析"></a>SAX解析</h2><p>SAX同样也有参考实现，相对DOM，其代码结构相对要复杂一些， 其中的核心是需要首先实现预定义的事件处理器<br>事件处理器由org.xml.sax.ContentHandler接口声明，在JDK中也提供了该接口的一个默认实现，叫DefaultHandler，我们在实现自定义事件处理器时可以继承该类，事件处理器中几个必要的重要方法如下：<br><img src="/2020/04/15/java3/image344.png" alt></p>
<pre><code>public class MyHandler extends DefaultHandler{
    StringBuffer sb = new StringBuffer();
    //读取每一行的字符数据
    @Override
    public void characters(char[] ch, int start, int length) throws SAXException {
        sb.append(new String(ch,start,length));
    }
    //读取到最后的时候输出数据
    @Override
    public void endElement(String uri, String localName, String qName) throws SAXException {
        if(!&quot;note&quot;.equals(qName)) {
            System.out.println(qName+&quot;: &quot;+sb.toString());
        }
    }
    //读取新行
    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
        sb = new StringBuffer();
    }
}


public class SAXTest {

    public static void main(String[] args) throws SAXException, ParserConfigurationException, FileNotFoundException, IOException {
        /**
         * 获取工厂，SAX解析器，xml读取对象
         */
        XMLReader xmlReader = SAXParserFactory.newInstance()
                        .newSAXParser()
                        .getXMLReader();
        //设置事件处理器
        xmlReader.setContentHandler(new MyHandler());
        //数据读取
        xmlReader.parse(new InputSource(new FileInputStream(&quot;src/note.xml&quot;)));
    }
}</code></pre><h2 id="常用第三方解析工具简介"><a href="#常用第三方解析工具简介" class="headerlink" title="常用第三方解析工具简介"></a>常用第三方解析工具简介</h2><p>常见的第三方XML解析器主要有以下几种：<br>JDOM<br>DOM4J<br>Google随Android推出的结合DOM和SAX的Pull<br>JDOM和DOM4J的结构非常类似JDK中提供的JAXP（即之前章节介绍的DOM和SAX的JDK参考实现），均是比较知名的开源解析组件<br>Pull方式将在后续的课程中详细介绍</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>XML文档有什么特点？<br>DOM和SAX方式解析XML有什么区别？<br>XML文档构建除了一棵树，XML文档必须有一个根元素，XML节点元素都必须有一个关闭标签，XML标签对大小写敏感，XML元素必须被正确的嵌套，XML属性值必须加引号<br>DOM：Document Object Model，文档对象模型，将整个文档加载进内存并分析整颗树的数据结构，根据节点元素之间的父子关系完成整棵树上所有节点的遍历，优势：符合XML树的数据结构逻辑定义，可以对树结构进行修改，劣势：需要完整加载文档，对于LDAP领域等能够产生超大型XML文档的环境明显不适用。SAX:Simple API for XML,针对XML文档的事件驱动解析引擎，逐行对文档进行分析，遇到文档的特定组成部分后回调预先定义的事件回调，优势：无需预先完整加载文档，不会对程序的运行时内存造成毁灭性影响，劣势：不符合XML文档的本质数据结构，只能用来解析遍历，而不能修改。</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>什么是JSON？<br>JSON指的是 JavaScript 对象表示法（JavaScript Object Notation）<br>JSON是轻量级的文本数据交换格式，类似 XML，JSON 比 XML 更小、更快，更易解析<br>JSON独立于语言<br>JSON 具有自我描述性，更易理解<br><strong>JSON和XML的异同，相同处：</strong><br>是纯文本<br>具有”自我描述性”（人类可读）<br>具有层级结构（值中存在值）<br>不同处：<br>没有结束标签<br>更短<br>读写的速度更快<br>能够使用内建的 JavaScript eval() 方法进行解析<br>使用数组<br>不使用保留字</p>
<p><strong>JSON 语法是 JavaScript 对象表示法语法的子集：</strong><br><strong>数据在名称/值对中，名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：，JSON 值可以是：数字（整数或浮点数）、字符串（在双引号中）、逻辑值（true 或 false）、数组、对象、null</strong><br><strong>数据由逗号分隔</strong><br><strong>大括号保存对象{ }</strong><br><strong>中括号保存数组[ ]</strong></p>
<p>JSON 对象在大括号({})中书写，对象可以包含多个 key/value（键/值）对<br>key 必须是字符串，value 可以是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）<br>key 和 value 中使用冒号(:)分割<br>每个 key/value 对使用逗号(,)分割<br>JSON对象示例：</p>
<pre><code>{
    &quot;id&quot;: 1,
    &quot;name&quot;: &quot;Java核心技术&quot;,
    &quot;author&quot;: {
        &quot;firstName&quot;: &quot;Abc&quot;,
        &quot;lastName&quot;: &quot;Xyz&quot;
    },
    &quot;isbn&quot;: &quot;1234567&quot;,
    &quot;tags&quot;: [&quot;Java&quot;, &quot;Network&quot;]
}</code></pre><p>JSON作为数据传输的格式，有几个显著的优点：</p>
<ul>
<li>JSON只允许使用UTF-8编码，不存在编码问题；</li>
<li>JSON只允许使用双引号作为key，特殊字符用\转义，格式简单；</li>
<li>浏览器内置JSON支持，如果把数据用JSON发送给浏览器，可以用JavaScript直接处理。</li>
</ul>
<p>因此，JSON适合表示层次结构，因为它格式简单，仅支持以下几种数据类型：</p>
<ul>
<li><p>键值对：{“key”: value}</p>
</li>
<li><p>数组：[1, 2, 3]</p>
</li>
<li><p>字符串：”abc”</p>
</li>
<li><p>数值（整数和浮点数）：12.34</p>
</li>
<li><p>布尔值：true或false</p>
</li>
<li><p>空值：null<br>GSON库<br>Gson是Google提供的一个能够将Java对象转换成相应JSON表达形式的一个开源Java类库，当然用Gson也能将JSON字符串转换成与之等价的Java对象。Gson对于任何Java对象都有效，包括那些预先存在没有源代码的对象<br>新建Lib文件夹—-&gt;复制GSON.jar到文件夹中—-&gt;鼠标点击右键 Build path——&gt;addbuildPath</p>
<pre><code>public class GsonTest {
public static void main(String[] args) {
    Student s = new Student(&quot;15&quot;,&quot;zhangbo&quot;,20);
    Gson g = new Gson();
    String json = g.toJson(s);
    System.out.println(json);
    Student stu = g.fromJson(json, Student.class);
    System.out.println(stu);
    System.out.println(&quot;------------------&quot;);
    List&lt;Student&gt; list = new ArrayList&lt;&gt;();
    list.add(new Student(&quot;16&quot;,&quot;lisi&quot;,45));
    list.add(new Student(&quot;17&quot;,&quot;zhaowo&quot;,60));
    list.add(new Student(&quot;19&quot;,&quot;zhouwi&quot;,85));
    list.add(new Student(&quot;20&quot;,&quot;zhengwu&quot;,90));
    String json2 = g.toJson(list);
    System.out.println(json2);
    List&lt;Student&gt; stu2 = g.fromJson(json2, new TypeToken&lt;List&lt;Student&gt;&gt;() {}.getType());
    for (Student student : stu2) {
        System.out.println(student);
    }
    System.out.println(&quot;--------------------&quot;);
    Map&lt;String,Student&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;16&quot;, new Student(&quot;16&quot;,&quot;lisi&quot;,45));
    map.put(&quot;17&quot;, new Student(&quot;17&quot;,&quot;zhaowo&quot;,60));
    map.put(&quot;19&quot;, new Student(&quot;19&quot;,&quot;zhouwi&quot;,85));
    map.put(&quot;20&quot;, new Student(&quot;20&quot;,&quot;zhengwu&quot;,90));
    String json3 = g.toJson(map);
    System.out.println(json3);
    Map&lt;String,Student&gt; stu3 = (Map&lt;String,Student&gt;)g.fromJson(json3, new TypeToken&lt;Map&lt;String,Student&gt;&gt;({}.getType());
    Set&lt;String&gt; keySet = stu3.keySet();
    for (String string : keySet) {
        System.out.println(stu3.get(string));
    }
}
}</code></pre></li>
</ul>
<p>小结<br>GSON对JSON的处理基本流程是什么？</p>
<p>GSON是由Google推出的开源JSON处理工具，要将Java对象转换为JSON字符串首先创建Gson对象，然后使用该对象的toJson()方法即可，如果要将JSON字符串转换为Java对象，利用同样的Gson对象的fromJson()方法即可，如果是集合，则需要通过TypeToken对象提供对应的泛型类型。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式是一套代码设计经验的总结。项目中合理的运用设计模式可以巧妙的解决很多问题<br>要对设计模式的使用场景有一定的认识后才使用，<strong>不要滥用</strong>。<br>如：输出一句“hello world”，非要强行给加上各种模式。<br>问：“为什么”，答：“总感觉少了模式！”。<br>抱着代码虐我千百遍，我待代码如初恋的心态，最终得出来的优化构造套路</p>
<h2 id="总体来说设计模式可以分为三大类："><a href="#总体来说设计模式可以分为三大类：" class="headerlink" title="总体来说设计模式可以分为三大类："></a>总体来说<strong>设计模式可以分为三大类</strong>：</h2><p><strong>创建型模式</strong><br><strong>工厂方法模式、抽象工厂模式、单例模式</strong>、建造者模式、原型模式<br><strong>结构型模式</strong><br>适配器模式、装饰器模式、<strong>代理模式</strong>、外观模式、桥接模式、组合模式、享元模式<br><strong>行为型模式</strong><br>策略模式、模板方法模式、<strong>观察者模式</strong>、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</p>
<h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则:"></a>设计模式的<strong>六大原则</strong>:</h2><h3 id="开闭原则（Open-Close-Principle）"><a href="#开闭原则（Open-Close-Principle）" class="headerlink" title="开闭原则（Open Close Principle）"></a><strong>开闭原则（Open Close Principle）</strong></h3><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使<strong>程序的扩展性好，易于维护和升级</strong>。想要达到这样的效果，我们需要使用<strong>接口和抽象类</strong>。</p>
<h3 id="里氏代换原则（Liskov-Substitution-Principle）"><a href="#里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle）"></a><strong>里氏代换原则（Liskov Substitution Principle）</strong></h3><p>里氏代换原则是<strong>面向对象设计的基本原则之一</strong>。 里氏代换原则中说，<strong>任何基类可以出现的地方，子类一定可以出现</strong>。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以<strong>里氏代换原则是对实现抽象化的具体步骤的规范</strong>。</p>
<h3 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h3><p>这个原则是开闭原则的基础，具体内容：<strong>针对接口编程，依赖于抽象而不依赖于具体</strong>。</p>
<h3 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h3><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：<strong>降低类之间的耦合度</strong>。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，<strong>它强调降低依赖，降低耦合。</strong></p>
<h3 id="迪米特法则，又称最少知道原则（Demeter-Principle）"><a href="#迪米特法则，又称最少知道原则（Demeter-Principle）" class="headerlink" title="迪米特法则，又称最少知道原则（Demeter Principle）"></a>迪米特法则，又称最少知道原则（Demeter Principle）</h3><p>最少知道原则是指：<strong>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立</strong>。</p>
<h3 id="合成复用原则（Composite-Reuse-Principle）"><a href="#合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="合成复用原则（Composite Reuse Principle）"></a>合成复用原则（Composite Reuse Principle）</h3><p>合成复用原则是指：<strong>尽量使用合成/聚合的方式，而不是使用继承</strong>。<br><img src="/2020/04/15/java3/image345.png" alt></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Sigleton，她们只要说道“老公”，都是指的同一个人，那就是我<br>别否认，单例模式就是你的梦想<br>单例模式是Java中最简单的设计模式之一。<strong>这种类型的设计模式属于创建型模式</strong>，<strong>它提供了一种创建对象的最佳方式</strong><br><strong>单例模式确保在一个应用程序中某一个类只有一个实例</strong>，而且自行实例化并向整个系统提供这个实例单例实例。单例模式只应在有真正的“单一实例”的需求时才可使用：<br><strong>单例类只能有一个实例</strong><br><strong>单例类必须自己创建自己的唯一实例</strong><br><strong>单例类必须给所有其他对象提供这一实例</strong></p>
<p>Java中实现单例模式可以通过两种形式实现：<br><strong>懒汉模式</strong>（类加载时不初始化）<br><strong>饿汉模式</strong>（在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快）</p>
<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>饿汉单例相对比较容易理解，一般表现为以下两种形式：<br><img src="/2020/04/15/java3/image346.png" alt><br><img src="/2020/04/15/java3/image347.png" alt></p>
<p>饿汉模式基于classloader机制避免了多线程的同步问题（静态初始化将保证在任何线程能够访问到域之前初始化它），不过，instance在类装载时就实例化，这时候初始化instance显然没有达到lazy loading的效果</p>
<h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>懒汉方式实现单例模式能够提高类加载性能，但是和饿汉模式借助与JVM的类加载内部同步机制实现了线程安全不同，需要在延迟加载时注意单例实例的线程安全性，如果简单粗暴的实现，在多线程环境中将引起运行异常，如：<br><img src="/2020/04/15/java3/image348.png" alt></p>
<p>多线程同时访问时可能会产生多个示例，甚至会破坏实例，违背单例的设计原则</p>
<p>可以为返回单例实例的方法设置同步用来保证线程安全性：<br><img src="/2020/04/15/java3/image349.png" alt></p>
<p>这种写法能够在多线程中很好的工作，而且看起来它也具备很好的lazy loading，但是，遗憾的是，由于整个方法被同步，<strong>因此效率相对较低</strong><br>之前提到了，静态初始化将在实例被任何线程访问到之前对其进行初始化，因此，可以借助于这个特性对懒汉单例进行改造：<br><img src="/2020/04/15/java3/image350.png" alt><br>JDK1.5之后引入了枚举，由于枚举的特性，可以利用其来实现单例，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象：<br><img src="/2020/04/15/java3/image351.png" alt></p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式主要是<strong>为创建对象提供过渡接口</strong>，以便<strong>将创建对象的具体过程屏蔽隔离起来</strong>，达到提高灵活性的目的<br>工厂模式在一般分为三类：</p>
<ul>
<li>简单工厂模式（Simple Factory）</li>
<li>工厂方法模式（Factory Method）</li>
<li>抽象工厂模式（Abstract Factory）</li>
</ul>
<p>这三种模式从上到下逐步抽象，并且更具一般性</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>又称静态工厂方法模式。从命名上就可以看出这个模式一定很简单。它存在的目的很简单：定义一个用于创建对象的接口，先来看看它的组成：</p>
<ul>
<li>工厂类角色:<br>这是本模式的核心，含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现</li>
<li>抽象产品角色:<br>它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。</li>
<li>具体产品角色:<br>工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。<br>话说多年前，有一个暴发户，他家有三辆汽车：Benz奔驰、Bmw宝马、Audi奥迪，还雇了司机为他开车。不过，暴发户坐车时总是怪怪的：上Benz车后跟司机说“开奔驰车！”，坐上Bmw后他说“开宝马车！”，坐上Audi说“开奥迪车！”。你一定说：这人有病！直接说开车不就行了？！<br><img src="/2020/04/15/java3/image352.png" alt></li>
</ul>
<p>使用了简单工厂模式后，我们的程序不在“有病”，更加符合现实中的情况；而且客户端免除了直接创建产品对象的责任，而仅仅负责“消费”产品（正如暴发户所为）<br>可以从开闭原则上来分析简单工厂模式。当暴发户增加了一辆车的时候，只要符合抽象产品制定的合同，那么只要通知工厂类知道就可以被客户使用了。所以对产品部分来说，它是符合开闭原则的；但是工厂部分好像不太理想，因为每增加一辆车，都要在工厂类中增加相应的业务逻辑或者判断逻辑，这显然是违背开闭原则的。可想而知对于新产品的加入，工厂类是很被动的</p>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>随着暴发户的生意越做越大，越来越有钱，于是乎他又买了几辆豪车-兰博基尼、保时捷、悍马…，由于车辆增加了，所有的汽车都要有老司机一个人管理，年检、保险、罚单、洗车，老司机一个人实在吃不消，而且老板会吩咐老司机从周一到周六要开不同款式的车外出，这个时候老司机就不得不记住老板哪天需要开哪辆车外出，于是乎给老板提议：给每台车都聘请一个司机，每辆汽车都有一个专门的人员负责，需要外出的时候招呼我一声，我就会派相应的人员过来接老板，老板毫不犹豫的说:就这么办…….<br>工厂方法模式是<strong>简单工厂模式的进一步抽象化和推广，工厂方法模式里不再只由一个工厂类决定那一个产品类应当被实例化,这个决定被交给抽象工厂的子类去做</strong>。来看下它的组成：</p>
<ul>
<li>抽象工厂角色：<br>工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现</li>
<li>具体工厂角色：<br>含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象</li>
<li>抽象产品角色：<br>它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现</li>
<li>具体产品角色：<br>具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现<br>工厂方法模式使用继承自抽象工厂角色的多个子类来代替简单工厂模式中的“上帝类”。正如上面所说，这样便分担了对象承受的压力；而且这样使得结构变得灵活 起来：当有新的产品（即暴发户的汽车）产生时，只要按照抽象产品角色、抽象工厂角色提供的合同来生成，那么就可以被客户使用，而不必去修改任何已有的代 码。可以看出工厂角色的结构也是符合开闭原则的<br><img src="/2020/04/15/java3/image353.png" alt><br><img src="/2020/04/15/java3/image354.png" alt><br><img src="/2020/04/15/java3/image355.png" alt></li>
</ul>
<p>使用工厂方法模式足以应付我们可能遇到的大部分业务需求。但是当产品种类非常多时，就会出现大量的与之对应的工厂类，这不应该是我们所希望的。所以<strong>建议在这种情况下使用简单工厂模式与工厂方法模式相结合的方式来减少工厂类：即对于产品树上类似的种类（一般是树的叶子中互为兄弟的）使用简单工厂模式来实现</strong></p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>事实上很多时候工厂所产生的产品会划分为很多层次</p>
<ul>
<li>产品族:</li>
</ul>
<p><strong>位于不同产品等级结构中，功能相关联的产品组成的家族<br>如果项目中涉及到多个产品族，则可以使用抽象工厂模式，抽象工厂模式的各个角色和工厂方法的如出一辙:</strong></p>
<ul>
<li>抽象工厂角色:<br>这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现</li>
<li>具体工厂角色:<br>它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。在java中它由具体的类来实现</li>
<li>抽象产品角色:<br>它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现</li>
<li>具体产品角色:</li>
</ul>
<p>具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现<br>抽象工厂模式和工厂方法模式的区别就在于需要创建对象的复杂程度上。而且抽象工厂模式是三个里面最为抽象、最具一般性的。抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族中的产品对象。而且使用抽象工厂模式还要满足一下条件：<br><strong>系统中有多个产品族，而系统一次只可能消费其中一族产品</strong><br><strong>同属于同一个产品族的产品以其使用</strong><br>在抽象工厂模式中，<strong>抽象产品可能是一个或多个，从而构成一个或多个产品族。 在只有一个产品族的情况下，抽象工厂模式实际上退化到工厂方法模式</strong><br> 抽象工厂模式示例参见课堂案例（课堂案例：MagnateAbstractFactory.java），在后续通过JDBC实现DAO访问数据库时会大量使用抽象工厂模式</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>想知道咱们公司最新MM情报吗？<br>加入公司的MM情报邮件组就行了，Jerry负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦<br>假设现在有A、B、C、D等四个独立的对象，其中B、C、D这三个对象想在A对象发生改变的第一时间知道这种改变，以便做出相应的响应。这就是观察者模式。<br>当然每个被观察者可以有多个观察者，每个观察者也可以有多个被观察者。观察者与被观察者也不是对立的，一个对象可以观察其他对象，也可以被其他对象观察<br>Java中通过<strong>Observable类和Observer接口实现了观察者模式</strong>。Observer对象监视着Observable对象的变化，<strong>当Observable对象发生变化时，Observer得到通知</strong>，就可以进行相应的工作<br>Observable类的两个方法比较重要：<br><img src="/2020/04/15/java3/image356.png" alt><br><img src="/2020/04/15/java3/image357.png" alt><br><img src="/2020/04/15/java3/image358.png" alt><br><img src="/2020/04/15/java3/image359.png" alt><br><img src="/2020/04/15/java3/image360.png" alt><br><img src="/2020/04/15/java3/image361.png" alt><br><img src="/2020/04/15/java3/image362.png" alt></p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主体对象与真实主体对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入</p>
<p>在上例中，如果孩子买劣质白菜克扣菜钱一直没有被发现，母亲每次都让他去代为买菜，形成了<strong>客户端和代理的一一绑定关系，我们称为这种代理为静态代理</strong>，这种代理方式实现非常简单<br>如果母亲经常更换代为买菜的目标，如父亲甚至是别人家的孩子用以对比谁更会买菜，那么<strong>客户端和代理实例之间会进行动态关联</strong>，这种代理我们称为<strong>动态代理</strong></p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>相比于静态代理，动态代理避免了我们编写各个繁锁的静态代理类，只需简单地指定一组接口及目标类对象就能动态的获得代理对象<br>JDK中对动态代理提供了默认支持，使用JDK动态代理的步骤如下：<br><strong>通过实现InvocationHandler接口来自定义自己的InvocationHandler</strong><br><strong>通过 Proxy.newProxyInstance()获得动态代理实体</strong><br><strong>通过代理对象调用目标方法</strong></p>
<p><img src="/2020/04/15/java3/image363.png" alt><br><img src="/2020/04/15/java3/image364.png" alt><br><img src="/2020/04/15/java3/image365.png" alt><br><img src="/2020/04/15/java3/image366.png" alt></p>
<p>判断监视聊MM问题</p>
<p><img src="/2020/04/15/java3/image367.png" alt></p>
<p>刚才提到了，代理甚至还可以对结果进行修改，进行伪装和欺骗。下面就对这个过程进行模拟，我们假设一种场景，张三发现自己被 FBI 监控了，他惊恐的企图对外求救，如下所示：</p>
<p><img src="/2020/04/15/java3/image368.png" alt><br><img src="/2020/04/15/java3/image369.png" alt><br><img src="/2020/04/15/java3/image370.png" alt><br><img src="/2020/04/15/java3/image371.png" alt><br><img src="/2020/04/15/java3/image372.png" alt></p>
<p>了解JDK动态代理的实现机理后就会发现，JVM在这个过程中会帮助我们动态构建实际创建对象的代理类，由于有了这个特性，我们可以在很多地方使用动态代理来解决一些看似无法实现的功能，如实现自定义的类似RMI(远程方法调用)的二进制RPC<br>在后续介绍开发框架时，还会发现MyBatis的自动映射机制也离不开JDK动态代理的支持</p>
<h2 id="CGLib简介"><a href="#CGLib简介" class="headerlink" title="CGLib简介"></a>CGLib简介</h2><p>CGLIB(Code Generation Library)是一个开源项目,它是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口<br>CGLIB是一个强大的高性能的代码生成包。它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。最流行的OR Mapping工具hibernate也使用CGLIB来代理单端single-ended(多对一和一对一)关联（对集合的延迟抓取，是采用其他机制实现的）。EasyMock和jMock是通过使用模仿（mock）对象来测试java代码的包。它们都通过使用CGLIB来为那些没有接口的类创建模仿（mock）对象<br>CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。除了CGLIB包，脚本语言例如Groovy和BeanShell，也是使用ASM来生成java的字节码。当然不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉</p>
<p>小结<br>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的，工厂模式在一般分为三类：简单工厂模式、工厂方法模式、抽象工厂模式，这三种模式从上到下逐步抽象，并且更具一般性<br>Java中通过Observable类和Observer接口实现了观察者模式。Observer对象监视着Observable对象的变化，当Observable对象发生变化时，Observer得到通知，就可以进行相应的工作<br>Java中实现单例模式可以通过两种形式实现：懒汉模式（类加载时不初始化）、饿汉模式（在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jinyeeeee.github.io/2020/04/15/java3/" data-id="ck9bi7hcs00061gv0f50h2ph2"
         class="article-share-link">分享</a>
      
    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2020/04/19/mysql/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            mysql
          
        </div>
      </a>
    
    
      <a href="/2020/04/06/spring-aop/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">spring_aop</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
    </div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/technology.js"></script>

  </div>
</body>
</html>